diff -Nru a/include/sound/rt286.h b/include/sound/rt286.h
--- a/include/sound/rt286.h	2015-08-16 23:52:51.000000000 -0400
+++ b/include/sound/rt286.h	2015-08-22 16:54:09.914983000 -0400
@@ -14,6 +14,7 @@
 struct rt286_platform_data {
 	bool cbj_en; /*combo jack enable*/
 	bool gpio2_en; /*GPIO2 enable*/
+	bool suspend_power_off; /* power is off during suspend */
 };
 
 #endif
diff -Nru a/include/sound/rt5677.h b/include/sound/rt5677.h
--- a/include/sound/rt5677.h	2015-08-16 23:52:51.000000000 -0400
+++ b/include/sound/rt5677.h	2015-08-22 16:54:09.914983000 -0400
@@ -12,13 +12,30 @@
 #ifndef __LINUX_SND_RT5677_H
 #define __LINUX_SND_RT5677_H
 
+enum rt5677_micbias {
+	RT5677_MICBIAS_1_476V = 0,
+	RT5677_MICBIAS_2_970V = 1,
+	RT5677_MICBIAS_1_242V = 2,
+	RT5677_MICBIAS_2_475V = 3,
+};
+
 enum rt5677_dmic2_clk {
 	RT5677_DMIC_CLK1 = 0,
 	RT5677_DMIC_CLK2 = 1,
 };
 
+enum rt5677_pdm_clk_div {
+	RT5677_PDM_CLK_DIV1 = 0,
+	RT5677_PDM_CLK_DIV2 = 1,
+	RT5677_PDM_CLK_DIV4 = 2,
+	RT5677_PDM_CLK_DIV3 = 3,
+};
 
 struct rt5677_platform_data {
+	/* MICBIAS output voltage control */
+	enum rt5677_micbias micbias1;
+	/* Select codec internal 1.8V as DACREF source optionally */
+	bool internal_dacref_en;
 	/* IN1/IN2/LOUT1/LOUT2/LOUT3 can optionally be differential */
 	bool in1_diff;
 	bool in2_diff;
@@ -27,9 +44,13 @@
 	bool lout3_diff;
 	/* DMIC2 clock source selection */
 	enum rt5677_dmic2_clk dmic2_clk_pin;
+	/* System clock to PDM filter divider */
+	enum rt5677_pdm_clk_div pdm_clk_div;
 
 	/* configures GPIO, 0 - floating, 1 - pulldown, 2 - pullup */
 	u8 gpio_config[6];
+	/* Asynchronous Sample Rate Converter can be optionally enabled */
+	bool asrc_en;
 
 	/* jd1 can select 0 ~ 3 as OFF, GPIO1, GPIO2 and GPIO3 respectively */
 	unsigned int jd1_gpio;
@@ -37,9 +58,6 @@
 		OFF, GPIO4, GPIO5 and GPIO6 respectively */
 	unsigned int jd2_gpio;
 	unsigned int jd3_gpio;
-
-	/* Set MICBIAS1 VDD 1v8 or 3v3 */
-	bool micbias1_vdd_3v3;
 };
 
 #endif
diff -Nru a/include/sound/soc-dai.h b/include/sound/soc-dai.h
--- a/include/sound/soc-dai.h	2015-08-16 23:52:51.000000000 -0400
+++ b/include/sound/soc-dai.h	2015-08-22 16:54:09.915983000 -0400
@@ -206,6 +206,7 @@
 	/* DAI description */
 	const char *name;
 	unsigned int id;
+	int ac97_control;
 	unsigned int base;
 
 	/* DAI driver callbacks */
@@ -215,8 +216,6 @@
 	int (*resume)(struct snd_soc_dai *dai);
 	/* compress dai */
 	bool compress_dai;
-	/* DAI is also used for the control bus */
-	bool bus_control;
 
 	/* ops */
 	const struct snd_soc_dai_ops *ops;
@@ -242,6 +241,7 @@
 	const char *name;
 	int id;
 	struct device *dev;
+	void *ac97_pdata;	/* platform_data for the ac97 codec */
 
 	/* driver ops */
 	struct snd_soc_dai_driver *driver;
@@ -268,6 +268,7 @@
 	unsigned int sample_bits;
 
 	/* parent platform/codec */
+	struct snd_soc_platform *platform;
 	struct snd_soc_codec *codec;
 	struct snd_soc_component *component;
 
@@ -275,6 +276,8 @@
 	unsigned int tx_mask;
 	unsigned int rx_mask;
 
+	struct snd_soc_card *card;
+
 	struct list_head list;
 };
 
diff -Nru a/include/sound/soc-dapm.h b/include/sound/soc-dapm.h
--- a/include/sound/soc-dapm.h	2015-08-16 23:52:51.000000000 -0400
+++ b/include/sound/soc-dapm.h	2015-08-22 16:54:09.916983000 -0400
@@ -107,6 +107,10 @@
 {	.id = snd_soc_dapm_mux, .name = wname, \
 	SND_SOC_DAPM_INIT_REG_VAL(wreg, wshift, winvert), \
 	.kcontrol_news = wcontrols, .num_kcontrols = 1}
+#define SND_SOC_DAPM_VIRT_MUX(wname, wreg, wshift, winvert, wcontrols) \
+	SND_SOC_DAPM_MUX(wname, wreg, wshift, winvert, wcontrols)
+#define SND_SOC_DAPM_VALUE_MUX(wname, wreg, wshift, winvert, wcontrols) \
+	SND_SOC_DAPM_MUX(wname, wreg, wshift, winvert, wcontrols)
 
 /* Simplified versions of above macros, assuming wncontrols = ARRAY_SIZE(wcontrols) */
 #define SOC_PGA_ARRAY(wname, wreg, wshift, winvert,\
@@ -162,6 +166,10 @@
 	SND_SOC_DAPM_INIT_REG_VAL(wreg, wshift, winvert), \
 	.kcontrol_news = wcontrols, .num_kcontrols = 1, \
 	.event = wevent, .event_flags = wflags}
+#define SND_SOC_DAPM_VIRT_MUX_E(wname, wreg, wshift, winvert, wcontrols, \
+	wevent, wflags) \
+	SND_SOC_DAPM_MUX_E(wname, wreg, wshift, winvert, wcontrols, wevent, \
+		wflags)
 
 /* additional sequencing control within an event type */
 #define SND_SOC_DAPM_PGA_S(wname, wsubseq, wreg, wshift, winvert, \
@@ -287,7 +295,7 @@
 	.access = SNDRV_CTL_ELEM_ACCESS_TLV_READ | SNDRV_CTL_ELEM_ACCESS_READWRITE,\
 	.tlv.p = (tlv_array), \
 	.get = snd_soc_dapm_get_volsw, .put = snd_soc_dapm_put_volsw, \
-	.private_value = SOC_SINGLE_VALUE(reg, shift, max, invert, 1) }
+	.private_value = SOC_SINGLE_VALUE(reg, shift, max, invert, 0) }
 #define SOC_DAPM_SINGLE_TLV_VIRT(xname, max, tlv_array) \
 	SOC_DAPM_SINGLE(xname, SND_SOC_NOPM, 0, max, 0, tlv_array)
 #define SOC_DAPM_ENUM(xname, xenum) \
@@ -296,12 +304,16 @@
  	.get = snd_soc_dapm_get_enum_double, \
  	.put = snd_soc_dapm_put_enum_double, \
   	.private_value = (unsigned long)&xenum }
+#define SOC_DAPM_ENUM_VIRT(xname, xenum) \
+	SOC_DAPM_ENUM(xname, xenum)
 #define SOC_DAPM_ENUM_EXT(xname, xenum, xget, xput) \
 {	.iface = SNDRV_CTL_ELEM_IFACE_MIXER, .name = xname, \
 	.info = snd_soc_info_enum_double, \
 	.get = xget, \
 	.put = xput, \
 	.private_value = (unsigned long)&xenum }
+#define SOC_DAPM_VALUE_ENUM(xname, xenum) \
+	SOC_DAPM_ENUM(xname, xenum)
 #define SOC_DAPM_PIN_SWITCH(xname) \
 {	.iface = SNDRV_CTL_ELEM_IFACE_MIXER, .name = xname " Switch", \
 	.info = snd_soc_dapm_info_pin_switch, \
@@ -378,7 +390,6 @@
 void snd_soc_dapm_connect_dai_link_widgets(struct snd_soc_card *card);
 int snd_soc_dapm_new_pcm(struct snd_soc_card *card,
 			 const struct snd_soc_pcm_stream *params,
-			 unsigned int num_params,
 			 struct snd_soc_dapm_widget *source,
 			 struct snd_soc_dapm_widget *sink);
 
@@ -406,7 +417,7 @@
 		struct snd_soc_dapm_update *update);
 
 /* dapm sys fs - used by the core */
-extern struct attribute *soc_dapm_dev_attrs[];
+int snd_soc_dapm_sys_add(struct device *dev);
 void snd_soc_dapm_debugfs_init(struct snd_soc_dapm_context *dapm,
 				struct dentry *parent);
 
@@ -432,15 +443,16 @@
 					   const char *pin);
 int snd_soc_dapm_ignore_suspend(struct snd_soc_dapm_context *dapm,
 				const char *pin);
-unsigned int dapm_kcontrol_get_value(const struct snd_kcontrol *kcontrol);
+void snd_soc_dapm_auto_nc_pins(struct snd_soc_card *card);
 
 /* Mostly internal - should not normally be used */
-void dapm_mark_endpoints_dirty(struct snd_soc_card *card);
+void dapm_mark_io_dirty(struct snd_soc_dapm_context *dapm);
 
 /* dapm path query */
 int snd_soc_dapm_dai_get_connected_widgets(struct snd_soc_dai *dai, int stream,
 	struct snd_soc_dapm_widget_list **list);
 
+struct snd_soc_codec *snd_soc_dapm_kcontrol_codec(struct snd_kcontrol *kcontrol);
 struct snd_soc_dapm_context *snd_soc_dapm_kcontrol_dapm(
 	struct snd_kcontrol *kcontrol);
 
@@ -507,9 +519,9 @@
 
 	/* status */
 	u32 connect:1;	/* source and sink widgets are connected */
+	u32 walked:1;	/* path has been walked */
 	u32 walking:1;  /* path is in the process of being walked */
 	u32 weak:1;	/* path ignored for power management */
-	u32 is_supply:1;	/* At least one of the connected widgets is a supply */
 
 	int (*connected)(struct snd_soc_dapm_widget *source,
 			 struct snd_soc_dapm_widget *sink);
@@ -525,14 +537,13 @@
 	enum snd_soc_dapm_type id;
 	const char *name;		/* widget name */
 	const char *sname;	/* stream name */
+	struct snd_soc_codec *codec;
 	struct list_head list;
 	struct snd_soc_dapm_context *dapm;
 
 	void *priv;				/* widget specific data */
 	struct regulator *regulator;		/* attached regulator */
 	const struct snd_soc_pcm_stream *params; /* params for dai links */
-	unsigned int num_params; /* number of params for dai links */
-	unsigned int params_select; /* currently selected param for dai link */
 
 	/* dapm control */
 	int reg;				/* negative reg = no direct dapm */
@@ -544,13 +555,11 @@
 	unsigned char active:1;			/* active stream on DAC, ADC's */
 	unsigned char connected:1;		/* connected codec pin */
 	unsigned char new:1;			/* cnew complete */
+	unsigned char ext:1;			/* has external widgets */
 	unsigned char force:1;			/* force state */
 	unsigned char ignore_suspend:1;         /* kept enabled over suspend */
 	unsigned char new_power:1;		/* power from this run */
 	unsigned char power_checked:1;		/* power checked this run */
-	unsigned char is_supply:1;		/* Widget is a supply type widget */
-	unsigned char is_sink:1;		/* Widget is a sink type widget */
-	unsigned char is_source:1;		/* Widget is a source type widget */
 	int subseq;				/* sort within widget type */
 
 	int (*power_check)(struct snd_soc_dapm_widget *w);
@@ -569,7 +578,6 @@
 	struct list_head sinks;
 
 	/* used during DAPM updates */
-	struct list_head work_list;
 	struct list_head power_list;
 	struct list_head dirty;
 	int inputs;
@@ -588,6 +596,8 @@
 /* DAPM context */
 struct snd_soc_dapm_context {
 	enum snd_soc_bias_level bias_level;
+	enum snd_soc_bias_level suspend_bias_level;
+	struct delayed_work delayed_work;
 	unsigned int idle_bias_off:1; /* Use BIAS_OFF instead of STANDBY */
 	/* Go to BIAS_OFF in suspend if the DAPM context is idle */
 	unsigned int suspend_bias_off:1;
@@ -596,6 +606,7 @@
 
 	struct device *dev; /* from parent - for debug */
 	struct snd_soc_component *component; /* parent component */
+	struct snd_soc_codec *codec; /* parent codec */
 	struct snd_soc_card *card; /* parent card */
 
 	/* used during DAPM updates */
diff -Nru a/include/sound/soc-dpcm.h b/include/sound/soc-dpcm.h
--- a/include/sound/soc-dpcm.h	2015-08-16 23:52:51.000000000 -0400
+++ b/include/sound/soc-dpcm.h	2015-08-22 16:54:09.916983000 -0400
@@ -102,8 +102,6 @@
 	/* state and update */
 	enum snd_soc_dpcm_update runtime_update;
 	enum snd_soc_dpcm_state state;
-
-	int trigger_pending; /* trigger cmd + 1 if pending, 0 if not */
 };
 
 /* can this BE stop and free */
@@ -135,7 +133,7 @@
 
 /* internal use only */
 int soc_dpcm_be_digital_mute(struct snd_soc_pcm_runtime *fe, int mute);
-void soc_dpcm_debugfs_add(struct snd_soc_pcm_runtime *rtd);
+int soc_dpcm_debugfs_add(struct snd_soc_pcm_runtime *rtd);
 int soc_dpcm_runtime_update(struct snd_soc_card *);
 
 int dpcm_path_get(struct snd_soc_pcm_runtime *fe,
diff -Nru a/include/sound/soc.h b/include/sound/soc.h
--- a/include/sound/soc.h	2015-08-16 23:52:51.000000000 -0400
+++ b/include/sound/soc.h	2015-08-22 16:54:09.918983000 -0400
@@ -36,11 +36,6 @@
 	{.reg = xreg, .rreg = xreg, .shift = shift_left, \
 	.rshift = shift_right, .max = xmax, .platform_max = xmax, \
 	.invert = xinvert, .autodisable = xautodisable})
-#define SOC_DOUBLE_S_VALUE(xreg, shift_left, shift_right, xmin, xmax, xsign_bit, xinvert, xautodisable) \
-	((unsigned long)&(struct soc_mixer_control) \
-	{.reg = xreg, .rreg = xreg, .shift = shift_left, \
-	.rshift = shift_right, .min = xmin, .max = xmax, .platform_max = xmax, \
-	.sign_bit = xsign_bit, .invert = xinvert, .autodisable = xautodisable})
 #define SOC_SINGLE_VALUE(xreg, xshift, xmax, xinvert, xautodisable) \
 	SOC_DOUBLE_VALUE(xreg, xshift, xshift, xmax, xinvert, xautodisable)
 #define SOC_SINGLE_VALUE_EXT(xreg, xmax, xinvert) \
@@ -176,9 +171,11 @@
 	.access = SNDRV_CTL_ELEM_ACCESS_TLV_READ | \
 		  SNDRV_CTL_ELEM_ACCESS_READWRITE, \
 	.tlv.p  = (tlv_array), \
-	.info = snd_soc_info_volsw, .get = snd_soc_get_volsw,\
-	.put = snd_soc_put_volsw, \
-	.private_value = SOC_DOUBLE_S_VALUE(xreg, 0, 8, xmin, xmax, 7, 0, 0) }
+	.info   = snd_soc_info_volsw_s8, .get = snd_soc_get_volsw_s8, \
+	.put    = snd_soc_put_volsw_s8, \
+	.private_value = (unsigned long)&(struct soc_mixer_control) \
+		{.reg = xreg, .min = xmin, .max = xmax, \
+		 .platform_max = xmax} }
 #define SOC_ENUM_DOUBLE(xreg, xshift_l, xshift_r, xitems, xtexts) \
 {	.reg = xreg, .shift_l = xshift_l, .shift_r = xshift_r, \
 	.items = xitems, .texts = xtexts, \
@@ -199,6 +196,8 @@
 	.info = snd_soc_info_enum_double, \
 	.get = snd_soc_get_enum_double, .put = snd_soc_put_enum_double, \
 	.private_value = (unsigned long)&xenum }
+#define SOC_VALUE_ENUM(xname, xenum) \
+	SOC_ENUM(xname, xenum)
 #define SOC_SINGLE_EXT(xname, xreg, xshift, xmax, xinvert,\
 	 xhandler_get, xhandler_put) \
 {	.iface = SNDRV_CTL_ELEM_IFACE_MIXER, .name = xname, \
@@ -280,7 +279,7 @@
 	.access = SNDRV_CTL_ELEM_ACCESS_TLV_READWRITE | \
 		  SNDRV_CTL_ELEM_ACCESS_TLV_CALLBACK, \
 	.tlv.c = (snd_soc_bytes_tlv_callback), \
-	.info = snd_soc_bytes_info_ext, \
+	.info = snd_soc_info_bytes_ext, \
 	.private_value = (unsigned long)&(struct soc_bytes_ext) \
 		{.max = xcount, .get = xhandler_get, .put = xhandler_put, } }
 #define SOC_SINGLE_XR_SX(xname, xregbase, xregcount, xnbits, \
@@ -369,6 +368,8 @@
 
 typedef int (*hw_write_t)(void *,const char* ,int);
 
+extern struct snd_ac97_bus_ops *soc_ac97_ops;
+
 enum snd_soc_pcm_subclass {
 	SND_SOC_PCM_CLASS_PCM	= 0,
 	SND_SOC_PCM_CLASS_BE	= 1,
@@ -387,20 +388,8 @@
 int snd_soc_register_card(struct snd_soc_card *card);
 int snd_soc_unregister_card(struct snd_soc_card *card);
 int devm_snd_soc_register_card(struct device *dev, struct snd_soc_card *card);
-#ifdef CONFIG_PM_SLEEP
 int snd_soc_suspend(struct device *dev);
 int snd_soc_resume(struct device *dev);
-#else
-static inline int snd_soc_suspend(struct device *dev)
-{
-	return 0;
-}
-
-static inline int snd_soc_resume(struct device *dev)
-{
-	return 0;
-}
-#endif
 int snd_soc_poweroff(struct device *dev);
 int snd_soc_register_platform(struct device *dev,
 		const struct snd_soc_platform_driver *platform_drv);
@@ -422,9 +411,13 @@
 			 const struct snd_soc_component_driver *cmpnt_drv,
 			 struct snd_soc_dai_driver *dai_drv, int num_dai);
 void snd_soc_unregister_component(struct device *dev);
+int snd_soc_cache_sync(struct snd_soc_codec *codec);
 int snd_soc_cache_init(struct snd_soc_codec *codec);
 int snd_soc_cache_exit(struct snd_soc_codec *codec);
-
+int snd_soc_cache_write(struct snd_soc_codec *codec,
+			unsigned int reg, unsigned int value);
+int snd_soc_cache_read(struct snd_soc_codec *codec,
+		       unsigned int reg, unsigned int *value);
 int snd_soc_platform_read(struct snd_soc_platform *platform,
 					unsigned int reg);
 int snd_soc_platform_write(struct snd_soc_platform *platform,
@@ -441,9 +434,6 @@
 void snd_soc_runtime_activate(struct snd_soc_pcm_runtime *rtd, int stream);
 void snd_soc_runtime_deactivate(struct snd_soc_pcm_runtime *rtd, int stream);
 
-int snd_soc_runtime_set_dai_fmt(struct snd_soc_pcm_runtime *rtd,
-	unsigned int dai_fmt);
-
 /* Utility functions to get clock rates from various things */
 int snd_soc_calc_frame_size(int sample_size, int channels, int tdm_slots);
 int snd_soc_params_to_frame_size(struct snd_pcm_hw_params *params);
@@ -462,10 +452,8 @@
 		      struct snd_soc_dai *dai);
 
 /* Jack reporting */
-int snd_soc_card_jack_new(struct snd_soc_card *card, const char *id, int type,
-	struct snd_soc_jack *jack, struct snd_soc_jack_pin *pins,
-	unsigned int num_pins);
-
+int snd_soc_jack_new(struct snd_soc_codec *codec, const char *id, int type,
+		     struct snd_soc_jack *jack);
 void snd_soc_jack_report(struct snd_soc_jack *jack, int status, int mask);
 int snd_soc_jack_add_pins(struct snd_soc_jack *jack, int count,
 			  struct snd_soc_jack_pin *pins);
@@ -484,6 +472,7 @@
 			    int count, struct snd_soc_jack_gpio *gpios);
 void snd_soc_jack_free_gpios(struct snd_soc_jack *jack, int count,
 			struct snd_soc_jack_gpio *gpios);
+void snd_soc_jack_gpio_detect(struct snd_soc_jack_gpio *gpio);
 #else
 static inline int snd_soc_jack_add_gpios(struct snd_soc_jack *jack, int count,
 					 struct snd_soc_jack_gpio *gpios)
@@ -503,6 +492,10 @@
 					   struct snd_soc_jack_gpio *gpios)
 {
 }
+
+void snd_soc_jack_gpio_detect(struct snd_soc_jack_gpio *gpio)
+{
+}
 #endif
 
 /* codec register bit access */
@@ -514,29 +507,14 @@
 int snd_soc_test_bits(struct snd_soc_codec *codec, unsigned int reg,
 				unsigned int mask, unsigned int value);
 
-#ifdef CONFIG_SND_SOC_AC97_BUS
-struct snd_ac97 *snd_soc_alloc_ac97_codec(struct snd_soc_codec *codec);
-struct snd_ac97 *snd_soc_new_ac97_codec(struct snd_soc_codec *codec);
-void snd_soc_free_ac97_codec(struct snd_ac97 *ac97);
+int snd_soc_new_ac97_codec(struct snd_soc_codec *codec,
+	struct snd_ac97_bus_ops *ops, int num);
+void snd_soc_free_ac97_codec(struct snd_soc_codec *codec);
 
 int snd_soc_set_ac97_ops(struct snd_ac97_bus_ops *ops);
 int snd_soc_set_ac97_ops_of_reset(struct snd_ac97_bus_ops *ops,
 		struct platform_device *pdev);
 
-extern struct snd_ac97_bus_ops *soc_ac97_ops;
-#else
-static inline int snd_soc_set_ac97_ops_of_reset(struct snd_ac97_bus_ops *ops,
-	struct platform_device *pdev)
-{
-	return 0;
-}
-
-static inline int snd_soc_set_ac97_ops(struct snd_ac97_bus_ops *ops)
-{
-	return 0;
-}
-#endif
-
 /*
  *Controls
  */
@@ -574,6 +552,12 @@
 	struct snd_ctl_elem_value *ucontrol);
 int snd_soc_put_volsw_sx(struct snd_kcontrol *kcontrol,
 	struct snd_ctl_elem_value *ucontrol);
+int snd_soc_info_volsw_s8(struct snd_kcontrol *kcontrol,
+	struct snd_ctl_elem_info *uinfo);
+int snd_soc_get_volsw_s8(struct snd_kcontrol *kcontrol,
+	struct snd_ctl_elem_value *ucontrol);
+int snd_soc_put_volsw_s8(struct snd_kcontrol *kcontrol,
+	struct snd_ctl_elem_value *ucontrol);
 int snd_soc_info_volsw_range(struct snd_kcontrol *kcontrol,
 	struct snd_ctl_elem_info *uinfo);
 int snd_soc_put_volsw_range(struct snd_kcontrol *kcontrol,
@@ -673,7 +657,7 @@
 struct snd_soc_jack {
 	struct mutex mutex;
 	struct snd_jack *jack;
-	struct snd_soc_card *card;
+	struct snd_soc_codec *codec;
 	struct list_head pins;
 	int status;
 	struct blocking_notifier_head notifier;
@@ -713,17 +697,6 @@
 struct snd_soc_component_driver {
 	const char *name;
 
-	/* Default control and setup, added after probe() is run */
-	const struct snd_kcontrol_new *controls;
-	unsigned int num_controls;
-	const struct snd_soc_dapm_widget *dapm_widgets;
-	unsigned int num_dapm_widgets;
-	const struct snd_soc_dapm_route *dapm_routes;
-	unsigned int num_dapm_routes;
-
-	int (*probe)(struct snd_soc_component *);
-	void (*remove)(struct snd_soc_component *);
-
 	/* DT */
 	int (*of_xlate_dai_name)(struct snd_soc_component *component,
 				 struct of_phandle_args *args,
@@ -731,10 +704,6 @@
 	void (*seq_notifier)(struct snd_soc_component *, enum snd_soc_dapm_type,
 		int subseq);
 	int (*stream_event)(struct snd_soc_component *, int event);
-
-	/* probe ordering - for components with runtime dependencies */
-	int probe_order;
-	int remove_order;
 };
 
 struct snd_soc_component {
@@ -748,7 +717,6 @@
 
 	unsigned int ignore_pmdown_time:1; /* pmdown_time is ignored at stop */
 	unsigned int registered_as_component:1;
-	unsigned int probed:1;
 
 	struct list_head list;
 
@@ -767,35 +735,9 @@
 
 	struct mutex io_mutex;
 
-#ifdef CONFIG_DEBUG_FS
-	struct dentry *debugfs_root;
-#endif
-
-	/*
-	* DO NOT use any of the fields below in drivers, they are temporary and
-	* are going to be removed again soon. If you use them in driver code the
-	* driver will be marked as BROKEN when these fields are removed.
-	*/
-
 	/* Don't use these, use snd_soc_component_get_dapm() */
 	struct snd_soc_dapm_context dapm;
 	struct snd_soc_dapm_context *dapm_ptr;
-
-	const struct snd_kcontrol_new *controls;
-	unsigned int num_controls;
-	const struct snd_soc_dapm_widget *dapm_widgets;
-	unsigned int num_dapm_widgets;
-	const struct snd_soc_dapm_route *dapm_routes;
-	unsigned int num_dapm_routes;
-	struct snd_soc_codec *codec;
-
-	int (*probe)(struct snd_soc_component *);
-	void (*remove)(struct snd_soc_component *);
-
-#ifdef CONFIG_DEBUG_FS
-	void (*init_debugfs)(struct snd_soc_component *component);
-	const char *debugfs_prefix;
-#endif
 };
 
 /* SoC Audio Codec device */
@@ -803,18 +745,26 @@
 	struct device *dev;
 	const struct snd_soc_codec_driver *driver;
 
+	struct mutex mutex;
 	struct list_head list;
 	struct list_head card_list;
 
 	/* runtime */
+	struct snd_ac97 *ac97;  /* for ad-hoc ac97 devices */
 	unsigned int cache_bypass:1; /* Suppress access to the cache */
 	unsigned int suspended:1; /* Codec is in suspend PM state */
+	unsigned int probed:1; /* Codec has been probed */
+	unsigned int ac97_registered:1; /* Codec has been AC97 registered */
+	unsigned int ac97_created:1; /* Codec has been created by SoC */
 	unsigned int cache_init:1; /* codec cache has been initialized */
+	u32 cache_only;  /* Suppress writes to hardware */
+	u32 cache_sync; /* Cache needs to be synced to hardware */
 
 	/* codec IO */
 	void *control_data; /* codec control (i2c/3wire) data */
 	hw_write_t hw_write;
 	void *reg_cache;
+	struct mutex cache_rw_mutex;
 
 	/* component */
 	struct snd_soc_component component;
@@ -823,6 +773,7 @@
 	struct snd_soc_dapm_context dapm;
 
 #ifdef CONFIG_DEBUG_FS
+	struct dentry *debugfs_codec_root;
 	struct dentry *debugfs_reg;
 #endif
 };
@@ -870,6 +821,10 @@
 			     enum snd_soc_dapm_type, int);
 
 	bool ignore_pmdown_time;  /* Doesn't benefit from pmdown delay */
+
+	/* probe ordering - for components with runtime dependencies */
+	int probe_order;
+	int remove_order;
 };
 
 /* SoC platform interface */
@@ -877,12 +832,22 @@
 
 	int (*probe)(struct snd_soc_platform *);
 	int (*remove)(struct snd_soc_platform *);
+	int (*suspend)(struct snd_soc_dai *dai);
+	int (*resume)(struct snd_soc_dai *dai);
 	struct snd_soc_component_driver component_driver;
 
 	/* pcm creation and destruction */
 	int (*pcm_new)(struct snd_soc_pcm_runtime *);
 	void (*pcm_free)(struct snd_pcm *);
 
+	/* Default control and setup, added after probe() is run */
+	const struct snd_kcontrol_new *controls;
+	int num_controls;
+	const struct snd_soc_dapm_widget *dapm_widgets;
+	int num_dapm_widgets;
+	const struct snd_soc_dapm_route *dapm_routes;
+	int num_dapm_routes;
+
 	/*
 	 * For platform caused delay reporting.
 	 * Optional.
@@ -896,12 +861,19 @@
 	/* platform stream compress ops */
 	const struct snd_compr_ops *compr_ops;
 
+	/* probe ordering - for components with runtime dependencies */
+	int probe_order;
+	int remove_order;
+
+	/* platform IO - used for platform DAPM */
+	unsigned int (*read)(struct snd_soc_platform *, unsigned int);
+	int (*write)(struct snd_soc_platform *, unsigned int, unsigned int);
 	int (*bespoke_trigger)(struct snd_pcm_substream *, int);
 };
 
 struct snd_soc_dai_link_component {
 	const char *name;
-	struct device_node *of_node;
+	const struct device_node *of_node;
 	const char *dai_name;
 };
 
@@ -909,9 +881,16 @@
 	struct device *dev;
 	const struct snd_soc_platform_driver *driver;
 
+	unsigned int suspended:1; /* platform is suspended */
+	unsigned int probed:1;
+
 	struct list_head list;
 
 	struct snd_soc_component component;
+
+#ifdef CONFIG_DEBUG_FS
+	struct dentry *debugfs_platform_root;
+#endif
 };
 
 struct snd_soc_dai_link {
@@ -926,7 +905,7 @@
 	 * only for codec to codec links, or systems using device tree.
 	 */
 	const char *cpu_name;
-	struct device_node *cpu_of_node;
+	const struct device_node *cpu_of_node;
 	/*
 	 * You MAY specify the DAI name of the CPU DAI. If this information is
 	 * omitted, the CPU-side DAI is matched using .cpu_name/.cpu_of_node
@@ -938,7 +917,7 @@
 	 * DT/OF node, but not both.
 	 */
 	const char *codec_name;
-	struct device_node *codec_of_node;
+	const struct device_node *codec_of_node;
 	/* You MUST specify the DAI name within the codec */
 	const char *codec_dai_name;
 
@@ -951,11 +930,10 @@
 	 * do not need a platform.
 	 */
 	const char *platform_name;
-	struct device_node *platform_of_node;
+	const struct device_node *platform_of_node;
 	int be_id;	/* optional ID for machine driver BE identification */
 
 	const struct snd_soc_pcm_stream *params;
-	unsigned int num_params;
 
 	unsigned int dai_fmt;           /* format to set on init */
 
@@ -969,9 +947,6 @@
 	unsigned int symmetric_channels:1;
 	unsigned int symmetric_samplebits:1;
 
-	/* Mark this pcm with non atomic ops */
-	bool nonatomic;
-
 	/* Do not create a PCM for this DAI link (Backend link) */
 	unsigned int no_pcm:1;
 
@@ -1007,7 +982,7 @@
 	 * DT/OF node, but not both.
 	 */
 	const char *dev_name;
-	struct device_node *of_node;
+	const struct device_node *of_node;
 
 	/*
 	 * optional map of kcontrol, widget and path name prefixes that are
@@ -1024,10 +999,10 @@
 	 * DT/OF node, but not both.
 	 */
 	const char *codec_name;
-	struct device_node *codec_of_node;
+	const struct device_node *codec_of_node;
 
 	/* codec/machine specific init - e.g. add machine controls */
-	int (*init)(struct snd_soc_component *component);
+	int (*init)(struct snd_soc_dapm_context *dapm);
 };
 
 /* SoC card */
@@ -1089,16 +1064,11 @@
 
 	/*
 	 * Card-specific routes and widgets.
-	 * Note: of_dapm_xxx for Device Tree; Otherwise for driver build-in.
 	 */
 	const struct snd_soc_dapm_widget *dapm_widgets;
 	int num_dapm_widgets;
 	const struct snd_soc_dapm_route *dapm_routes;
 	int num_dapm_routes;
-	const struct snd_soc_dapm_widget *of_dapm_widgets;
-	int num_of_dapm_widgets;
-	const struct snd_soc_dapm_route *of_dapm_routes;
-	int num_of_dapm_routes;
 	bool fully_routed;
 
 	struct work_struct deferred_resume_work;
@@ -1150,7 +1120,6 @@
 	struct snd_soc_platform *platform;
 	struct snd_soc_dai *codec_dai;
 	struct snd_soc_dai *cpu_dai;
-	struct snd_soc_component *component; /* Only valid for AUX dev rtds */
 
 	struct snd_soc_dai **codec_dais;
 	unsigned int num_codecs;
@@ -1281,35 +1250,11 @@
 	return component->dapm_ptr;
 }
 
-/**
- * snd_soc_dapm_kcontrol_codec() - Returns the codec associated to a kcontrol
- * @kcontrol: The kcontrol
- *
- * This function must only be used on DAPM contexts that are known to be part of
- * a CODEC (e.g. in a CODEC driver). Otherwise the behavior is undefined.
- */
-static inline struct snd_soc_codec *snd_soc_dapm_kcontrol_codec(
-	struct snd_kcontrol *kcontrol)
-{
-	return snd_soc_dapm_to_codec(snd_soc_dapm_kcontrol_dapm(kcontrol));
-}
-
 /* codec IO */
 unsigned int snd_soc_read(struct snd_soc_codec *codec, unsigned int reg);
 int snd_soc_write(struct snd_soc_codec *codec, unsigned int reg,
 	unsigned int val);
 
-/**
- * snd_soc_cache_sync() - Sync the register cache with the hardware
- * @codec: CODEC to sync
- *
- * Note: This function will call regcache_sync()
- */
-static inline int snd_soc_cache_sync(struct snd_soc_codec *codec)
-{
-	return regcache_sync(codec->component.regmap);
-}
-
 /* component IO */
 int snd_soc_component_read(struct snd_soc_component *component,
 	unsigned int reg, unsigned int *val);
@@ -1323,44 +1268,8 @@
 int snd_soc_component_test_bits(struct snd_soc_component *component,
 	unsigned int reg, unsigned int mask, unsigned int value);
 
-#ifdef CONFIG_REGMAP
-
-void snd_soc_component_init_regmap(struct snd_soc_component *component,
+int snd_soc_component_init_io(struct snd_soc_component *component,
 	struct regmap *regmap);
-void snd_soc_component_exit_regmap(struct snd_soc_component *component);
-
-/**
- * snd_soc_codec_init_regmap() - Initialize regmap instance for the CODEC
- * @codec: The CODEC for which to initialize the regmap instance
- * @regmap: The regmap instance that should be used by the CODEC
- *
- * This function allows deferred assignment of the regmap instance that is
- * associated with the CODEC. Only use this if the regmap instance is not yet
- * ready when the CODEC is registered. The function must also be called before
- * the first IO attempt of the CODEC.
- */
-static inline void snd_soc_codec_init_regmap(struct snd_soc_codec *codec,
-	struct regmap *regmap)
-{
-	snd_soc_component_init_regmap(&codec->component, regmap);
-}
-
-/**
- * snd_soc_codec_exit_regmap() - De-initialize regmap instance for the CODEC
- * @codec: The CODEC for which to de-initialize the regmap instance
- *
- * Calls regmap_exit() on the regmap instance associated to the CODEC and
- * removes the regmap instance from the CODEC.
- *
- * This function should only be used if snd_soc_codec_init_regmap() was used to
- * initialize the regmap instance.
- */
-static inline void snd_soc_codec_exit_regmap(struct snd_soc_codec *codec)
-{
-	snd_soc_component_exit_regmap(&codec->component);
-}
-
-#endif
 
 /* device driver data */
 
@@ -1375,37 +1284,26 @@
 	return card->drvdata;
 }
 
-static inline void snd_soc_component_set_drvdata(struct snd_soc_component *c,
-		void *data)
-{
-	dev_set_drvdata(c->dev, data);
-}
-
-static inline void *snd_soc_component_get_drvdata(struct snd_soc_component *c)
-{
-	return dev_get_drvdata(c->dev);
-}
-
 static inline void snd_soc_codec_set_drvdata(struct snd_soc_codec *codec,
 		void *data)
 {
-	snd_soc_component_set_drvdata(&codec->component, data);
+	dev_set_drvdata(codec->dev, data);
 }
 
 static inline void *snd_soc_codec_get_drvdata(struct snd_soc_codec *codec)
 {
-	return snd_soc_component_get_drvdata(&codec->component);
+	return dev_get_drvdata(codec->dev);
 }
 
 static inline void snd_soc_platform_set_drvdata(struct snd_soc_platform *platform,
 		void *data)
 {
-	snd_soc_component_set_drvdata(&platform->component, data);
+	dev_set_drvdata(platform->dev, data);
 }
 
 static inline void *snd_soc_platform_get_drvdata(struct snd_soc_platform *platform)
 {
-	return snd_soc_component_get_drvdata(&platform->component);
+	return dev_get_drvdata(platform->dev);
 }
 
 static inline void snd_soc_pcm_set_drvdata(struct snd_soc_pcm_runtime *rtd,
@@ -1505,7 +1403,7 @@
 }
 
 /**
- * snd_soc_kcontrol_platform() - Returns the platform that registered the control
+ * snd_soc_kcontrol_platform() - Returns the platform that registerd the control
  * @kcontrol: The control for which to get the platform
  *
  * Note: This function will only work correctly if the control has been
@@ -1536,9 +1434,6 @@
 				     struct device_node **framemaster);
 int snd_soc_of_get_dai_name(struct device_node *of_node,
 			    const char **dai_name);
-int snd_soc_of_get_dai_link_codecs(struct device *dev,
-				   struct device_node *of_node,
-				   struct snd_soc_dai_link *dai_link);
 
 #include <sound/soc-dai.h>
 
Binary files a/sound/soc/.soc-dapm.c.un~ and b/sound/soc/.soc-dapm.c.un~ differ
diff -Nru a/sound/soc/Makefile b/sound/soc/Makefile
--- a/sound/soc/Makefile	2015-08-16 23:52:51.000000000 -0400
+++ b/sound/soc/Makefile	2015-08-22 16:54:09.930983000 -0400
@@ -1,5 +1,5 @@
 snd-soc-core-objs := soc-core.o soc-dapm.o soc-jack.o soc-cache.o soc-utils.o
-snd-soc-core-objs += soc-pcm.o soc-compress.o soc-io.o soc-devres.o soc-ops.o
+snd-soc-core-objs += soc-pcm.o soc-compress.o soc-io.o soc-devres.o
 
 ifneq ($(CONFIG_SND_SOC_GENERIC_DMAENGINE_PCM),)
 snd-soc-core-objs += soc-generic-dmaengine-pcm.o
diff -Nru a/sound/soc/codecs/rt286.c b/sound/soc/codecs/rt286.c
--- a/sound/soc/codecs/rt286.c	2015-08-16 23:52:51.000000000 -0400
+++ b/sound/soc/codecs/rt286.c	2015-08-22 16:54:09.943983000 -0400
@@ -17,7 +17,6 @@
 #include <linux/i2c.h>
 #include <linux/platform_device.h>
 #include <linux/spi/spi.h>
-#include <linux/dmi.h>
 #include <linux/acpi.h>
 #include <sound/core.h>
 #include <sound/pcm.h>
@@ -34,14 +33,14 @@
 #include "rt286.h"
 
 #define RT286_VENDOR_ID 0x10ec0286
-#define RT288_VENDOR_ID 0x10ec0288
 
 struct rt286_priv {
 	struct regmap *regmap;
 	struct snd_soc_codec *codec;
 	struct rt286_platform_data pdata;
 	struct i2c_client *i2c;
-	struct snd_soc_jack *jack;
+	struct snd_soc_jack *hp_jack;
+	struct snd_soc_jack *mic_jack;
 	struct delayed_work jack_detect_work;
 	int sys_clk;
 	int clk_id;
@@ -192,7 +191,7 @@
 	u8 data[4];
 	int ret, i;
 
-	/* handle index registers */
+	/*handle index registers*/
 	if (reg <= 0xff) {
 		rt286_hw_write(client, RT286_COEF_INDEX, reg);
 		for (i = 0; i < INDEX_CACHE_SIZE; i++) {
@@ -235,7 +234,7 @@
 	__be32 be_reg;
 	unsigned int index, vid, buf = 0x0;
 
-	/* handle index registers */
+	/*handle index registers*/
 	if (reg <= 0xff) {
 		rt286_hw_write(client, RT286_COEF_INDEX, reg);
 		reg = RT286_PROC_COEF;
@@ -273,7 +272,6 @@
 	return 0;
 }
 
-#ifdef CONFIG_PM
 static void rt286_index_sync(struct snd_soc_codec *codec)
 {
 	struct rt286_priv *rt286 = snd_soc_codec_get_drvdata(codec);
@@ -284,7 +282,6 @@
 				  rt286->index_cache[i].def);
 	}
 }
-#endif
 
 static int rt286_support_power_controls[] = {
 	RT286_DAC_OUT1,
@@ -301,69 +298,99 @@
 
 static int rt286_jack_detect(struct rt286_priv *rt286, bool *hp, bool *mic)
 {
-	unsigned int val, buf;
+	unsigned int val, buf, vm = 0;
+	int i;
 
 	*hp = false;
 	*mic = false;
 
 	if (!rt286->codec)
-		return -EINVAL;
+		return 0;
+
+	/* power on HV,VERF */
+	snd_soc_dapm_force_enable_pin(&rt286->codec->dapm, "VREF");
+	snd_soc_dapm_force_enable_pin(&rt286->codec->dapm, "LDO1");
+	snd_soc_dapm_sync(&rt286->codec->dapm);
 	if (rt286->pdata.cbj_en) {
 		regmap_read(rt286->regmap, RT286_GET_HP_SENSE, &buf);
 		*hp = buf & 0x80000000;
 		if (*hp) {
-			/* power on HV,VERF */
-			regmap_update_bits(rt286->regmap,
-				RT286_DC_GAIN, 0x200, 0x200);
-
-			snd_soc_dapm_force_enable_pin(&rt286->codec->dapm,
-							"HV");
-			snd_soc_dapm_force_enable_pin(&rt286->codec->dapm,
-							"VREF");
 			/* power LDO1 */
-			snd_soc_dapm_force_enable_pin(&rt286->codec->dapm,
-							"LDO1");
-			snd_soc_dapm_sync(&rt286->codec->dapm);
-
-			regmap_write(rt286->regmap, RT286_SET_MIC1, 0x24);
-			msleep(50);
-
 			regmap_update_bits(rt286->regmap,
-				RT286_CBJ_CTRL1, 0xfcc0, 0xd400);
-			msleep(300);
+				RT286_POWER_CTRL2, 0x4, 0x4);
+			regmap_write(rt286->regmap, RT286_SET_MIC1, 0x24);
 			regmap_read(rt286->regmap, RT286_CBJ_CTRL2, &val);
 
-			if (0x0070 == (val & 0x0070)) {
-				*mic = true;
-			} else {
-				regmap_update_bits(rt286->regmap,
-					RT286_CBJ_CTRL1, 0xfcc0, 0xe400);
-				msleep(300);
+			msleep(200);
+			i = 40;
+			while (((val & 0x0800) == 0) && (i > 0)) {
 				regmap_read(rt286->regmap,
 					RT286_CBJ_CTRL2, &val);
-				if (0x0070 == (val & 0x0070))
-					*mic = true;
-				else
-					*mic = false;
+				i--;
+				msleep(20);
+			}
+
+			if (0x0400 == (val & 0x0700)) {
+				*mic = false;
+
+				regmap_write(rt286->regmap,
+					RT286_SET_MIC1, 0x20);
+				regmap_update_bits(rt286->regmap,
+					RT286_A_BIAS_CTRL3, 0xc000, 0x0000);
+				regmap_update_bits(rt286->regmap,
+					RT286_CBJ_CTRL1, 0x0030, 0x0000);
+				regmap_update_bits(rt286->regmap,
+					RT286_A_BIAS_CTRL2, 0xc000, 0x0000);
+			} else if ((0x0200 == (val & 0x0700)) ||
+				(0x0100 == (val & 0x0700))) {
+				*mic = true;
+				regmap_update_bits(rt286->regmap,
+					RT286_A_BIAS_CTRL3, 0xc000, 0x8000);
+				regmap_update_bits(rt286->regmap,
+					RT286_CBJ_CTRL1, 0x0030, 0x0020);
+				regmap_update_bits(rt286->regmap,
+					RT286_A_BIAS_CTRL2, 0xc000, 0x8000);
+			} else {
+				*mic = false;
 			}
-			regmap_update_bits(rt286->regmap,
-				RT286_DC_GAIN, 0x200, 0x0);
 
+			regmap_update_bits(rt286->regmap,
+						RT286_MISC_CTRL1,
+						0x0060, 0x0000);
 		} else {
+			regmap_update_bits(rt286->regmap,
+						RT286_MISC_CTRL1,
+						0x0060, 0x0020);
+			regmap_update_bits(rt286->regmap,
+						RT286_A_BIAS_CTRL3,
+						0xc000, 0x8000);
+			regmap_update_bits(rt286->regmap,
+						RT286_CBJ_CTRL1,
+						0x0030, 0x0020);
+			regmap_update_bits(rt286->regmap,
+						RT286_A_BIAS_CTRL2,
+						0xc000, 0x8000);
+			regmap_write(rt286->regmap,
+					RT286_SET_MIC1, 0x0);
 			*mic = false;
-			regmap_write(rt286->regmap, RT286_SET_MIC1, 0x20);
 		}
 	} else {
 		regmap_read(rt286->regmap, RT286_GET_HP_SENSE, &buf);
 		*hp = buf & 0x80000000;
 		regmap_read(rt286->regmap, RT286_GET_MIC1_SENSE, &buf);
 		*mic = buf & 0x80000000;
+		if (*mic)
+			vm |= 0x4;
+		if (*hp)
+			vm |= 0x20;
+
+		regmap_write(rt286->regmap, RT286_SET_MIC1, vm);
 	}
 
-	snd_soc_dapm_disable_pin(&rt286->codec->dapm, "HV");
-	snd_soc_dapm_disable_pin(&rt286->codec->dapm, "VREF");
 	if (!*hp)
 		snd_soc_dapm_disable_pin(&rt286->codec->dapm, "LDO1");
+
+	snd_soc_dapm_disable_pin(&rt286->codec->dapm, "VREF");
 	snd_soc_dapm_sync(&rt286->codec->dapm);
 
 	return 0;
@@ -385,40 +412,63 @@
 	if (mic == true)
 		status |= SND_JACK_MICROPHONE;
 
-	snd_soc_jack_report(rt286->jack, status,
-		SND_JACK_MICROPHONE | SND_JACK_HEADPHONE);
+	snd_soc_jack_report(rt286->hp_jack, status, SND_JACK_HEADPHONE);
+	snd_soc_jack_report(rt286->mic_jack, status, SND_JACK_MICROPHONE);
 }
 
-int rt286_mic_detect(struct snd_soc_codec *codec, struct snd_soc_jack *jack)
+int rt286_mic_detect(struct snd_soc_codec *codec, struct snd_soc_jack *hp_jack,
+			struct snd_soc_jack *mic_jack)
 {
 	struct rt286_priv *rt286 = snd_soc_codec_get_drvdata(codec);
 
-	rt286->jack = jack;
+	rt286->hp_jack = hp_jack;
+	rt286->mic_jack = mic_jack;
 
-	if (jack) {
-		/* enable IRQ */
-		if (rt286->jack->status & SND_JACK_HEADPHONE)
-			snd_soc_dapm_force_enable_pin(&codec->dapm, "LDO1");
-		regmap_update_bits(rt286->regmap, RT286_IRQ_CTRL, 0x2, 0x2);
-		/* Send an initial empty report */
-		snd_soc_jack_report(rt286->jack, rt286->jack->status,
-			SND_JACK_MICROPHONE | SND_JACK_HEADPHONE);
-	} else {
-		/* disable IRQ */
-		regmap_update_bits(rt286->regmap, RT286_IRQ_CTRL, 0x2, 0x0);
-		snd_soc_dapm_disable_pin(&codec->dapm, "LDO1");
-	}
-	snd_soc_dapm_sync(&codec->dapm);
+	/* Send an initial empty report */
+	snd_soc_jack_report(rt286->hp_jack, 0, SND_JACK_HEADPHONE);
+	snd_soc_jack_report(rt286->mic_jack, 0, SND_JACK_MICROPHONE);
 
 	return 0;
 }
 EXPORT_SYMBOL_GPL(rt286_mic_detect);
 
+/**
+ * rt286_set_jack_type - Configure the HW supported jack type
+ *
+ * @codec:   RT286 codec
+ * @type:    supported jack type
+ *
+ * RT286 need to configure the jack type (combo or non-combo) according to the
+ * HW design. This function is given a easy way to set the correct jacy type
+ * for those without platform data supported.
+ */
+void rt286_set_jack_type(struct snd_soc_codec *codec,
+				enum rt286_jack_type type)
+{
+	struct rt286_priv *rt286 = snd_soc_codec_get_drvdata(codec);
+
+	if (RT286_TYPE_COMBO == type)
+		rt286->pdata.cbj_en = true;
+	else
+		rt286->pdata.cbj_en = false;
+
+	if (!rt286->pdata.cbj_en) {
+		regmap_write(rt286->regmap, RT286_CBJ_CTRL2, 0x0000);
+		regmap_write(rt286->regmap, RT286_MIC1_DET_CTRL, 0x0816);
+		regmap_write(rt286->regmap, RT286_MISC_CTRL1, 0x0000);
+		regmap_update_bits(rt286->regmap,
+					RT286_CBJ_CTRL1, 0xf000, 0xb000);
+	} else {
+		regmap_update_bits(rt286->regmap,
+					RT286_CBJ_CTRL1, 0xf000, 0x5000);
+	}
+}
+EXPORT_SYMBOL_GPL(rt286_set_jack_type);
+
 static int is_mclk_mode(struct snd_soc_dapm_widget *source,
 			 struct snd_soc_dapm_widget *sink)
 {
-	struct snd_soc_codec *codec = snd_soc_dapm_to_codec(source->dapm);
-	struct rt286_priv *rt286 = snd_soc_codec_get_drvdata(codec);
+	struct rt286_priv *rt286 = snd_soc_codec_get_drvdata(source->codec);
 
 	if (rt286->clk_id == RT286_SCLK_S_MCLK)
 		return 1;
@@ -432,8 +482,6 @@
 static const struct snd_kcontrol_new rt286_snd_controls[] = {
 	SOC_DOUBLE_R_TLV("DAC0 Playback Volume", RT286_DACL_GAIN,
 			    RT286_DACR_GAIN, 0, 0x7f, 0, out_vol_tlv),
-	SOC_DOUBLE_R("ADC0 Capture Switch", RT286_ADCL_GAIN,
-			    RT286_ADCR_GAIN, 7, 1, 1),
 	SOC_DOUBLE_R_TLV("ADC0 Capture Volume", RT286_ADCL_GAIN,
 			    RT286_ADCR_GAIN, 0, 0x7f, 0, out_vol_tlv),
 	SOC_SINGLE_TLV("AMIC Volume", RT286_MIC_GAIN,
@@ -517,7 +565,7 @@
 static int rt286_spk_event(struct snd_soc_dapm_widget *w,
 			    struct snd_kcontrol *kcontrol, int event)
 {
-	struct snd_soc_codec *codec = snd_soc_dapm_to_codec(w->dapm);
+	struct snd_soc_codec *codec = w->codec;
 
 	switch (event) {
 	case SND_SOC_DAPM_POST_PMU:
@@ -539,7 +587,7 @@
 static int rt286_set_dmic1_event(struct snd_soc_dapm_widget *w,
 				  struct snd_kcontrol *kcontrol, int event)
 {
-	struct snd_soc_codec *codec = snd_soc_dapm_to_codec(w->dapm);
+	struct snd_soc_codec *codec = w->codec;
 
 	switch (event) {
 	case SND_SOC_DAPM_POST_PMU:
@@ -555,16 +603,24 @@
 	return 0;
 }
 
-static int rt286_vref_event(struct snd_soc_dapm_widget *w,
+static int rt286_adc_event(struct snd_soc_dapm_widget *w,
 			     struct snd_kcontrol *kcontrol, int event)
 {
-	struct snd_soc_codec *codec = snd_soc_dapm_to_codec(w->dapm);
+	struct snd_soc_codec *codec = w->codec;
+	unsigned int nid;
+
+	nid = (w->reg >> 20) & 0xff;
 
 	switch (event) {
-	case SND_SOC_DAPM_PRE_PMU:
+	case SND_SOC_DAPM_POST_PMU:
 		snd_soc_update_bits(codec,
-			RT286_CBJ_CTRL1, 0x0400, 0x0000);
-		mdelay(50);
+			VERB_CMD(AC_VERB_SET_AMP_GAIN_MUTE, nid, 0),
+			0x7080, 0x7000);
+		break;
+	case SND_SOC_DAPM_PRE_PMD:
+		snd_soc_update_bits(codec,
+			VERB_CMD(AC_VERB_SET_AMP_GAIN_MUTE, nid, 0),
+			0x7080, 0x7080);
 		break;
 	default:
 		return 0;
@@ -573,17 +629,24 @@
 	return 0;
 }
 
-static int rt286_ldo2_event(struct snd_soc_dapm_widget *w,
+static int rt286_vref_event(struct snd_soc_dapm_widget *w,
 			     struct snd_kcontrol *kcontrol, int event)
 {
-	struct snd_soc_codec *codec = snd_soc_dapm_to_codec(w->dapm);
+	struct snd_soc_codec *codec = w->codec;
 
 	switch (event) {
+	case SND_SOC_DAPM_PRE_PMU:
+		snd_soc_update_bits(codec,
+			RT286_CBJ_CTRL1, 0x8400, 0x8000);
+		mdelay(50);
+		break;
 	case SND_SOC_DAPM_POST_PMU:
-		snd_soc_update_bits(codec, RT286_POWER_CTRL2, 0x38, 0x08);
+		snd_soc_update_bits(codec,
+			RT286_POWER_CTRL1, 0x1, 0x0);
 		break;
 	case SND_SOC_DAPM_PRE_PMD:
-		snd_soc_update_bits(codec, RT286_POWER_CTRL2, 0x38, 0x30);
+		snd_soc_update_bits(codec,
+			RT286_POWER_CTRL1, 0x1, 0x1);
 		break;
 	default:
 		return 0;
@@ -592,23 +655,17 @@
 	return 0;
 }
 
-static int rt286_mic1_event(struct snd_soc_dapm_widget *w,
+static int rt286_ldo2_event(struct snd_soc_dapm_widget *w,
 			     struct snd_kcontrol *kcontrol, int event)
 {
-	struct snd_soc_codec *codec = snd_soc_dapm_to_codec(w->dapm);
+	struct snd_soc_codec *codec = w->codec;
 
 	switch (event) {
-	case SND_SOC_DAPM_PRE_PMU:
-		snd_soc_update_bits(codec,
-			RT286_A_BIAS_CTRL3, 0xc000, 0x8000);
-		snd_soc_update_bits(codec,
-			RT286_A_BIAS_CTRL2, 0xc000, 0x8000);
+	case SND_SOC_DAPM_POST_PMU:
+		snd_soc_update_bits(codec, RT286_POWER_CTRL2, 0x38, 0x08);
 		break;
-	case SND_SOC_DAPM_POST_PMD:
-		snd_soc_update_bits(codec,
-			RT286_A_BIAS_CTRL3, 0xc000, 0x0000);
-		snd_soc_update_bits(codec,
-			RT286_A_BIAS_CTRL2, 0xc000, 0x0000);
+	case SND_SOC_DAPM_PRE_PMD:
+		snd_soc_update_bits(codec, RT286_POWER_CTRL2, 0x38, 0x30);
 		break;
 	default:
 		return 0;
@@ -618,20 +675,16 @@
 }
 
 static const struct snd_soc_dapm_widget rt286_dapm_widgets[] = {
-	SND_SOC_DAPM_SUPPLY_S("HV", 1, RT286_POWER_CTRL1,
-		12, 1, NULL, 0),
 	SND_SOC_DAPM_SUPPLY("VREF", RT286_POWER_CTRL1,
-		0, 1, rt286_vref_event, SND_SOC_DAPM_PRE_PMU),
+		12, 1, rt286_vref_event, SND_SOC_DAPM_PRE_PMD |
+		SND_SOC_DAPM_POST_PMU | SND_SOC_DAPM_PRE_PMU),
 	SND_SOC_DAPM_SUPPLY_S("LDO1", 1, RT286_POWER_CTRL2,
 		2, 0, NULL, 0),
-	SND_SOC_DAPM_SUPPLY_S("LDO2", 2, RT286_POWER_CTRL1,
+	SND_SOC_DAPM_SUPPLY_S("LDO2", 1, RT286_POWER_CTRL1,
 		13, 1, rt286_ldo2_event, SND_SOC_DAPM_PRE_PMD |
 		SND_SOC_DAPM_POST_PMU),
 	SND_SOC_DAPM_SUPPLY("MCLK MODE", RT286_PLL_CTRL1,
 		5, 0, NULL, 0),
-	SND_SOC_DAPM_SUPPLY("MIC1 Input Buffer", SND_SOC_NOPM,
-		0, 0, rt286_mic1_event, SND_SOC_DAPM_PRE_PMU |
-		SND_SOC_DAPM_POST_PMD),
 
 	/* Input Lines */
 	SND_SOC_DAPM_INPUT("DMIC1 Pin"),
@@ -658,10 +711,12 @@
 	SND_SOC_DAPM_ADC("ADC 1", NULL, SND_SOC_NOPM, 0, 0),
 
 	/* ADC Mux */
-	SND_SOC_DAPM_MUX("ADC 0 Mux", RT286_SET_POWER(RT286_ADC_IN1), 0, 1,
-		&rt286_adc0_mux),
-	SND_SOC_DAPM_MUX("ADC 1 Mux", RT286_SET_POWER(RT286_ADC_IN2), 0, 1,
-		&rt286_adc1_mux),
+	SND_SOC_DAPM_MUX_E("ADC 0 Mux", RT286_SET_POWER(RT286_ADC_IN1), 0, 1,
+		&rt286_adc0_mux, rt286_adc_event, SND_SOC_DAPM_PRE_PMD |
+		SND_SOC_DAPM_POST_PMU),
+	SND_SOC_DAPM_MUX_E("ADC 1 Mux", RT286_SET_POWER(RT286_ADC_IN2), 0, 1,
+		&rt286_adc1_mux, rt286_adc_event, SND_SOC_DAPM_PRE_PMD |
+		SND_SOC_DAPM_POST_PMU),
 
 	/* Audio Interface */
 	SND_SOC_DAPM_AIF_IN("AIF1RX", "AIF1 Playback", 0, SND_SOC_NOPM, 0, 0),
@@ -709,18 +764,15 @@
 	{"Front", NULL, "MCLK MODE", is_mclk_mode},
 	{"Surround", NULL, "MCLK MODE", is_mclk_mode},
 
+	{"MIC1", NULL, "LDO1"},
+	{"SPO", NULL, "LDO1"},
 	{"HP Power", NULL, "LDO1"},
-	{"HP Power", NULL, "LDO2"},
 
-	{"MIC1", NULL, "LDO1"},
 	{"MIC1", NULL, "LDO2"},
-	{"MIC1", NULL, "HV"},
-	{"MIC1", NULL, "VREF"},
-	{"MIC1", NULL, "MIC1 Input Buffer"},
-
-	{"SPO", NULL, "LDO1"},
 	{"SPO", NULL, "LDO2"},
-	{"SPO", NULL, "HV"},
+	{"HP Power", NULL, "LDO2"},
+
+	{"MIC1", NULL, "VREF"},
 	{"SPO", NULL, "VREF"},
 
 	{"DMIC1", NULL, "DMIC1 Pin"},
@@ -850,8 +902,10 @@
 		RT286_I2S_CTRL1, 0x0018, d_len_code << 3);
 	dev_dbg(codec->dev, "format val = 0x%x\n", val);
 
-	snd_soc_update_bits(codec, RT286_DAC_FORMAT, 0x407f, val);
-	snd_soc_update_bits(codec, RT286_ADC_FORMAT, 0x407f, val);
+	if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK)
+		snd_soc_update_bits(codec, RT286_DAC_FORMAT, 0x407f, val);
+	else
+		snd_soc_update_bits(codec, RT286_ADC_FORMAT, 0x407f, val);
 
 	return 0;
 }
@@ -911,15 +965,11 @@
 	if (RT286_SCLK_S_MCLK == clk_id) {
 		snd_soc_update_bits(codec,
 			RT286_I2S_CTRL2, 0x0100, 0x0);
-		snd_soc_update_bits(codec,
-			RT286_PLL_CTRL1, 0x20, 0x20);
 	} else {
 		snd_soc_update_bits(codec,
 			RT286_I2S_CTRL2, 0x0100, 0x0100);
 		snd_soc_update_bits(codec,
 			RT286_PLL_CTRL, 0x4, 0x4);
-		snd_soc_update_bits(codec,
-			RT286_PLL_CTRL1, 0x20, 0x0);
 	}
 
 	switch (freq) {
@@ -996,7 +1046,7 @@
 	case SND_SOC_BIAS_ON:
 		mdelay(10);
 		snd_soc_update_bits(codec,
-			RT286_CBJ_CTRL1, 0x0400, 0x0400);
+			RT286_CBJ_CTRL1, 0x8400, 0x0400);
 		snd_soc_update_bits(codec,
 			RT286_DC_GAIN, 0x200, 0x0);
 
@@ -1005,8 +1055,6 @@
 	case SND_SOC_BIAS_STANDBY:
 		snd_soc_write(codec,
 			RT286_SET_AUDIO_POWER, AC_PWRST_D3);
-		snd_soc_update_bits(codec,
-			RT286_CBJ_CTRL1, 0x0400, 0x0000);
 		break;
 
 	default:
@@ -1035,8 +1083,8 @@
 	if (mic == true)
 		status |= SND_JACK_MICROPHONE;
 
-	snd_soc_jack_report(rt286->jack, status,
-		SND_JACK_MICROPHONE | SND_JACK_HEADPHONE);
+	snd_soc_jack_report(rt286->hp_jack, status, SND_JACK_HEADPHONE);
+	snd_soc_jack_report(rt286->mic_jack, status, SND_JACK_MICROPHONE);
 
 	pm_wakeup_event(&rt286->i2c->dev, 300);
 
@@ -1048,6 +1096,10 @@
 	struct rt286_priv *rt286 = snd_soc_codec_get_drvdata(codec);
 
 	rt286->codec = codec;
+	codec->dapm.bias_level = SND_SOC_BIAS_OFF;
+
+	if (rt286->pdata.suspend_power_off)
+		codec->dapm.idle_bias_off = false;
 
 	if (rt286->i2c->irq) {
 		regmap_update_bits(rt286->regmap,
@@ -1182,44 +1234,31 @@
 
 static const struct i2c_device_id rt286_i2c_id[] = {
 	{"rt286", 0},
-	{"rt288", 0},
 	{}
 };
 MODULE_DEVICE_TABLE(i2c, rt286_i2c_id);
 
+/* the default platform data for acpi devices */
+static struct rt286_platform_data rt286_acpi_data = {
+	.cbj_en = true,
+	.gpio2_en = false,
+	.suspend_power_off = true,
+};
+
 static const struct acpi_device_id rt286_acpi_match[] = {
-	{ "INT343A", 0 },
+	{ "INT343A", (unsigned long)&rt286_acpi_data },
 	{},
 };
 MODULE_DEVICE_TABLE(acpi, rt286_acpi_match);
 
-static struct dmi_system_id force_combo_jack_table[] = {
-	{
-		.ident = "Intel Wilson Beach",
-		.matches = {
-			DMI_MATCH(DMI_BOARD_NAME, "Wilson Beach SDS")
-		}
-	},
-	{ }
-};
-
-static struct dmi_system_id dmi_dell_dino[] = {
-	{
-		.ident = "Dell Dino",
-		.matches = {
-			DMI_MATCH(DMI_SYS_VENDOR, "Dell Inc."),
-			DMI_MATCH(DMI_PRODUCT_NAME, "XPS 13 9343")
-		}
-	},
-	{ }
-};
-
 static int rt286_i2c_probe(struct i2c_client *i2c,
 			   const struct i2c_device_id *id)
 {
 	struct rt286_platform_data *pdata = dev_get_platdata(&i2c->dev);
 	struct rt286_priv *rt286;
-	int i, ret, val;
+	struct device *dev = &i2c->dev;
+	const struct acpi_device_id *acpiid;
+	int i, ret;
 
 	rt286 = devm_kzalloc(&i2c->dev,	sizeof(*rt286),
 				GFP_KERNEL);
@@ -1234,15 +1273,11 @@
 		return ret;
 	}
 
-	ret = regmap_read(rt286->regmap,
-		RT286_GET_PARAM(AC_NODE_ROOT, AC_PAR_VENDOR_ID), &val);
-	if (ret != 0) {
-		dev_err(&i2c->dev, "I2C error %d\n", ret);
-		return ret;
-	}
-	if (val != RT286_VENDOR_ID && val != RT288_VENDOR_ID) {
+	regmap_read(rt286->regmap,
+		RT286_GET_PARAM(AC_NODE_ROOT, AC_PAR_VENDOR_ID), &ret);
+	if (ret != RT286_VENDOR_ID) {
 		dev_err(&i2c->dev,
-			"Device with ID register %x is not rt286\n", val);
+			"Device with ID register %x is not rt286\n", ret);
 		return -ENODEV;
 	}
 
@@ -1250,20 +1285,15 @@
 	rt286->i2c = i2c;
 	i2c_set_clientdata(i2c, rt286);
 
-	/* restore codec default */
-	for (i = 0; i < INDEX_CACHE_SIZE; i++)
-		regmap_write(rt286->regmap, rt286->index_cache[i].reg,
-				rt286->index_cache[i].def);
-	for (i = 0; i < ARRAY_SIZE(rt286_reg); i++)
-		regmap_write(rt286->regmap, rt286_reg[i].reg,
-				rt286_reg[i].def);
-
 	if (pdata)
 		rt286->pdata = *pdata;
 
-	if (dmi_check_system(force_combo_jack_table) ||
-		dmi_check_system(dmi_dell_dino))
-		rt286->pdata.cbj_en = true;
+	/* enable jack combo mode on supported devices */
+	acpiid = acpi_match_device(dev->driver->acpi_match_table, dev);
+	if (acpiid) {
+		rt286->pdata = *(struct rt286_platform_data *)
+				acpiid->driver_data;
+	}
 
 	regmap_write(rt286->regmap, RT286_SET_AUDIO_POWER, AC_PWRST_D3);
 
@@ -1275,6 +1305,7 @@
 	if (!rt286->pdata.cbj_en) {
 		regmap_write(rt286->regmap, RT286_CBJ_CTRL2, 0x0000);
 		regmap_write(rt286->regmap, RT286_MIC1_DET_CTRL, 0x0816);
+		regmap_write(rt286->regmap, RT286_MISC_CTRL1, 0x0000);
 		regmap_update_bits(rt286->regmap,
 					RT286_CBJ_CTRL1, 0xf000, 0xb000);
 	} else {
@@ -1291,27 +1322,14 @@
 
 	mdelay(10);
 
-	regmap_write(rt286->regmap, RT286_MISC_CTRL1, 0x0000);
-	/* Power down LDO, VREF */
-	regmap_update_bits(rt286->regmap, RT286_POWER_CTRL2, 0xc, 0x0);
-	regmap_update_bits(rt286->regmap, RT286_POWER_CTRL1, 0x1001, 0x1001);
+	/*Power down LDO2*/
+	regmap_update_bits(rt286->regmap, RT286_POWER_CTRL2, 0x8, 0x0);
 
-	/* Set depop parameter */
+	/*Set depop parameter*/
 	regmap_update_bits(rt286->regmap, RT286_DEPOP_CTRL2, 0x403a, 0x401a);
 	regmap_update_bits(rt286->regmap, RT286_DEPOP_CTRL3, 0xf777, 0x4737);
 	regmap_update_bits(rt286->regmap, RT286_DEPOP_CTRL4, 0x00ff, 0x003f);
 
-	if (dmi_check_system(dmi_dell_dino)) {
-		regmap_update_bits(rt286->regmap,
-			RT286_SET_GPIO_MASK, 0x40, 0x40);
-		regmap_update_bits(rt286->regmap,
-			RT286_SET_GPIO_DIRECTION, 0x40, 0x40);
-		regmap_update_bits(rt286->regmap,
-			RT286_SET_GPIO_DATA, 0x40, 0x40);
-		regmap_update_bits(rt286->regmap,
-			RT286_GPIO_CTRL, 0xc, 0x8);
-	}
-
 	if (rt286->i2c->irq) {
 		ret = request_threaded_irq(rt286->i2c->irq, NULL, rt286_irq,
 			IRQF_TRIGGER_HIGH | IRQF_ONESHOT, "rt286", rt286);
diff -Nru a/sound/soc/codecs/rt286.h b/sound/soc/codecs/rt286.h
--- a/sound/soc/codecs/rt286.h	2015-08-16 23:52:51.000000000 -0400
+++ b/sound/soc/codecs/rt286.h	2015-08-22 16:54:09.943983000 -0400
@@ -117,12 +117,6 @@
 	VERB_CMD(AC_VERB_SET_COEF_INDEX, RT286_VENDOR_REGISTERS, 0)
 #define RT286_PROC_COEF\
 	VERB_CMD(AC_VERB_SET_PROC_COEF, RT286_VENDOR_REGISTERS, 0)
-#define RT286_SET_GPIO_MASK\
-	VERB_CMD(AC_VERB_SET_GPIO_MASK, RT286_AUDIO_FUNCTION_GROUP, 0)
-#define RT286_SET_GPIO_DIRECTION\
-	VERB_CMD(AC_VERB_SET_GPIO_DIRECTION, RT286_AUDIO_FUNCTION_GROUP, 0)
-#define RT286_SET_GPIO_DATA\
-	VERB_CMD(AC_VERB_SET_GPIO_DATA, RT286_AUDIO_FUNCTION_GROUP, 0)
 
 /* Index registers */
 #define RT286_A_BIAS_CTRL1	0x01
@@ -137,7 +131,6 @@
 #define RT286_POWER_CTRL3	0x0f
 #define RT286_MIC1_DET_CTRL	0x19
 #define RT286_MISC_CTRL1	0x20
-#define RT286_GPIO_CTRL		0x29
 #define RT286_IRQ_CTRL		0x33
 #define RT286_PLL_CTRL1		0x49
 #define RT286_CBJ_CTRL1		0x4f
@@ -199,7 +192,15 @@
 	RT286_AIFS,
 };
 
-int rt286_mic_detect(struct snd_soc_codec *codec, struct snd_soc_jack *jack);
+enum rt286_jack_type {
+	RT286_TYPE_COMBO,
+	RT286_TYPE_NONCOMBO,
+};
+
+int rt286_mic_detect(struct snd_soc_codec *codec, struct snd_soc_jack *hp_jack,
+			struct snd_soc_jack *mic_jack);
+void rt286_set_jack_type(struct snd_soc_codec *codec,
+				enum rt286_jack_type type);
 
 #endif /* __RT286_H__ */
 
diff -Nru a/sound/soc/codecs/rt5677-spi.c b/sound/soc/codecs/rt5677-spi.c
--- a/sound/soc/codecs/rt5677-spi.c	2015-08-16 23:52:51.000000000 -0400
+++ b/sound/soc/codecs/rt5677-spi.c	2015-08-22 16:54:09.944983000 -0400
@@ -28,57 +28,521 @@
 #include <linux/sysfs.h>
 #include <linux/clk.h>
 #include <linux/firmware.h>
+#include <linux/acpi.h>
 
+#include <sound/soc.h>
+
+#include "rt5677.h"
 #include "rt5677-spi.h"
 
+#define SPI_BURST_LEN		240
+#define SPI_HEADER		5
+#define SPI_FREQ		6000000
+
+#define RT5677_SPI_WRITE_BURST	0x5
+#define RT5677_SPI_READ_BURST	0x4
+#define RT5677_SPI_WRITE_32	0x3
+#define RT5677_SPI_READ_32	0x2
+#define RT5677_SPI_WRITE_16	0x1
+#define RT5677_SPI_READ_16	0x0
+
+#define RT5677_MIC_BUF_ADDR		0x60030000
+#define RT5677_MODEL_ADDR		0x5FFC9800
+#define RT5677_MIC_BUF_BYTES		((u32)(0x20000 - sizeof(u32)))
+#define RT5677_MIC_BUF_FIRST_READ_SIZE	0x10000
+
 static struct spi_device *g_spi;
+static DEFINE_MUTEX(spi_mutex);
+
+struct rt5677_dsp {
+	struct device *dev;
+	struct delayed_work copy_work;
+	struct mutex dma_lock;
+	struct snd_pcm_substream *substream;
+	size_t dma_offset;	/* zero-based offset into runtime->dma_area */
+	size_t avail_bytes;	/* number of new bytes since last period */
+	u32 mic_read_offset;	/* zero-based offset into DSP's mic buffer */
+	bool new_hotword;	/* a new hotword is fired */
+};
+
+static const struct snd_pcm_hardware rt5677_spi_pcm_hardware = {
+	.info			= SNDRV_PCM_INFO_MMAP |
+				  SNDRV_PCM_INFO_MMAP_VALID |
+				  SNDRV_PCM_INFO_INTERLEAVED,
+	.formats		= SNDRV_PCM_FMTBIT_S16_LE,
+	.period_bytes_min	= PAGE_SIZE,
+	.period_bytes_max	= 0x20000 / 8,
+	.periods_min		= 8,
+	.periods_max		= 8,
+	.channels_min		= 1,
+	.channels_max		= 1,
+	.buffer_bytes_max	= 0x20000,
+};
+
+static int rt5677_spi_dai_hw_params(struct snd_pcm_substream *substream,
+	struct snd_pcm_hw_params *params, struct snd_soc_dai *dai)
+{
+	return 0;
+}
+
+static struct snd_soc_dai_ops rt5677_spi_dai_ops = {
+	.hw_params = rt5677_spi_dai_hw_params,
+};
+
+static struct snd_soc_dai_driver rt5677_spi_dai = {
+	/* The DAI name "rt5677-dsp-cpu-dai" is not used. The actual DAI name
+	 * registered with ASoC is the name of the device "spi-RT5677AA:00",
+	 * because we only have one DAI. See snd_soc_register_dais().
+	 */
+	.name = "rt5677-dsp-cpu-dai",
+	.id = 0,
+	.capture = {
+		.stream_name = "DSP Capture",
+		.channels_min = 1,
+		.channels_max = 1,
+		.rates = SNDRV_PCM_RATE_16000,
+		.formats = SNDRV_PCM_FMTBIT_S16_LE,
+	},
+	.ops = &rt5677_spi_dai_ops,
+};
+
+/* PCM for streaming audio from the DSP buffer */
+static int rt5677_spi_pcm_open(struct snd_pcm_substream *substream)
+{
+	struct snd_soc_pcm_runtime *rtd = substream->private_data;
+	struct rt5677_priv *rt5677 = snd_soc_codec_get_drvdata(rtd->codec);
+
+	rt5677->set_dsp_vad(rtd->codec, true);
+	snd_soc_set_runtime_hwparams(substream, &rt5677_spi_pcm_hardware);
+	return 0;
+}
+
+static int rt5677_spi_pcm_close(struct snd_pcm_substream *substream)
+{
+	struct snd_soc_pcm_runtime *rtd = substream->private_data;
+	struct rt5677_priv *rt5677 = snd_soc_codec_get_drvdata(rtd->codec);
+	struct rt5677_dsp *rt5677_dsp =
+			snd_soc_platform_get_drvdata(rtd->platform);
+
+	cancel_delayed_work_sync(&rt5677_dsp->copy_work);
+	rt5677->set_dsp_vad(rtd->codec, false);
+	return 0;
+}
+
+static int rt5677_spi_hw_params(struct snd_pcm_substream *substream,
+			       struct snd_pcm_hw_params *hw_params)
+{
+	struct snd_soc_pcm_runtime *rtd = substream->private_data;
+	struct rt5677_dsp *rt5677_dsp =
+			snd_soc_platform_get_drvdata(rtd->platform);
+	int ret;
+
+	mutex_lock(&rt5677_dsp->dma_lock);
+	ret = snd_pcm_lib_alloc_vmalloc_buffer(substream,
+			params_buffer_bytes(hw_params));
+	rt5677_dsp->substream = substream;
+	mutex_unlock(&rt5677_dsp->dma_lock);
+
+	return ret;
+}
+
+static int rt5677_spi_hw_free(struct snd_pcm_substream *substream)
+{
+	struct snd_soc_pcm_runtime *rtd = substream->private_data;
+	struct rt5677_dsp *rt5677_dsp =
+			snd_soc_platform_get_drvdata(rtd->platform);
+
+	mutex_lock(&rt5677_dsp->dma_lock);
+	rt5677_dsp->substream = 0;
+	mutex_unlock(&rt5677_dsp->dma_lock);
 
-/**
- * rt5677_spi_write - Write data to SPI.
- * @txbuf: Data Buffer for writing.
- * @len: Data length.
+	return snd_pcm_lib_free_vmalloc_buffer(substream);
+}
+
+static int rt5677_spi_prepare(struct snd_pcm_substream *substream)
+{
+	struct snd_soc_pcm_runtime *rtd = substream->private_data;
+	struct rt5677_dsp *rt5677_dsp =
+			snd_soc_platform_get_drvdata(rtd->platform);
+
+	rt5677_dsp->dma_offset = 0;
+	rt5677_dsp->avail_bytes = 0;
+	return 0;
+}
+
+static snd_pcm_uframes_t rt5677_spi_pcm_pointer(
+		struct snd_pcm_substream *substream)
+{
+	struct snd_pcm_runtime *runtime = substream->runtime;
+	struct snd_soc_pcm_runtime *rtd = substream->private_data;
+	struct rt5677_dsp *rt5677_dsp =
+		snd_soc_platform_get_drvdata(rtd->platform);
+
+	return bytes_to_frames(runtime, rt5677_dsp->dma_offset);
+}
+
+static int rt5677_spi_mic_write_offset(u32 *mic_write_offset)
+{
+	int ret;
+	/* Grab the first 4 bytes that hold the write pointer on the
+	 * dsp, and check to make sure that it points somewhere inside the
+	 * buffer.
+	 */
+	ret = rt5677_spi_read(RT5677_MIC_BUF_ADDR, mic_write_offset,
+			sizeof(u32));
+	if (ret)
+		return ret;
+	/* Adjust the offset so that it's zero-based */
+	*mic_write_offset = *mic_write_offset - sizeof(u32);
+	return *mic_write_offset < RT5677_MIC_BUF_BYTES ? 0 : -EFAULT;
+}
+
+/*
+ * Copy one contiguous block of audio samples from the DSP mic buffer to the
+ * dma_area of the pcm runtime. The receiving buffer may wrap around.
+ * @begin: start offset of the block to copy, in bytes.
+ * @end:   offset of the first byte after the block to copy, must be greater
+ *         than or equal to begin.
  *
+ * Return: Zero if successful, or a negative error code on failure.
+ */
+static int rt5677_spi_copy_block(struct rt5677_dsp *rt5677_dsp,
+		u32 begin, u32 end)
+{
+	struct snd_pcm_runtime *runtime = rt5677_dsp->substream->runtime;
+	size_t bytes_per_frame = frames_to_bytes(runtime, 1);
+	size_t first_chunk_len, second_chunk_len;
+	int ret;
+
+	if (begin > end || runtime->dma_bytes < 2 * bytes_per_frame) {
+		dev_err(rt5677_dsp->dev,
+			"Invalid copy from (%u, %u), dma_area size %zu\n",
+			begin, end, runtime->dma_bytes);
+		return -EINVAL;
+	}
+
+	/* The block to copy is empty */
+	if (begin == end)
+		return 0;
+
+	/* If the incoming chunk is too big for the receiving buffer, only the
+	 * last "receiving buffer size - one frame" bytes are copied.
+	 */
+	if (end - begin > runtime->dma_bytes - bytes_per_frame)
+		begin = end - (runtime->dma_bytes - bytes_per_frame);
+
+	/* May need to split to two chunks, calculate the size of each */
+	first_chunk_len = end - begin;
+	second_chunk_len = 0;
+	if (rt5677_dsp->dma_offset + first_chunk_len > runtime->dma_bytes) {
+		/* Receiving buffer wrapped around */
+		second_chunk_len = first_chunk_len;
+		first_chunk_len = runtime->dma_bytes - rt5677_dsp->dma_offset;
+		second_chunk_len -= first_chunk_len;
+	}
+
+	/* Copy first chunk */
+	ret = rt5677_spi_read(RT5677_MIC_BUF_ADDR + sizeof(u32) + begin,
+			runtime->dma_area + rt5677_dsp->dma_offset,
+			first_chunk_len);
+	if (ret)
+		return ret;
+	rt5677_dsp->dma_offset += first_chunk_len;
+	if (rt5677_dsp->dma_offset == runtime->dma_bytes)
+		rt5677_dsp->dma_offset = 0;
+
+	/* Copy second chunk */
+	if (second_chunk_len) {
+		ret = rt5677_spi_read(RT5677_MIC_BUF_ADDR + sizeof(u32) +
+				begin + first_chunk_len, runtime->dma_area,
+				second_chunk_len);
+		if (!ret)
+			rt5677_dsp->dma_offset = second_chunk_len;
+	}
+	return ret;
+}
+
+/*
+ * Copy a given amount of audio samples from the DSP mic buffer starting at
+ * mic_read_offset, to the dma_area of the pcm runtime. The source buffer may
+ * wrap around. mic_read_offset is updated after successful copy.
+ * @amount: amount of samples to copy, in bytes.
  *
- * Returns true for success.
+ * Return: Zero if successful, or a negative error code on failure.
  */
-int rt5677_spi_write(u8 *txbuf, size_t len)
+static int rt5677_spi_copy(struct rt5677_dsp *rt5677_dsp, u32 amount)
 {
-	int status;
+	int ret = 0;
+	u32 target;
 
-	status = spi_write(g_spi, txbuf, len);
+	if (amount == 0)
+		return ret;
 
-	if (status)
-		dev_err(&g_spi->dev, "rt5677_spi_write error %d\n", status);
+	target = rt5677_dsp->mic_read_offset + amount;
+	/* Copy the first chunk in DSP's mic buffer */
+	ret |= rt5677_spi_copy_block(rt5677_dsp, rt5677_dsp->mic_read_offset,
+			min(target, RT5677_MIC_BUF_BYTES));
+
+	if (target >= RT5677_MIC_BUF_BYTES) {
+		/* Wrap around, copy the second chunk */
+		target -= RT5677_MIC_BUF_BYTES;
+		ret |= rt5677_spi_copy_block(rt5677_dsp, 0, target);
+	}
 
-	return status;
+	if (!ret)
+		rt5677_dsp->mic_read_offset = target;
+	return ret;
 }
-EXPORT_SYMBOL_GPL(rt5677_spi_write);
 
-/**
- * rt5677_spi_burst_write - Write data to SPI by rt5677 dsp memory address.
- * @addr: Start address.
- * @txbuf: Data Buffer for writng.
- * @len: Data length, it must be a multiple of 8.
- *
- *
- * Returns true for success.
+/*
+ * A delayed work that streams audio samples from the DSP mic buffer to the
+ * dma_area of the pcm runtime via SPI.
  */
-int rt5677_spi_burst_write(u32 addr, const struct firmware *fw)
+static void rt5677_spi_copy_work(struct work_struct *work)
 {
-	u8 spi_cmd = RT5677_SPI_CMD_BURST_WRITE;
-	u8 *write_buf;
-	unsigned int i, end, offset = 0;
+	struct rt5677_dsp *rt5677_dsp =
+		container_of(work, struct rt5677_dsp, copy_work.work);
+	struct snd_pcm_runtime *runtime;
+	u32 mic_write_offset;
+	size_t new_bytes, copy_bytes, period_bytes;
+	int ret = 0;
+
+	/* Ensure runtime->dma_area buffer does not go away while copying. */
+	mutex_lock(&rt5677_dsp->dma_lock);
+	if (!rt5677_dsp->substream) {
+		dev_err(rt5677_dsp->dev, "No pcm substream\n");
+		goto done;
+	}
 
-	write_buf = kmalloc(RT5677_SPI_BUF_LEN + 6, GFP_KERNEL);
+	runtime = rt5677_dsp->substream->runtime;
 
-	if (write_buf == NULL)
-		return -ENOMEM;
+	if (rt5677_spi_mic_write_offset(&mic_write_offset)) {
+		dev_err(rt5677_dsp->dev, "No mic_write_offset\n");
+		goto done;
+	}
 
-	while (offset < fw->size) {
-		if (offset + RT5677_SPI_BUF_LEN <= fw->size)
-			end = RT5677_SPI_BUF_LEN;
+	/* If this is the first time that we've asked for streaming data after
+	 * a hotword is fired, we should start reading from the previous 2
+	 * seconds of audio from wherever the mic_write_offset is currently.
+	 */
+	if (rt5677_dsp->new_hotword) {
+		rt5677_dsp->new_hotword = false;
+		/* See if buffer wraparound happens */
+		if (mic_write_offset < RT5677_MIC_BUF_FIRST_READ_SIZE)
+			rt5677_dsp->mic_read_offset = RT5677_MIC_BUF_BYTES -
+					(RT5677_MIC_BUF_FIRST_READ_SIZE -
+					mic_write_offset);
 		else
-			end = fw->size % RT5677_SPI_BUF_LEN;
+			rt5677_dsp->mic_read_offset = mic_write_offset -
+					RT5677_MIC_BUF_FIRST_READ_SIZE;
+	}
+
+	/* Calculate the amount of new samples in bytes */
+	if (rt5677_dsp->mic_read_offset <= mic_write_offset)
+		new_bytes = mic_write_offset - rt5677_dsp->mic_read_offset;
+	else
+		new_bytes = RT5677_MIC_BUF_BYTES + mic_write_offset
+				- rt5677_dsp->mic_read_offset;
+
+	/* Copy all new samples from DSP mic buffer, one period at a time */
+	period_bytes = snd_pcm_lib_period_bytes(rt5677_dsp->substream);
+	while (new_bytes) {
+		copy_bytes = min(new_bytes, period_bytes
+				- rt5677_dsp->avail_bytes);
+		ret = rt5677_spi_copy(rt5677_dsp, copy_bytes);
+		if (ret) {
+			dev_err(rt5677_dsp->dev, "Copy failed %d\n", ret);
+			goto done;
+		}
+		rt5677_dsp->avail_bytes += copy_bytes;
+		if (rt5677_dsp->avail_bytes >= period_bytes) {
+			snd_pcm_period_elapsed(rt5677_dsp->substream);
+			rt5677_dsp->avail_bytes = 0;
+		}
+		new_bytes -= copy_bytes;
+	}
+
+	/* TODO benzh: use better delay time based on period_bytes */
+	schedule_delayed_work(&rt5677_dsp->copy_work, msecs_to_jiffies(5));
+done:
+	mutex_unlock(&rt5677_dsp->dma_lock);
+}
+
+struct page *rt5677_spi_pcm_page(struct snd_pcm_substream *substream,
+		unsigned long offset)
+{
+	return snd_pcm_lib_get_vmalloc_page(substream, offset);
+}
+
+static struct snd_pcm_ops rt5677_spi_pcm_ops = {
+	.open		= rt5677_spi_pcm_open,
+	.close		= rt5677_spi_pcm_close,
+	.hw_params	= rt5677_spi_hw_params,
+	.hw_free	= rt5677_spi_hw_free,
+	.prepare	= rt5677_spi_prepare,
+	.pointer	= rt5677_spi_pcm_pointer,
+	.mmap		= snd_pcm_lib_mmap_vmalloc,
+	.page		= rt5677_spi_pcm_page,
+};
+
+static int rt5677_spi_pcm_probe(struct snd_soc_platform *platform)
+{
+	struct rt5677_dsp *rt5677_dsp;
+
+	rt5677_dsp = devm_kzalloc(platform->dev, sizeof(*rt5677_dsp),
+			GFP_KERNEL);
+	rt5677_dsp->dev = &g_spi->dev;
+	mutex_init(&rt5677_dsp->dma_lock);
+	INIT_DELAYED_WORK(&rt5677_dsp->copy_work, rt5677_spi_copy_work);
+
+	snd_soc_platform_set_drvdata(platform, rt5677_dsp);
+	return 0;
+}
+
+static struct snd_soc_platform_driver rt5677_spi_platform = {
+	.probe = rt5677_spi_pcm_probe,
+	.ops = &rt5677_spi_pcm_ops,
+};
+
+static const struct snd_soc_component_driver rt5677_spi_dai_component = {
+	.name		= "rt5677-spi-dai",
+};
+
+/* Read DSP memory using SPI. Addr and len have to be multiples of 16-bits. */
+int rt5677_spi_read(u32 addr, void *rxbuf, size_t len)
+{
+	unsigned int i, end, offset = 0;
+	int status = 0;
+	struct spi_transfer t[2];
+	struct spi_message m;
+	u8 *rx_buf;
+	u8 buf[SPI_BURST_LEN + SPI_HEADER + 4];
+	u8 spi_cmd;
+	u8 *rx_data = rxbuf;
+
+	if (!g_spi)
+		return -ENODEV;
+
+	rx_buf = buf + SPI_HEADER + 4;
+	memset(t, 0, sizeof(t));
+	t[0].tx_buf = buf;
+	t[0].len = SPI_HEADER + 4;
+	t[0].speed_hz = SPI_FREQ;
+	t[1].rx_buf = rx_buf;
+	t[1].speed_hz = SPI_FREQ;
+	spi_message_init(&m);
+	spi_message_add_tail(&t[0], &m);
+	spi_message_add_tail(&t[1], &m);
+
+	while (offset < len) {
+		/* TODO benzh: Clean up the read length selection logic */
+		switch (min(len - offset, (size_t)(addr + offset) & 0x7)) {
+		case 4:
+			spi_cmd = RT5677_SPI_READ_32;
+			end = 4;
+			break;
+		case 2:
+		case 6:
+			spi_cmd = RT5677_SPI_READ_16;
+			end = 2;
+			break;
+		case 0:
+			if (offset + SPI_BURST_LEN <= len) {
+				spi_cmd = RT5677_SPI_READ_BURST;
+				end = SPI_BURST_LEN;
+				break;
+			} else if (offset + 4 <= len) {
+				spi_cmd = RT5677_SPI_READ_32;
+				end = 4;
+				break;
+			} else if (offset + 2 <= len) {
+				spi_cmd = RT5677_SPI_READ_16;
+				end = 2;
+				break;
+			}
+			/* Fall through to default error case */
+		default:
+			pr_err("Bad section alignment\n");
+			return -EACCES;
+		}
+
+		buf[0] = spi_cmd;
+		buf[1] = ((addr + offset) & 0xff000000) >> 24;
+		buf[2] = ((addr + offset) & 0x00ff0000) >> 16;
+		buf[3] = ((addr + offset) & 0x0000ff00) >> 8;
+		buf[4] = ((addr + offset) & 0x000000ff) >> 0;
+
+		t[1].len = end;
+
+		mutex_lock(&spi_mutex);
+		status |= spi_sync(g_spi, &m);
+		mutex_unlock(&spi_mutex);
+
+		if (spi_cmd == RT5677_SPI_READ_BURST) {
+			for (i = 0; i < end; i += 8) {
+				rx_data[offset + i + 0] = rx_buf[i + 7];
+				rx_data[offset + i + 1] = rx_buf[i + 6];
+				rx_data[offset + i + 2] = rx_buf[i + 5];
+				rx_data[offset + i + 3] = rx_buf[i + 4];
+				rx_data[offset + i + 4] = rx_buf[i + 3];
+				rx_data[offset + i + 5] = rx_buf[i + 2];
+				rx_data[offset + i + 6] = rx_buf[i + 1];
+				rx_data[offset + i + 7] = rx_buf[i + 0];
+			}
+		} else {
+			for (i = 0; i < end; i++)
+				rx_data[offset + i] = rx_buf[end - i - 1];
+		}
+
+		offset += end;
+	}
+
+	return status;
+}
+EXPORT_SYMBOL_GPL(rt5677_spi_read);
+
+int rt5677_spi_write(u32 addr, const u8 *txbuf, size_t len)
+{
+	unsigned int i, end, offset = 0;
+	int status = 0;
+	u8 write_buf[SPI_BURST_LEN + SPI_HEADER + 1];
+	u8 spi_cmd;
+	struct spi_transfer t;
+	struct spi_message m;
+
+	if (!g_spi)
+		return -ENODEV;
+
+	memset(&t, 0, sizeof(t));
+	t.tx_buf = write_buf;
+	t.speed_hz = SPI_FREQ;
+	spi_message_init(&m);
+	spi_message_add_tail(&t, &m);
+
+	while (offset < len) {
+		switch ((addr + offset) & 0x7) {
+		case 4:
+			spi_cmd = RT5677_SPI_WRITE_32;
+			end = 4;
+			break;
+		case 2:
+		case 6:
+			spi_cmd = RT5677_SPI_WRITE_16;
+			end = 2;
+			break;
+		case 0:
+			spi_cmd = RT5677_SPI_WRITE_BURST;
+			if (offset + SPI_BURST_LEN <= len)
+				end = SPI_BURST_LEN;
+			else {
+				end = len - offset;
+				end = (((end - 1) >> 3) + 1) << 3;
+			}
+			break;
+		default:
+			pr_err("Bad section alignment\n");
+			return -EACCES;
+		}
 
 		write_buf[0] = spi_cmd;
 		write_buf[1] = ((addr + offset) & 0xff000000) >> 24;
@@ -86,42 +550,117 @@
 		write_buf[3] = ((addr + offset) & 0x0000ff00) >> 8;
 		write_buf[4] = ((addr + offset) & 0x000000ff) >> 0;
 
-		for (i = 0; i < end; i += 8) {
-			write_buf[i + 12] = fw->data[offset + i + 0];
-			write_buf[i + 11] = fw->data[offset + i + 1];
-			write_buf[i + 10] = fw->data[offset + i + 2];
-			write_buf[i +  9] = fw->data[offset + i + 3];
-			write_buf[i +  8] = fw->data[offset + i + 4];
-			write_buf[i +  7] = fw->data[offset + i + 5];
-			write_buf[i +  6] = fw->data[offset + i + 6];
-			write_buf[i +  5] = fw->data[offset + i + 7];
+		if (spi_cmd == RT5677_SPI_WRITE_BURST) {
+			for (i = 0; i < end; i += 8) {
+				write_buf[i + 12] = txbuf[offset + i + 0];
+				write_buf[i + 11] = txbuf[offset + i + 1];
+				write_buf[i + 10] = txbuf[offset + i + 2];
+				write_buf[i +  9] = txbuf[offset + i + 3];
+				write_buf[i +  8] = txbuf[offset + i + 4];
+				write_buf[i +  7] = txbuf[offset + i + 5];
+				write_buf[i +  6] = txbuf[offset + i + 6];
+				write_buf[i +  5] = txbuf[offset + i + 7];
+			}
+		} else {
+			unsigned int j = end + (SPI_HEADER - 1);
+			for (i = 0; i < end; i++, j--) {
+				if (offset + i < len)
+					write_buf[j] = txbuf[offset + i];
+				else
+					write_buf[j] = 0;
+			}
 		}
+		write_buf[end + SPI_HEADER] = spi_cmd;
+		t.len = end + SPI_HEADER + 1;
+
+		mutex_lock(&spi_mutex);
+		status |= spi_sync(g_spi, &m);
+		mutex_unlock(&spi_mutex);
+
+		offset += end;
+	}
+
+	return status;
+}
+EXPORT_SYMBOL_GPL(rt5677_spi_write);
 
-		write_buf[end + 5] = spi_cmd;
+void rt5677_spi_hotword_detected(void)
+{
+	struct snd_soc_platform *platform;
+	struct rt5677_dsp *rt5677_dsp;
 
-		rt5677_spi_write(write_buf, end + 6);
+	if (!g_spi)
+		return;
+	platform = snd_soc_lookup_platform(&g_spi->dev);
+	if (!platform) {
+		dev_err(&g_spi->dev, "Can't get snd_soc_platform\n");
+		return;
+	}
 
-		offset += RT5677_SPI_BUF_LEN;
+	rt5677_dsp = snd_soc_platform_get_drvdata(platform);
+	if (!rt5677_dsp) {
+		dev_err(&g_spi->dev, "Can't get rt5677_dsp\n");
+		return;
 	}
 
-	kfree(write_buf);
+	mutex_lock(&rt5677_dsp->dma_lock);
+	dev_info(rt5677_dsp->dev, "Hotword detected\n");
+	rt5677_dsp->new_hotword = true;
+	mutex_unlock(&rt5677_dsp->dma_lock);
 
-	return 0;
+	schedule_delayed_work(&rt5677_dsp->copy_work, 0);
 }
-EXPORT_SYMBOL_GPL(rt5677_spi_burst_write);
+EXPORT_SYMBOL_GPL(rt5677_spi_hotword_detected);
 
 static int rt5677_spi_probe(struct spi_device *spi)
 {
+	int ret;
+
 	g_spi = spi;
+
+	ret = snd_soc_register_platform(&spi->dev, &rt5677_spi_platform);
+	if (ret < 0) {
+		dev_err(&spi->dev, "Failed to register platform.\n");
+		goto err_plat;
+	}
+
+	ret = snd_soc_register_component(&spi->dev, &rt5677_spi_dai_component,
+					 &rt5677_spi_dai, 1);
+	if (ret < 0) {
+		dev_err(&spi->dev, "Failed to register component.\n");
+		goto err_comp;
+	}
 	return 0;
+
+err_comp:
+	snd_soc_unregister_platform(&spi->dev);
+err_plat:
+	return ret;
 }
 
+static int rt5677_spi_remove(struct spi_device *spi)
+{
+	snd_soc_unregister_component(&spi->dev);
+	snd_soc_unregister_platform(&spi->dev);
+	return 0;
+}
+
+#ifdef CONFIG_ACPI
+static const struct acpi_device_id rt5677_spi_acpi_id[] = {
+	{ "RT5677AA", 0 },
+	{ }
+};
+MODULE_DEVICE_TABLE(acpi, rt5677_spi_acpi_id);
+#endif
+
 static struct spi_driver rt5677_spi_driver = {
 	.driver = {
-		.name = "rt5677",
+		.name = "rt5677spi",
 		.owner = THIS_MODULE,
+		.acpi_match_table = ACPI_PTR(rt5677_spi_acpi_id),
 	},
 	.probe = rt5677_spi_probe,
+	.remove = rt5677_spi_remove,
 };
 module_spi_driver(rt5677_spi_driver);
 
diff -Nru a/sound/soc/codecs/rt5677-spi.h b/sound/soc/codecs/rt5677-spi.h
--- a/sound/soc/codecs/rt5677-spi.h	2015-08-16 23:52:51.000000000 -0400
+++ b/sound/soc/codecs/rt5677-spi.h	2015-08-22 16:54:09.944983000 -0400
@@ -12,10 +12,8 @@
 #ifndef __RT5677_SPI_H__
 #define __RT5677_SPI_H__
 
-#define RT5677_SPI_BUF_LEN 240
-#define RT5677_SPI_CMD_BURST_WRITE 0x05
-
-int rt5677_spi_write(u8 *txbuf, size_t len);
-int rt5677_spi_burst_write(u32 addr, const struct firmware *fw);
+int rt5677_spi_write(u32 addr, const u8 *txbuf, size_t len);
+int rt5677_spi_read(u32 addr, void *rxbuf, size_t len);
+void rt5677_spi_hotword_detected(void);
 
 #endif /* __RT5677_SPI_H__ */
diff -Nru a/sound/soc/codecs/rt5677.c b/sound/soc/codecs/rt5677.c
--- a/sound/soc/codecs/rt5677.c	2015-08-16 23:52:51.000000000 -0400
+++ b/sound/soc/codecs/rt5677.c	2015-08-22 16:54:09.945983000 -0400
@@ -20,8 +20,13 @@
 #include <linux/i2c.h>
 #include <linux/platform_device.h>
 #include <linux/spi/spi.h>
+#include <linux/acpi.h>
 #include <linux/firmware.h>
 #include <linux/gpio.h>
+#include <linux/irq.h>
+#include <linux/interrupt.h>
+#include <linux/irqdomain.h>
+#include <linux/workqueue.h>
 #include <sound/core.h>
 #include <sound/pcm.h>
 #include <sound/pcm_params.h>
@@ -36,6 +41,10 @@
 
 #define RT5677_DEVICE_ID 0x6327
 
+/* Register controlling boot vector */
+#define RT5677_DSP_BOOT_VECTOR		0x1801f090
+#define RT5677_MODEL_ADDR		0x5FFC9800
+
 #define RT5677_PR_RANGE_BASE (0xff + 1)
 #define RT5677_PR_SPACING 0x100
 
@@ -62,9 +71,6 @@
 	{RT5677_PR_BASE + 0x1e,	0x0000},
 	{RT5677_PR_BASE + 0x12,	0x0eaa},
 	{RT5677_PR_BASE + 0x14,	0x018a},
-	{RT5677_PR_BASE + 0x15,	0x0490},
-	{RT5677_PR_BASE + 0x38,	0x0f71},
-	{RT5677_PR_BASE + 0x39,	0x0f71},
 };
 #define RT5677_INIT_REG_LEN ARRAY_SIZE(init_list)
 
@@ -296,6 +302,7 @@
 	case RT5677_I2C_MASTER_CTRL7:
 	case RT5677_I2C_MASTER_CTRL8:
 	case RT5677_HAP_GENE_CTRL2:
+	case RT5677_PWR_ANLG2: /* Modified by DSP firmware */
 	case RT5677_PWR_DSP_ST:
 	case RT5677_PRIV_DATA:
 	case RT5677_PLL1_CTRL2:
@@ -308,6 +315,8 @@
 	case RT5677_IRQ_CTRL1:
 	case RT5677_IRQ_CTRL2:
 	case RT5677_GPIO_ST:
+	case RT5677_GPIO_CTRL1: /* Modified by DSP firmware */
+	case RT5677_GPIO_CTRL2: /* Modified by DSP firmware */
 	case RT5677_DSP_INB1_SRC_CTRL4:
 	case RT5677_DSP_INB2_SRC_CTRL4:
 	case RT5677_DSP_INB3_SRC_CTRL4:
@@ -686,10 +695,8 @@
 	return ret;
 }
 
-static void rt5677_set_dsp_mode(struct snd_soc_codec *codec, bool on)
+static void rt5677_set_dsp_mode(struct rt5677_priv *rt5677, bool on)
 {
-	struct rt5677_priv *rt5677 = snd_soc_codec_get_drvdata(codec);
-
 	if (on) {
 		regmap_update_bits(rt5677->regmap, RT5677_PWR_DSP1, 0x2, 0x2);
 		rt5677->is_dsp_mode = true;
@@ -699,86 +706,260 @@
 	}
 }
 
+static unsigned int rt5677_set_vad_source(struct rt5677_priv *rt5677)
+{
+	/* The hotword audio path is from "DMIC L1" to "DSP Buffer".
+	 * "DSP Buffer" is then connected to "DSP Capture" which is the
+	 * rt5677-dsp-cpu-dai with a PCM interface in rt5677-spi.
+	 *
+	 * "DMIC L1" should be enabled in ucm config for hotwording.
+	 */
+
+	/* Mono ADC Capture Switch = unmute (default) */
+	regmap_update_bits(rt5677->regmap, RT5677_MONO_ADC_DIG_VOL,
+			RT5677_L_MUTE, 0);
+
+	/* Mono ADC Boost Volume = 24dB */
+	regmap_update_bits(rt5677->regmap, RT5677_ADC_BST_CTRL2,
+		RT5677_MONO_ADC_L_BST_MASK | RT5677_MONO_ADC_R_BST_MASK,
+		0xa000);
+
+	/* Mono ADC MIXL = Mono ADC2 L Mux (unmute)
+	 *                 Mono ADC1 L Mux (mute)
+	 * Mono ADC2 L Mux = Mono DMIC L Mux
+	 * Mono DMIC L Mux = DMIC1 (left)
+	 */
+	regmap_update_bits(rt5677->regmap, RT5677_MONO_ADC_MIXER,
+		RT5677_M_MONO_ADC_L2 | RT5677_M_MONO_ADC_L1 |
+		RT5677_SEL_MONO_ADC_L2_MASK | RT5677_SEL_MONO_DMIC_L_MASK,
+		RT5677_M_MONO_ADC_L1 | (1 << RT5677_SEL_MONO_ADC_L2_SFT) |
+		(0 << RT5677_SEL_MONO_DMIC_L_SFT));
+
+	/* DMIC1 power = enabled
+	 * DMIC CLK = 256 * fs / 12
+	 */
+	regmap_update_bits(rt5677->regmap, RT5677_DMIC_CTRL1,
+		RT5677_DMIC_1_EN_MASK | RT5677_DMIC_CLK_MASK,
+		RT5677_DMIC_1_EN | (5 << RT5677_DMIC_CLK_SFT));
+
+	/* I2S pre divide 2 = /6 (clk_sys2) */
+	regmap_update_bits(rt5677->regmap, RT5677_CLK_TREE_CTRL1,
+		RT5677_I2S_PD2_MASK, RT5677_I2S_PD2_6);
+
+	/* System Clock = MCLK1
+	 * Stereo ADC/DAC over sample rate = 128Fs (default)
+	 */
+	regmap_write(rt5677->regmap, RT5677_GLB_CLK1, 0x0000);
+
+	/* DSP Clock = MCLK1 (bypassed PLL2) */
+	regmap_write(rt5677->regmap, RT5677_GLB_CLK2, 0x0080);
+
+	/* Clock source for Mono L ADC = clk_sys2 */
+	regmap_update_bits(rt5677->regmap, RT5677_ASRC_6, 0xf000, 0x7000);
+
+	/* SAD Threshold1 */
+	regmap_write(rt5677->regmap, RT5677_VAD_CTRL2, 0x013f);
+	/* SAD Threshold2 */
+	regmap_write(rt5677->regmap, RT5677_VAD_CTRL3, 0x0ae5);
+	/* SAD Sample Rate Converter = Up 6 (8K to 48K)
+	 * SAD Output Sample Rate = Same as I2S
+	 * VAD ADC Mux = MONO ADC MIX L
+	 * SAD Threshold3
+	 */
+	regmap_write(rt5677->regmap, RT5677_VAD_CTRL4, 0x017f);
+	/* Minimum frame level within a pre-determined duration = 32 frames
+	 * Bypass ADPCM Encoder/Decoder = Bypass ADPCM
+	 * Automatic Push Data to SAD Buffer Once SAD Flag is triggered = enable
+	 * SAD Buffer Over-Writing = enable
+	 * SAD Buffer Pop Mode Control = disable
+	 * SAD Buffer Push Mode Control = enable
+	 * SAD Detector Control = enable
+	 * SAD Function Control = enable
+	 * SAD Function Reset = normal
+	 */
+	regmap_write(rt5677->regmap, RT5677_VAD_CTRL1, 0x273c);
+
+	/* InBound0/1 Source = VAD ADC/DAC1 FS */
+	regmap_update_bits(rt5677->regmap, RT5677_DSP_INB_CTRL1,
+		RT5677_IB01_SRC_MASK, 4 << RT5677_IB01_SRC_SFT);
+
+	/* VAD/SAD is not routed to the IRQ output (i.e. MX-BE[14] = 0), but it
+	 * is routed to DSP_IRQ_0, so DSP firmware may use it to sleep and save
+	 * power. See ALC5677 datasheet section 9.17 "GPIO, Interrupt and Jack
+	 * Detection" for more info.
+	 */
+
+	/* Enable Gating Mode with MCLK = enable */
+	regmap_update_bits(rt5677->regmap, RT5677_DIG_MISC, 0x1, 0x1);
+
+	/* Private register, no doc */
+	regmap_update_bits(rt5677->regmap, RT5677_PR_BASE + RT5677_BIAS_CUR4,
+		0x0f00, 0x0100);
+
+	/* adc mono left filter = power on */
+	regmap_update_bits(rt5677->regmap, RT5677_PWR_DIG2,
+		RT5677_PWR_ADC_MF_L, RT5677_PWR_ADC_MF_L);
+
+	/* LDO2 output = 1.2V
+	 * LDO1 output = 1.2V (LDO_IN = 1.8V)
+	 */
+	regmap_update_bits(rt5677->regmap, RT5677_PWR_ANLG1,
+		RT5677_LDO1_SEL_MASK | RT5677_LDO2_SEL_MASK,
+		0x0055);
+
+	/* Codec core power =  power on
+	 * LDO1 power = power on
+	 */
+	regmap_update_bits(rt5677->regmap, RT5677_PWR_ANLG2,
+		RT5677_PWR_CORE | RT5677_PWR_LDO1,
+		RT5677_PWR_CORE | RT5677_PWR_LDO1);
+
+	/* Isolation for DCVDD4 = normal (set during probe)
+	 * Isolation for DCVDD2 = normal (set during probe)
+	 * Isolation for DSP = normal
+	 * Isolation for Band 0~7 = disable
+	 * Isolation for InBound 4~10 and OutBound 4~10 = disable
+	 */
+	regmap_write(rt5677->regmap, RT5677_PWR_DSP2, 0x07ff);
+
+	/* System Band 0~7 = power on
+	 * InBound 4~10 and OutBound 4~10 = power on
+	 * DSP = power on
+	 * DSP CPU = stop (will be set to "run" after firmware loaded)
+	 */
+	regmap_write(rt5677->regmap, RT5677_PWR_DSP1, 0x07ff);
+
+	return 0;
+}
+
+static int rt5677_parse_and_load_dsp(struct rt5677_priv *rt5677, const u8 *buf,
+		unsigned int len)
+{
+	struct snd_soc_codec *codec = rt5677->codec;
+	Elf32_Ehdr *elf_hdr;
+	Elf32_Phdr *pr_hdr;
+	Elf32_Half i;
+	int ret = 0;
+
+	if (!buf || (len < sizeof(Elf32_Ehdr)))
+		return -ENOMEM;
+
+	elf_hdr = (Elf32_Ehdr *)buf;
+#ifndef EM_XTENSA
+#define EM_XTENSA	94
+#endif
+	if (strncmp(elf_hdr->e_ident, ELFMAG, sizeof(ELFMAG) - 1))
+		dev_err(codec->dev, "Wrong ELF header prefix\n");
+	if (elf_hdr->e_ehsize != sizeof(Elf32_Ehdr))
+		dev_err(codec->dev, "Wrong Elf header size\n");
+	if (elf_hdr->e_machine != EM_XTENSA)
+		dev_err(codec->dev, "Wrong DSP code file\n");
+
+	if (len < elf_hdr->e_phoff)
+		return -ENOMEM;
+	pr_hdr = (Elf32_Phdr *)(buf + elf_hdr->e_phoff);
+	for (i = 0; i < elf_hdr->e_phnum; i++) {
+		/* TODO: handle p_memsz != p_filesz */
+		if (pr_hdr->p_paddr && pr_hdr->p_filesz) {
+			dev_info(codec->dev, "Load 0x%x bytes to 0x%x\n",
+					pr_hdr->p_filesz, pr_hdr->p_paddr);
+
+			ret = rt5677_spi_write(pr_hdr->p_paddr,
+					buf + pr_hdr->p_offset,
+					pr_hdr->p_filesz);
+			if (ret)
+				dev_err(codec->dev, "Load firmware failed %d\n",
+						ret);
+		}
+		pr_hdr++;
+	}
+	return ret;
+}
+
+static int rt5677_load_dsp_from_file(struct rt5677_priv *rt5677)
+{
+	const struct firmware *fwp;
+	struct device *dev = rt5677->codec->dev;
+	int ret = 0;
+
+	/* Load dsp firmware from rt5677_elf_vad file */
+	ret = request_firmware(&fwp, "rt5677_elf_vad", dev);
+	if (ret) {
+		dev_err(dev, "Request rt5677_elf_vad failed %d\n", ret);
+		return ret;
+	}
+	dev_info(dev, "Requested rt5677_elf_vad (%zu)\n", fwp->size);
+
+	ret = rt5677_parse_and_load_dsp(rt5677, fwp->data, fwp->size);
+	release_firmware(fwp);
+	return ret;
+}
+
 static int rt5677_set_dsp_vad(struct snd_soc_codec *codec, bool on)
 {
 	struct rt5677_priv *rt5677 = snd_soc_codec_get_drvdata(codec);
-	static bool activity;
-	int ret;
+	rt5677->dsp_vad_en_request = on;
+	rt5677->dsp_vad_en = on;
+	schedule_delayed_work(&rt5677->dsp_work, 0);
+	return 0;
+}
 
-	if (!IS_ENABLED(CONFIG_SND_SOC_RT5677_SPI))
-		return -ENXIO;
+static void rt5677_dsp_work(struct work_struct *work)
+{
+	struct rt5677_priv *rt5677 =
+		container_of(work, struct rt5677_priv, dsp_work.work);
+	static bool activity;
+	bool enable = rt5677->dsp_vad_en;
 
-	if (on && !activity) {
+	dev_info(rt5677->codec->dev, "DSP VAD: enable=%d, activity=%d\n",
+			enable, activity);
+	if (enable && !activity) {
 		activity = true;
 
-		regcache_cache_only(rt5677->regmap, false);
-		regcache_cache_bypass(rt5677->regmap, true);
+		/* Before a hotword is detected, GPIO1 pin is configured as IRQ
+		 * output so that jack detect works. When a hotword is detected,
+		 * the DSP firmware configures the GPIO1 pin as GPIO1 and
+		 * drives a 1. rt5677_irq() is called after a rising edge on
+		 * the GPIO1 pin, due to either jack detect event or hotword
+		 * event, or both. All possible events are checked and handled
+		 * in rt5677_irq() where GPIO1 pin is configured back to IRQ
+		 * output if a hotword is detected.
+		 */
 
-		regmap_update_bits(rt5677->regmap, RT5677_DIG_MISC, 0x1, 0x1);
-		regmap_update_bits(rt5677->regmap,
-			RT5677_PR_BASE + RT5677_BIAS_CUR4, 0x0f00, 0x0f00);
-		regmap_update_bits(rt5677->regmap, RT5677_PWR_ANLG1,
-			RT5677_LDO1_SEL_MASK, 0x0);
-		regmap_update_bits(rt5677->regmap, RT5677_PWR_ANLG2,
-			RT5677_PWR_LDO1, RT5677_PWR_LDO1);
-		switch (rt5677->type) {
-		case RT5677:
-			regmap_update_bits(rt5677->regmap, RT5677_GLB_CLK1,
-				RT5677_MCLK_SRC_MASK, RT5677_MCLK2_SRC);
-			regmap_update_bits(rt5677->regmap, RT5677_GLB_CLK2,
-				RT5677_PLL2_PR_SRC_MASK |
-				RT5677_DSP_CLK_SRC_MASK,
-				RT5677_PLL2_PR_SRC_MCLK2 |
-				RT5677_DSP_CLK_SRC_BYPASS);
-			break;
-		case RT5676:
-			regmap_update_bits(rt5677->regmap, RT5677_GLB_CLK2,
-				RT5677_DSP_CLK_SRC_MASK,
-				RT5677_DSP_CLK_SRC_BYPASS);
-			break;
-		default:
-			break;
-		}
-		regmap_write(rt5677->regmap, RT5677_PWR_DSP2, 0x07ff);
-		regmap_write(rt5677->regmap, RT5677_PWR_DSP1, 0x07fd);
-		rt5677_set_dsp_mode(codec, true);
-
-		ret = request_firmware(&rt5677->fw1, RT5677_FIRMWARE1,
-			codec->dev);
-		if (ret == 0) {
-			rt5677_spi_burst_write(0x50000000, rt5677->fw1);
-			release_firmware(rt5677->fw1);
-		}
+		rt5677_set_vad_source(rt5677);
+		rt5677_set_dsp_mode(rt5677, true);
 
-		ret = request_firmware(&rt5677->fw2, RT5677_FIRMWARE2,
-			codec->dev);
-		if (ret == 0) {
-			rt5677_spi_burst_write(0x60000000, rt5677->fw2);
-			release_firmware(rt5677->fw2);
-		}
+		/* Boot the firmware from IRAM instead of SRAM0. */
+		rt5677_dsp_mode_i2c_write_addr(rt5677, RT5677_DSP_BOOT_VECTOR,
+			0x0009, 0x0003);
+		rt5677_dsp_mode_i2c_write_addr(rt5677, RT5677_DSP_BOOT_VECTOR,
+			0x0019, 0x0003);
+		rt5677_dsp_mode_i2c_write_addr(rt5677, RT5677_DSP_BOOT_VECTOR,
+			0x0009, 0x0003);
 
-		regmap_update_bits(rt5677->regmap, RT5677_PWR_DSP1, 0x1, 0x0);
+		rt5677_load_dsp_from_file(rt5677);
 
-		regcache_cache_bypass(rt5677->regmap, false);
-		regcache_cache_only(rt5677->regmap, true);
-	} else if (!on && activity) {
+		/* Set DSP CPU to Run */
+		regmap_update_bits(rt5677->regmap, RT5677_PWR_DSP1, 0x1, 0x0);
+	} else if (!enable && activity) {
 		activity = false;
 
-		regcache_cache_only(rt5677->regmap, false);
-		regcache_cache_bypass(rt5677->regmap, true);
-
+		/* Don't turn off the DSP while handling irqs */
+		mutex_lock(&rt5677->irq_lock);
+		/* Set DSP CPU to Stop */
 		regmap_update_bits(rt5677->regmap, RT5677_PWR_DSP1, 0x1, 0x1);
-		rt5677_set_dsp_mode(codec, false);
+
+		rt5677_set_dsp_mode(rt5677, false);
 		regmap_write(rt5677->regmap, RT5677_PWR_DSP1, 0x0001);
 
-		regmap_write(rt5677->regmap, RT5677_RESET, 0x10ec);
+		/* Disable and clear VAD interrupt */
+		regmap_write(rt5677->regmap, RT5677_VAD_CTRL1, 0x2184);
 
-		regcache_cache_bypass(rt5677->regmap, false);
-		regcache_mark_dirty(rt5677->regmap);
-		regcache_sync(rt5677->regmap);
+		/* Set GPIO1 pin back to be IRQ output for jack detect */
+		regmap_update_bits(rt5677->regmap, RT5677_GPIO_CTRL1,
+			RT5677_GPIO1_PIN_MASK, RT5677_GPIO1_PIN_IRQ);
+		mutex_unlock(&rt5677->irq_lock);
 	}
-
-	return 0;
 }
 
 static const DECLARE_TLV_DB_SCALE(out_vol_tlv, -4650, 150, 0);
@@ -803,10 +984,10 @@
 static int rt5677_dsp_vad_get(struct snd_kcontrol *kcontrol,
 		struct snd_ctl_elem_value *ucontrol)
 {
-	struct snd_soc_component *component = snd_kcontrol_chip(kcontrol);
-	struct rt5677_priv *rt5677 = snd_soc_component_get_drvdata(component);
+	struct snd_soc_codec *codec = snd_soc_kcontrol_codec(kcontrol);
+	struct rt5677_priv *rt5677 = snd_soc_codec_get_drvdata(codec);
 
-	ucontrol->value.integer.value[0] = rt5677->dsp_vad_en;
+	ucontrol->value.integer.value[0] = rt5677->dsp_vad_en_request;
 
 	return 0;
 }
@@ -814,15 +995,8 @@
 static int rt5677_dsp_vad_put(struct snd_kcontrol *kcontrol,
 		struct snd_ctl_elem_value *ucontrol)
 {
-	struct snd_soc_component *component = snd_kcontrol_chip(kcontrol);
-	struct rt5677_priv *rt5677 = snd_soc_component_get_drvdata(component);
-	struct snd_soc_codec *codec = snd_soc_component_to_codec(component);
-
-	rt5677->dsp_vad_en = !!ucontrol->value.integer.value[0];
-
-	if (codec->dapm.bias_level == SND_SOC_BIAS_OFF)
-		rt5677_set_dsp_vad(codec, rt5677->dsp_vad_en);
-
+	struct snd_soc_codec *codec = snd_soc_kcontrol_codec(kcontrol);
+	rt5677_set_dsp_vad(codec, !!ucontrol->value.integer.value[0]);
 	return 0;
 }
 
@@ -837,13 +1011,13 @@
 
 	/* DAC Digital Volume */
 	SOC_DOUBLE_TLV("DAC1 Playback Volume", RT5677_DAC1_DIG_VOL,
-		RT5677_L_VOL_SFT, RT5677_R_VOL_SFT, 87, 0, dac_vol_tlv),
+		RT5677_L_VOL_SFT, RT5677_R_VOL_SFT, 127, 0, dac_vol_tlv),
 	SOC_DOUBLE_TLV("DAC2 Playback Volume", RT5677_DAC2_DIG_VOL,
-		RT5677_L_VOL_SFT, RT5677_R_VOL_SFT, 87, 0, dac_vol_tlv),
+		RT5677_L_VOL_SFT, RT5677_R_VOL_SFT, 127, 0, dac_vol_tlv),
 	SOC_DOUBLE_TLV("DAC3 Playback Volume", RT5677_DAC3_DIG_VOL,
-		RT5677_L_VOL_SFT, RT5677_R_VOL_SFT, 87, 0, dac_vol_tlv),
+		RT5677_L_VOL_SFT, RT5677_R_VOL_SFT, 127, 0, dac_vol_tlv),
 	SOC_DOUBLE_TLV("DAC4 Playback Volume", RT5677_DAC4_DIG_VOL,
-		RT5677_L_VOL_SFT, RT5677_R_VOL_SFT, 87, 0, dac_vol_tlv),
+		RT5677_L_VOL_SFT, RT5677_R_VOL_SFT, 127, 0, dac_vol_tlv),
 
 	/* IN1/IN2 Control */
 	SOC_SINGLE_TLV("IN1 Boost", RT5677_IN1, RT5677_BST_SFT1, 8, 0, bst_tlv),
@@ -898,6 +1072,7 @@
 		RT5677_MONO_ADC_L_BST_SFT, RT5677_MONO_ADC_R_BST_SFT, 3, 0,
 		adc_bst_tlv),
 
+	/* TDM Control */
 	SOC_SINGLE_EXT("DSP VAD Switch", SND_SOC_NOPM, 0, 1, 0,
 		rt5677_dsp_vad_get, rt5677_dsp_vad_put),
 };
@@ -915,9 +1090,9 @@
 static int set_dmic_clk(struct snd_soc_dapm_widget *w,
 	struct snd_kcontrol *kcontrol, int event)
 {
-	struct snd_soc_codec *codec = snd_soc_dapm_to_codec(w->dapm);
+	struct snd_soc_codec *codec = w->codec;
 	struct rt5677_priv *rt5677 = snd_soc_codec_get_drvdata(codec);
-	int idx = rl6231_calc_dmic_clk(rt5677->lrck[RT5677_AIF1] << 8);
+	int idx = rl6231_calc_dmic_clk(rt5677->sysclk);
 
 	if (idx < 0)
 		dev_err(codec->dev, "Failed to set DMIC clock\n");
@@ -930,8 +1105,7 @@
 static int is_sys_clk_from_pll(struct snd_soc_dapm_widget *source,
 			 struct snd_soc_dapm_widget *sink)
 {
-	struct snd_soc_codec *codec = snd_soc_dapm_to_codec(source->dapm);
-	struct rt5677_priv *rt5677 = snd_soc_codec_get_drvdata(codec);
+	struct rt5677_priv *rt5677 = snd_soc_codec_get_drvdata(source->codec);
 	unsigned int val;
 
 	regmap_read(rt5677->regmap, RT5677_GLB_CLK1, &val);
@@ -945,8 +1119,6 @@
 static int is_using_asrc(struct snd_soc_dapm_widget *source,
 			 struct snd_soc_dapm_widget *sink)
 {
-	struct snd_soc_codec *codec = snd_soc_dapm_to_codec(source->dapm);
-	struct rt5677_priv *rt5677 = snd_soc_codec_get_drvdata(codec);
 	unsigned int reg, shift, val;
 
 	if (source->reg == RT5677_ASRC_1) {
@@ -1013,9 +1185,7 @@
 		}
 	}
 
-	regmap_read(rt5677->regmap, reg, &val);
-	val = (val >> shift) & 0xf;
-
+	val = (snd_soc_read(source->codec, reg) >> shift) & 0xf;
 	switch (val) {
 	case 1 ... 6:
 		return 1;
@@ -1060,6 +1230,7 @@
 	unsigned int asrc5_mask = 0, asrc5_value = 0;
 	unsigned int asrc6_mask = 0, asrc6_value = 0;
 	unsigned int asrc7_mask = 0, asrc7_value = 0;
+	unsigned int asrc8_mask = 0, asrc8_value = 0;
 
 	switch (clk_src) {
 	case RT5677_CLK_SEL_SYS:
@@ -1196,10 +1367,108 @@
 		regmap_update_bits(rt5677->regmap, RT5677_ASRC_7, asrc7_mask,
 			asrc7_value);
 
+	/* ASRC 8 */
+	if (filter_mask & RT5677_I2S1_SOURCE) {
+		asrc8_mask |= RT5677_I2S1_CLK_SEL_MASK;
+		asrc8_value = (asrc8_value & ~RT5677_I2S1_CLK_SEL_MASK)
+			| ((clk_src - 1) << RT5677_I2S1_CLK_SEL_SFT);
+	}
+
+	if (filter_mask & RT5677_I2S2_SOURCE) {
+		asrc8_mask |= RT5677_I2S2_CLK_SEL_MASK;
+		asrc8_value = (asrc8_value & ~RT5677_I2S2_CLK_SEL_MASK)
+			| ((clk_src - 1) << RT5677_I2S2_CLK_SEL_SFT);
+	}
+
+	if (filter_mask & RT5677_I2S3_SOURCE) {
+		asrc8_mask |= RT5677_I2S3_CLK_SEL_MASK;
+		asrc8_value = (asrc8_value & ~RT5677_I2S3_CLK_SEL_MASK)
+			| ((clk_src - 1) << RT5677_I2S3_CLK_SEL_SFT);
+	}
+
+	if (filter_mask & RT5677_I2S4_SOURCE) {
+		asrc8_mask |= RT5677_I2S4_CLK_SEL_MASK;
+		asrc8_value = (asrc8_value & ~RT5677_I2S4_CLK_SEL_MASK)
+			| ((clk_src - 1) << RT5677_I2S4_CLK_SEL_SFT);
+	}
+
+	if (asrc8_mask)
+		regmap_update_bits(rt5677->regmap, RT5677_ASRC_8, asrc8_mask,
+			asrc8_value);
+
 	return 0;
 }
 EXPORT_SYMBOL_GPL(rt5677_sel_asrc_clk_src);
 
+static int rt5677_dmic_use_asrc(struct snd_soc_dapm_widget *source,
+			 struct snd_soc_dapm_widget *sink)
+{
+	struct snd_soc_codec *codec = snd_soc_dapm_to_codec(source->dapm);
+	struct rt5677_priv *rt5677 = snd_soc_codec_get_drvdata(codec);
+	unsigned int asrc_setting;
+
+	switch (source->shift) {
+	case 11:
+		regmap_read(rt5677->regmap, RT5677_ASRC_5, &asrc_setting);
+		asrc_setting = (asrc_setting & RT5677_AD_STO1_CLK_SEL_MASK) >>
+				RT5677_AD_STO1_CLK_SEL_SFT;
+		if (asrc_setting >= RT5677_CLK_SEL_I2S1_ASRC &&
+			asrc_setting <= RT5677_CLK_SEL_I2S6_ASRC)
+			return 1;
+		break;
+
+	case 10:
+		regmap_read(rt5677->regmap, RT5677_ASRC_5, &asrc_setting);
+		asrc_setting = (asrc_setting & RT5677_AD_STO2_CLK_SEL_MASK) >>
+				RT5677_AD_STO2_CLK_SEL_SFT;
+		if (asrc_setting >= RT5677_CLK_SEL_I2S1_ASRC &&
+			asrc_setting <= RT5677_CLK_SEL_I2S6_ASRC)
+			return 1;
+		break;
+
+	case 9:
+		regmap_read(rt5677->regmap, RT5677_ASRC_5, &asrc_setting);
+		asrc_setting = (asrc_setting & RT5677_AD_STO3_CLK_SEL_MASK) >>
+				RT5677_AD_STO3_CLK_SEL_SFT;
+		if (asrc_setting >= RT5677_CLK_SEL_I2S1_ASRC &&
+			asrc_setting <= RT5677_CLK_SEL_I2S6_ASRC)
+			return 1;
+		break;
+
+	case 8:
+		regmap_read(rt5677->regmap, RT5677_ASRC_5, &asrc_setting);
+		asrc_setting = (asrc_setting & RT5677_AD_STO4_CLK_SEL_MASK) >>
+			RT5677_AD_STO4_CLK_SEL_SFT;
+		if (asrc_setting >= RT5677_CLK_SEL_I2S1_ASRC &&
+			asrc_setting <= RT5677_CLK_SEL_I2S6_ASRC)
+			return 1;
+		break;
+
+	case 7:
+		regmap_read(rt5677->regmap, RT5677_ASRC_6, &asrc_setting);
+		asrc_setting = (asrc_setting & RT5677_AD_MONOL_CLK_SEL_MASK) >>
+			RT5677_AD_MONOL_CLK_SEL_SFT;
+		if (asrc_setting >= RT5677_CLK_SEL_I2S1_ASRC &&
+			asrc_setting <= RT5677_CLK_SEL_I2S6_ASRC)
+			return 1;
+		break;
+
+	case 6:
+		regmap_read(rt5677->regmap, RT5677_ASRC_6, &asrc_setting);
+		asrc_setting = (asrc_setting & RT5677_AD_MONOR_CLK_SEL_MASK) >>
+			RT5677_AD_MONOR_CLK_SEL_SFT;
+		if (asrc_setting >= RT5677_CLK_SEL_I2S1_ASRC &&
+			asrc_setting <= RT5677_CLK_SEL_I2S6_ASRC)
+			return 1;
+		break;
+
+	default:
+		break;
+	}
+
+	return 0;
+}
+
 /* Digital Mixer */
 static const struct snd_kcontrol_new rt5677_sto1_adc_l_mix[] = {
 	SOC_DAPM_SINGLE("ADC1 Switch", RT5677_STO1_ADC_MIXER,
@@ -2309,7 +2578,7 @@
 static int rt5677_bst1_event(struct snd_soc_dapm_widget *w,
 	struct snd_kcontrol *kcontrol, int event)
 {
-	struct snd_soc_codec *codec = snd_soc_dapm_to_codec(w->dapm);
+	struct snd_soc_codec *codec = w->codec;
 	struct rt5677_priv *rt5677 = snd_soc_codec_get_drvdata(codec);
 
 	switch (event) {
@@ -2333,7 +2602,7 @@
 static int rt5677_bst2_event(struct snd_soc_dapm_widget *w,
 	struct snd_kcontrol *kcontrol, int event)
 {
-	struct snd_soc_codec *codec = snd_soc_dapm_to_codec(w->dapm);
+	struct snd_soc_codec *codec = w->codec;
 	struct rt5677_priv *rt5677 = snd_soc_codec_get_drvdata(codec);
 
 	switch (event) {
@@ -2357,18 +2626,14 @@
 static int rt5677_set_pll1_event(struct snd_soc_dapm_widget *w,
 	struct snd_kcontrol *kcontrol, int event)
 {
-	struct snd_soc_codec *codec = snd_soc_dapm_to_codec(w->dapm);
+	struct snd_soc_codec *codec = w->codec;
 	struct rt5677_priv *rt5677 = snd_soc_codec_get_drvdata(codec);
 
 	switch (event) {
-	case SND_SOC_DAPM_PRE_PMU:
-		regmap_update_bits(rt5677->regmap, RT5677_PLL1_CTRL2, 0x2, 0x2);
-		break;
-
 	case SND_SOC_DAPM_POST_PMU:
+		regmap_update_bits(rt5677->regmap, RT5677_PLL1_CTRL2, 0x2, 0x2);
 		regmap_update_bits(rt5677->regmap, RT5677_PLL1_CTRL2, 0x2, 0x0);
 		break;
-
 	default:
 		return 0;
 	}
@@ -2379,18 +2644,14 @@
 static int rt5677_set_pll2_event(struct snd_soc_dapm_widget *w,
 	struct snd_kcontrol *kcontrol, int event)
 {
-	struct snd_soc_codec *codec = snd_soc_dapm_to_codec(w->dapm);
+	struct snd_soc_codec *codec = w->codec;
 	struct rt5677_priv *rt5677 = snd_soc_codec_get_drvdata(codec);
 
 	switch (event) {
-	case SND_SOC_DAPM_PRE_PMU:
-		regmap_update_bits(rt5677->regmap, RT5677_PLL2_CTRL2, 0x2, 0x2);
-		break;
-
 	case SND_SOC_DAPM_POST_PMU:
+		regmap_update_bits(rt5677->regmap, RT5677_PLL2_CTRL2, 0x2, 0x2);
 		regmap_update_bits(rt5677->regmap, RT5677_PLL2_CTRL2, 0x2, 0x0);
 		break;
-
 	default:
 		return 0;
 	}
@@ -2401,7 +2662,7 @@
 static int rt5677_set_micbias1_event(struct snd_soc_dapm_widget *w,
 	struct snd_kcontrol *kcontrol, int event)
 {
-	struct snd_soc_codec *codec = snd_soc_dapm_to_codec(w->dapm);
+	struct snd_soc_codec *codec = w->codec;
 	struct rt5677_priv *rt5677 = snd_soc_codec_get_drvdata(codec);
 
 	switch (event) {
@@ -2428,7 +2689,7 @@
 static int rt5677_if1_adc_tdm_event(struct snd_soc_dapm_widget *w,
 	struct snd_kcontrol *kcontrol, int event)
 {
-	struct snd_soc_codec *codec = snd_soc_dapm_to_codec(w->dapm);
+	struct snd_soc_codec *codec = w->codec;
 	struct rt5677_priv *rt5677 = snd_soc_codec_get_drvdata(codec);
 	unsigned int value;
 
@@ -2451,7 +2712,7 @@
 static int rt5677_if2_adc_tdm_event(struct snd_soc_dapm_widget *w,
 	struct snd_kcontrol *kcontrol, int event)
 {
-	struct snd_soc_codec *codec = snd_soc_dapm_to_codec(w->dapm);
+	struct snd_soc_codec *codec = w->codec;
 	struct rt5677_priv *rt5677 = snd_soc_codec_get_drvdata(codec);
 	unsigned int value;
 
@@ -2474,7 +2735,7 @@
 static int rt5677_vref_event(struct snd_soc_dapm_widget *w,
 	struct snd_kcontrol *kcontrol, int event)
 {
-	struct snd_soc_codec *codec = snd_soc_dapm_to_codec(w->dapm);
+	struct snd_soc_codec *codec = w->codec;
 	struct rt5677_priv *rt5677 = snd_soc_codec_get_drvdata(codec);
 
 	switch (event) {
@@ -2496,13 +2757,22 @@
 	return 0;
 }
 
+static int rt5677_dac_stereo1_filter_event(struct snd_soc_dapm_widget *w,
+	struct snd_kcontrol *kcontrol, int event)
+{
+	switch (event) {
+	case SND_SOC_DAPM_POST_PMU:
+		msleep(25);
+		break;
+	}
+	return 0;
+}
+
 static const struct snd_soc_dapm_widget rt5677_dapm_widgets[] = {
 	SND_SOC_DAPM_SUPPLY("PLL1", RT5677_PWR_ANLG2, RT5677_PWR_PLL1_BIT,
-		0, rt5677_set_pll1_event, SND_SOC_DAPM_PRE_PMU |
-		SND_SOC_DAPM_POST_PMU),
+		0, rt5677_set_pll1_event, SND_SOC_DAPM_POST_PMU),
 	SND_SOC_DAPM_SUPPLY("PLL2", RT5677_PWR_ANLG2, RT5677_PWR_PLL2_BIT,
-		0, rt5677_set_pll2_event, SND_SOC_DAPM_PRE_PMU |
-		SND_SOC_DAPM_POST_PMU),
+		0, rt5677_set_pll2_event, SND_SOC_DAPM_POST_PMU),
 
 	/* ASRC */
 	SND_SOC_DAPM_SUPPLY_S("I2S1 ASRC", 1, RT5677_ASRC_1, 0, 0, NULL, 0),
@@ -2908,6 +3178,7 @@
 	SND_SOC_DAPM_AIF_OUT("AIF4TX", "AIF4 Capture", 0, SND_SOC_NOPM, 0, 0),
 	SND_SOC_DAPM_AIF_IN("SLBRX", "SLIMBus Playback", 0, SND_SOC_NOPM, 0, 0),
 	SND_SOC_DAPM_AIF_OUT("SLBTX", "SLIMBus Capture", 0, SND_SOC_NOPM, 0, 0),
+	SND_SOC_DAPM_AIF_OUT("DSPTX", "DSP Buffer", 0, SND_SOC_NOPM, 0, 0),
 
 	/* Sidetone Mux */
 	SND_SOC_DAPM_MUX("Sidetone Mux", SND_SOC_NOPM, 0, 0,
@@ -2972,7 +3243,8 @@
 
 	/* DAC Mixer */
 	SND_SOC_DAPM_SUPPLY("dac stereo1 filter", RT5677_PWR_DIG2,
-		RT5677_PWR_DAC_S1F_BIT, 0, NULL, 0),
+		RT5677_PWR_DAC_S1F_BIT, 0, rt5677_dac_stereo1_filter_event,
+		SND_SOC_DAPM_POST_PMU),
 	SND_SOC_DAPM_SUPPLY("dac mono2 left filter", RT5677_PWR_DIG2,
 		RT5677_PWR_DAC_M2F_L_BIT, 0, NULL, 0),
 	SND_SOC_DAPM_SUPPLY("dac mono2 right filter", RT5677_PWR_DIG2,
@@ -3057,12 +3329,12 @@
 };
 
 static const struct snd_soc_dapm_route rt5677_dapm_routes[] = {
-	{ "Stereo1 DMIC Mux", NULL, "DMIC STO1 ASRC", can_use_asrc },
-	{ "Stereo2 DMIC Mux", NULL, "DMIC STO2 ASRC", can_use_asrc },
-	{ "Stereo3 DMIC Mux", NULL, "DMIC STO3 ASRC", can_use_asrc },
-	{ "Stereo4 DMIC Mux", NULL, "DMIC STO4 ASRC", can_use_asrc },
-	{ "Mono DMIC L Mux", NULL, "DMIC MONO L ASRC", can_use_asrc },
-	{ "Mono DMIC R Mux", NULL, "DMIC MONO R ASRC", can_use_asrc },
+	{ "Stereo1 DMIC Mux", NULL, "DMIC STO1 ASRC", rt5677_dmic_use_asrc },
+	{ "Stereo2 DMIC Mux", NULL, "DMIC STO2 ASRC", rt5677_dmic_use_asrc },
+	{ "Stereo3 DMIC Mux", NULL, "DMIC STO3 ASRC", rt5677_dmic_use_asrc },
+	{ "Stereo4 DMIC Mux", NULL, "DMIC STO4 ASRC", rt5677_dmic_use_asrc },
+	{ "Mono DMIC L Mux", NULL, "DMIC MONO L ASRC", rt5677_dmic_use_asrc },
+	{ "Mono DMIC R Mux", NULL, "DMIC MONO R ASRC", rt5677_dmic_use_asrc },
 	{ "I2S1", NULL, "I2S1 ASRC", can_use_asrc},
 	{ "I2S2", NULL, "I2S2 ASRC", can_use_asrc},
 	{ "I2S3", NULL, "I2S3 ASRC", can_use_asrc},
@@ -3435,11 +3707,24 @@
 	{ "SLBTX", NULL, "SLB ADC3 Mux" },
 	{ "SLBTX", NULL, "SLB ADC4 Mux" },
 
+	{ "DSPTX", NULL, "IB01 Bypass Mux" },
+
 	{ "IB01 Mux", "IF1 DAC 01", "IF1 DAC01" },
 	{ "IB01 Mux", "IF2 DAC 01", "IF2 DAC01" },
 	{ "IB01 Mux", "SLB DAC 01", "SLB DAC01" },
 	{ "IB01 Mux", "STO1 ADC MIX", "Stereo1 ADC MIX" },
-	{ "IB01 Mux", "VAD ADC/DAC1 FS", "DAC1 FS" },
+	/* The IB01 Mux controls the source for InBound0 and InBound1.
+	 * When the mux option "VAD ADC/DAC1 FS" is selected, "VAD ADC" goes to
+	 * InBound0 and "DAC1 FS" goes to InBound1. "VAD ADC" is used for
+	 * hotwording. "DAC1 FS" is not used currently.
+	 *
+	 * Creating a common widget node for "VAD ADC" + "DAC1 FS" and
+	 * connecting the common widget to IB01 Mux causes the issue where
+	 * there is an active path going from system playback -> "DAC1 FS" ->
+	 * IB01 Mux -> DSP Buffer -> hotword stream. This wrong path confuses
+	 * DAPM. Therefore "DAC1 FS" is ignored for now.
+	 */
+	{ "IB01 Mux", "VAD ADC/DAC1 FS", "VAD ADC Mux" },
 
 	{ "IB01 Bypass Mux", "Bypass", "IB01 Mux" },
 	{ "IB01 Bypass Mux", "Pass SRC", "IB01 Mux" },
@@ -3463,8 +3748,8 @@
 	{ "IB45 Bypass Mux", "Bypass", "IB45 Mux" },
 	{ "IB45 Bypass Mux", "Pass SRC", "IB45 Mux" },
 
-	{ "IB6 Mux", "IF1 DAC 6", "IF1 DAC6 Mux" },
-	{ "IB6 Mux", "IF2 DAC 6", "IF2 DAC6 Mux" },
+	{ "IB6 Mux", "IF1 DAC 6", "IF1 DAC6" },
+	{ "IB6 Mux", "IF2 DAC 6", "IF2 DAC6" },
 	{ "IB6 Mux", "SLB DAC 6", "SLB DAC6" },
 	{ "IB6 Mux", "STO4 ADC MIX L", "Stereo4 ADC MIXL" },
 	{ "IB6 Mux", "IF4 DAC L", "IF4 DAC L" },
@@ -3472,8 +3757,8 @@
 	{ "IB6 Mux", "STO2 ADC MIX L", "Stereo2 ADC MIXL" },
 	{ "IB6 Mux", "STO3 ADC MIX L", "Stereo3 ADC MIXL" },
 
-	{ "IB7 Mux", "IF1 DAC 7", "IF1 DAC7 Mux" },
-	{ "IB7 Mux", "IF2 DAC 7", "IF2 DAC7 Mux" },
+	{ "IB7 Mux", "IF1 DAC 7", "IF1 DAC7" },
+	{ "IB7 Mux", "IF2 DAC 7", "IF2 DAC7" },
 	{ "IB7 Mux", "SLB DAC 7", "SLB DAC7" },
 	{ "IB7 Mux", "STO4 ADC MIX R", "Stereo4 ADC MIXR" },
 	{ "IB7 Mux", "IF4 DAC R", "IF4 DAC R" },
@@ -3814,15 +4099,15 @@
 	{ "DAC1 FS", NULL, "DAC1 MIXL" },
 	{ "DAC1 FS", NULL, "DAC1 MIXR" },
 
-	{ "DAC2 L Mux", "IF1 DAC 2", "IF1 DAC2 Mux" },
-	{ "DAC2 L Mux", "IF2 DAC 2", "IF2 DAC2 Mux" },
+	{ "DAC2 L Mux", "IF1 DAC 2", "IF1 DAC2" },
+	{ "DAC2 L Mux", "IF2 DAC 2", "IF2 DAC2" },
 	{ "DAC2 L Mux", "IF3 DAC L", "IF3 DAC L" },
 	{ "DAC2 L Mux", "IF4 DAC L", "IF4 DAC L" },
 	{ "DAC2 L Mux", "SLB DAC 2", "SLB DAC2" },
 	{ "DAC2 L Mux", "OB 2", "OutBound2" },
 
-	{ "DAC2 R Mux", "IF1 DAC 3", "IF1 DAC3 Mux" },
-	{ "DAC2 R Mux", "IF2 DAC 3", "IF2 DAC3 Mux" },
+	{ "DAC2 R Mux", "IF1 DAC 3", "IF1 DAC3" },
+	{ "DAC2 R Mux", "IF2 DAC 3", "IF2 DAC3" },
 	{ "DAC2 R Mux", "IF3 DAC R", "IF3 DAC R" },
 	{ "DAC2 R Mux", "IF4 DAC R", "IF4 DAC R" },
 	{ "DAC2 R Mux", "SLB DAC 3", "SLB DAC3" },
@@ -3830,29 +4115,29 @@
 	{ "DAC2 R Mux", "Haptic Generator", "Haptic Generator" },
 	{ "DAC2 R Mux", "VAD ADC", "VAD ADC Mux" },
 
-	{ "DAC3 L Mux", "IF1 DAC 4", "IF1 DAC4 Mux" },
-	{ "DAC3 L Mux", "IF2 DAC 4", "IF2 DAC4 Mux" },
+	{ "DAC3 L Mux", "IF1 DAC 4", "IF1 DAC4" },
+	{ "DAC3 L Mux", "IF2 DAC 4", "IF2 DAC4" },
 	{ "DAC3 L Mux", "IF3 DAC L", "IF3 DAC L" },
 	{ "DAC3 L Mux", "IF4 DAC L", "IF4 DAC L" },
 	{ "DAC3 L Mux", "SLB DAC 4", "SLB DAC4" },
 	{ "DAC3 L Mux", "OB 4", "OutBound4" },
 
-	{ "DAC3 R Mux", "IF1 DAC 5", "IF1 DAC5 Mux" },
-	{ "DAC3 R Mux", "IF2 DAC 5", "IF2 DAC5 Mux" },
+	{ "DAC3 R Mux", "IF1 DAC 5", "IF1 DAC4" },
+	{ "DAC3 R Mux", "IF2 DAC 5", "IF2 DAC4" },
 	{ "DAC3 R Mux", "IF3 DAC R", "IF3 DAC R" },
 	{ "DAC3 R Mux", "IF4 DAC R", "IF4 DAC R" },
 	{ "DAC3 R Mux", "SLB DAC 5", "SLB DAC5" },
 	{ "DAC3 R Mux", "OB 5", "OutBound5" },
 
-	{ "DAC4 L Mux", "IF1 DAC 6", "IF1 DAC6 Mux" },
-	{ "DAC4 L Mux", "IF2 DAC 6", "IF2 DAC6 Mux" },
+	{ "DAC4 L Mux", "IF1 DAC 6", "IF1 DAC6" },
+	{ "DAC4 L Mux", "IF2 DAC 6", "IF2 DAC6" },
 	{ "DAC4 L Mux", "IF3 DAC L", "IF3 DAC L" },
 	{ "DAC4 L Mux", "IF4 DAC L", "IF4 DAC L" },
 	{ "DAC4 L Mux", "SLB DAC 6", "SLB DAC6" },
 	{ "DAC4 L Mux", "OB 6", "OutBound6" },
 
-	{ "DAC4 R Mux", "IF1 DAC 7", "IF1 DAC7 Mux" },
-	{ "DAC4 R Mux", "IF2 DAC 7", "IF2 DAC7 Mux" },
+	{ "DAC4 R Mux", "IF1 DAC 7", "IF1 DAC7" },
+	{ "DAC4 R Mux", "IF2 DAC 7", "IF2 DAC7" },
 	{ "DAC4 R Mux", "IF3 DAC R", "IF3 DAC R" },
 	{ "DAC4 R Mux", "IF4 DAC R", "IF4 DAC R" },
 	{ "DAC4 R Mux", "SLB DAC 7", "SLB DAC7" },
@@ -4281,68 +4566,6 @@
 	return 0;
 }
 
-static int rt5677_set_tdm_slot(struct snd_soc_dai *dai, unsigned int tx_mask,
-			unsigned int rx_mask, int slots, int slot_width)
-{
-	struct snd_soc_codec *codec = dai->codec;
-	struct rt5677_priv *rt5677 = snd_soc_codec_get_drvdata(codec);
-	unsigned int val = 0, slot_width_25 = 0;
-
-	if (rx_mask || tx_mask)
-		val |= (1 << 12);
-
-	switch (slots) {
-	case 4:
-		val |= (1 << 10);
-		break;
-	case 6:
-		val |= (2 << 10);
-		break;
-	case 8:
-		val |= (3 << 10);
-		break;
-	case 2:
-	default:
-		break;
-	}
-
-	switch (slot_width) {
-	case 20:
-		val |= (1 << 8);
-		break;
-	case 25:
-		slot_width_25 = 0x8080;
-	case 24:
-		val |= (2 << 8);
-		break;
-	case 32:
-		val |= (3 << 8);
-		break;
-	case 16:
-	default:
-		break;
-	}
-
-	switch (dai->id) {
-	case RT5677_AIF1:
-		regmap_update_bits(rt5677->regmap, RT5677_TDM1_CTRL1, 0x1f00,
-			val);
-		regmap_update_bits(rt5677->regmap, RT5677_DIG_MISC, 0x8000,
-			slot_width_25);
-		break;
-	case RT5677_AIF2:
-		regmap_update_bits(rt5677->regmap, RT5677_TDM2_CTRL1, 0x1f00,
-			val);
-		regmap_update_bits(rt5677->regmap, RT5677_DIG_MISC, 0x80,
-			slot_width_25);
-		break;
-	default:
-		break;
-	}
-
-	return 0;
-}
-
 static int rt5677_set_bias_level(struct snd_soc_codec *codec,
 			enum snd_soc_bias_level level)
 {
@@ -4354,8 +4577,6 @@
 
 	case SND_SOC_BIAS_PREPARE:
 		if (codec->dapm.bias_level == SND_SOC_BIAS_STANDBY) {
-			rt5677_set_dsp_vad(codec, false);
-
 			regmap_update_bits(rt5677->regmap, RT5677_PWR_ANLG1,
 				RT5677_LDO1_SEL_MASK | RT5677_LDO2_SEL_MASK,
 				0x0055);
@@ -4377,19 +4598,33 @@
 		break;
 
 	case SND_SOC_BIAS_STANDBY:
+		if (codec->dapm.bias_level == SND_SOC_BIAS_OFF &&
+				rt5677->dsp_vad_en_request) {
+			/* Re-enable the DSP if it was turned off at suspend */
+			rt5677->dsp_vad_en = true;
+			/* The delay is to wait for MCLK */
+			schedule_delayed_work(&rt5677->dsp_work,
+					msecs_to_jiffies(1000));
+		}
 		break;
 
 	case SND_SOC_BIAS_OFF:
+		flush_delayed_work(&rt5677->dsp_work);
+		if (rt5677->is_dsp_mode) {
+			/* Turn off the DSP before suspend */
+			rt5677->dsp_vad_en = false;
+			schedule_delayed_work(&rt5677->dsp_work, 0);
+			flush_delayed_work(&rt5677->dsp_work);
+		}
+
 		regmap_update_bits(rt5677->regmap, RT5677_DIG_MISC, 0x1, 0x0);
 		regmap_write(rt5677->regmap, RT5677_PWR_DIG1, 0x0000);
-		regmap_write(rt5677->regmap, RT5677_PWR_DIG2, 0x0000);
 		regmap_write(rt5677->regmap, RT5677_PWR_ANLG1, 0x0022);
-		regmap_write(rt5677->regmap, RT5677_PWR_ANLG2, 0x0000);
+		regmap_update_bits(rt5677->regmap, RT5677_PWR_ANLG2,
+			RT5677_PWR_CORE, 0);
 		regmap_update_bits(rt5677->regmap,
 			RT5677_PR_BASE + RT5677_BIAS_CUR4, 0x0f00, 0x0000);
 
-		if (rt5677->dsp_vad_en)
-			rt5677_set_dsp_vad(codec, true);
 		break;
 
 	default:
@@ -4520,7 +4755,6 @@
 static int rt5677_to_irq(struct gpio_chip *chip, unsigned offset)
 {
 	struct rt5677_priv *rt5677 = gpio_to_rt5677(chip);
-	struct regmap_irq_chip_data *data = rt5677->irq_data;
 	int irq;
 
 	if (offset >= RT5677_GPIO1 && offset <= RT5677_GPIO3) {
@@ -4554,7 +4788,7 @@
 		}
 	}
 
-	return regmap_irq_get_virq(data, irq);
+	return irq_create_mapping(rt5677->domain, irq);
 }
 
 static struct gpio_chip rt5677_template_chip = {
@@ -4604,6 +4838,7 @@
 }
 #endif
 
+
 static int rt5677_probe(struct snd_soc_codec *codec)
 {
 	struct rt5677_priv *rt5677 = snd_soc_codec_get_drvdata(codec);
@@ -4623,37 +4858,13 @@
 
 	rt5677_set_bias_level(codec, SND_SOC_BIAS_OFF);
 
-	regmap_write(rt5677->regmap, RT5677_DIG_MISC, 0x0020);
+	regmap_update_bits(rt5677->regmap, RT5677_DIG_MISC,
+			~RT5677_IRQ_DEBOUNCE_SEL_MASK, 0x0020);
 	regmap_write(rt5677->regmap, RT5677_PWR_DSP2, 0x0c00);
 
 	for (i = 0; i < RT5677_GPIO_NUM; i++)
 		rt5677_gpio_config(rt5677, i, rt5677->pdata.gpio_config[i]);
 
-	if (rt5677->irq_data) {
-		regmap_update_bits(rt5677->regmap, RT5677_GPIO_CTRL1, 0x8000,
-			0x8000);
-		regmap_update_bits(rt5677->regmap, RT5677_DIG_MISC, 0x0018,
-			0x0008);
-
-		if (rt5677->pdata.jd1_gpio)
-			regmap_update_bits(rt5677->regmap, RT5677_JD_CTRL1,
-				RT5677_SEL_GPIO_JD1_MASK,
-				rt5677->pdata.jd1_gpio <<
-				RT5677_SEL_GPIO_JD1_SFT);
-
-		if (rt5677->pdata.jd2_gpio)
-			regmap_update_bits(rt5677->regmap, RT5677_JD_CTRL1,
-				RT5677_SEL_GPIO_JD2_MASK,
-				rt5677->pdata.jd2_gpio <<
-				RT5677_SEL_GPIO_JD2_SFT);
-
-		if (rt5677->pdata.jd3_gpio)
-			regmap_update_bits(rt5677->regmap, RT5677_JD_CTRL1,
-				RT5677_SEL_GPIO_JD3_MASK,
-				rt5677->pdata.jd3_gpio <<
-				RT5677_SEL_GPIO_JD3_SFT);
-	}
-
 	mutex_init(&rt5677->dsp_cmd_lock);
 	mutex_init(&rt5677->dsp_pri_lock);
 
@@ -4664,6 +4875,8 @@
 {
 	struct rt5677_priv *rt5677 = snd_soc_codec_get_drvdata(codec);
 
+	cancel_delayed_work_sync(&rt5677->dsp_work);
+
 	regmap_write(rt5677->regmap, RT5677_RESET, 0x10ec);
 	if (gpio_is_valid(rt5677->pow_ldo2))
 		gpio_set_value_cansleep(rt5677->pow_ldo2, 0);
@@ -4676,14 +4889,19 @@
 {
 	struct rt5677_priv *rt5677 = snd_soc_codec_get_drvdata(codec);
 
+	if (rt5677->irq) {
+		cancel_delayed_work_sync(&rt5677->resume_irq_check);
+		disable_irq(rt5677->irq);
+	}
+
 	if (!rt5677->dsp_vad_en) {
 		regcache_cache_only(rt5677->regmap, true);
 		regcache_mark_dirty(rt5677->regmap);
-
-		if (gpio_is_valid(rt5677->pow_ldo2))
-			gpio_set_value_cansleep(rt5677->pow_ldo2, 0);
 	}
 
+	if (gpio_is_valid(rt5677->pow_ldo2))
+		gpio_set_value_cansleep(rt5677->pow_ldo2, 0);
+
 	return 0;
 }
 
@@ -4691,16 +4909,21 @@
 {
 	struct rt5677_priv *rt5677 = snd_soc_codec_get_drvdata(codec);
 
-	if (!rt5677->dsp_vad_en) {
-		if (gpio_is_valid(rt5677->pow_ldo2)) {
-			gpio_set_value_cansleep(rt5677->pow_ldo2, 1);
-			msleep(10);
-		}
+	if (gpio_is_valid(rt5677->pow_ldo2)) {
+		gpio_set_value_cansleep(rt5677->pow_ldo2, 1);
+		msleep(10);
+	}
 
+	if (!rt5677->dsp_vad_en) {
 		regcache_cache_only(rt5677->regmap, false);
 		regcache_sync(rt5677->regmap);
 	}
 
+	if (rt5677->irq) {
+		enable_irq(rt5677->irq);
+		schedule_delayed_work(&rt5677->resume_irq_check, 0);
+	}
+
 	return 0;
 }
 #else
@@ -4762,7 +4985,6 @@
 	.set_fmt = rt5677_set_dai_fmt,
 	.set_sysclk = rt5677_set_dai_sysclk,
 	.set_pll = rt5677_set_dai_pll,
-	.set_tdm_slot = rt5677_set_tdm_slot,
 };
 
 static struct snd_soc_dai_driver rt5677_dai[] = {
@@ -4861,6 +5083,17 @@
 		},
 		.ops = &rt5677_aif_dai_ops,
 	},
+	{
+		.name = "rt5677-dspbuffer",
+		.id = RT5677_DSPBUFF,
+		.capture = {
+			.stream_name = "DSP Buffer",
+			.channels_min = 1,
+			.channels_max = 1,
+			.rates = SNDRV_PCM_RATE_16000,
+			.formats = SNDRV_PCM_FMTBIT_S16_LE,
+		},
+	},
 };
 
 static struct snd_soc_codec_driver soc_codec_dev_rt5677 = {
@@ -4912,14 +5145,16 @@
 };
 
 static const struct i2c_device_id rt5677_i2c_id[] = {
-	{ "rt5677", RT5677 },
-	{ "rt5676", RT5676 },
+	{ "rt5677", 0 },
 	{ }
 };
 MODULE_DEVICE_TABLE(i2c, rt5677_i2c_id);
 
 static int rt5677_parse_dt(struct rt5677_priv *rt5677, struct device_node *np)
 {
+	of_property_read_u32(np, "realtek,micbias1", &rt5677->pdata.micbias1);
+	rt5677->pdata.internal_dacref_en = of_property_read_bool(np,
+					"realtek,internal-dacref-en");
 	rt5677->pdata.in1_diff = of_property_read_bool(np,
 					"realtek,in1-differential");
 	rt5677->pdata.in2_diff = of_property_read_bool(np,
@@ -4930,6 +5165,10 @@
 					"realtek,lout2-differential");
 	rt5677->pdata.lout3_diff = of_property_read_bool(np,
 					"realtek,lout3-differential");
+	of_property_read_u32(np, "realtek,pdm_clk_div",
+					&rt5677->pdata.pdm_clk_div);
+	rt5677->pdata.asrc_en = of_property_read_bool(np,
+					"realtek,asrc-en");
 
 	rt5677->pow_ldo2 = of_get_named_gpio(np,
 					"realtek,pow-ldo2-gpio", 0);
@@ -4954,65 +5193,317 @@
 	return 0;
 }
 
-static struct regmap_irq rt5677_irqs[] = {
+#ifdef CONFIG_ACPI
+
+static unsigned long long rt5677_parse_acpi_entry(struct device *dev,
+		acpi_string name)
+{
+	acpi_handle handle = ACPI_HANDLE(dev);
+	unsigned long long val;
+	acpi_status status;
+
+	status = acpi_evaluate_integer(handle, name, NULL, &val);
+	if (ACPI_FAILURE(status)) {
+		dev_err(dev, "Failed to parse ACPI entry %s, default to 0: %d\n",
+				name, status);
+		return 0;
+	}
+	return val;
+}
+
+static void rt5677_parse_acpi(struct rt5677_priv *rt5677, struct device *dev)
+{
+	rt5677->pdata.micbias1 = (enum rt5677_micbias)
+		rt5677_parse_acpi_entry(dev, "MB1");
+	rt5677->pdata.internal_dacref_en = (bool)
+		rt5677_parse_acpi_entry(dev, "DACR");
+	rt5677->pdata.dmic2_clk_pin = (enum rt5677_dmic2_clk)
+		rt5677_parse_acpi_entry(dev, "DCLK");
+	rt5677->pdata.pdm_clk_div = (enum rt5677_pdm_clk_div)
+		rt5677_parse_acpi_entry(dev, "PCLK");
+	rt5677->pdata.in1_diff = (bool)rt5677_parse_acpi_entry(dev, "IN1");
+	rt5677->pdata.in2_diff = (bool)rt5677_parse_acpi_entry(dev, "IN2");
+	rt5677->pdata.lout1_diff = (bool)rt5677_parse_acpi_entry(dev, "OUT1");
+	rt5677->pdata.lout2_diff = (bool)rt5677_parse_acpi_entry(dev, "OUT2");
+	rt5677->pdata.lout3_diff = (bool)rt5677_parse_acpi_entry(dev, "OUT3");
+	rt5677->pdata.asrc_en = (bool)rt5677_parse_acpi_entry(dev, "ASRC");
+	rt5677->pdata.jd1_gpio = rt5677_parse_acpi_entry(dev, "JD1");
+	rt5677->pdata.jd2_gpio = rt5677_parse_acpi_entry(dev, "JD2");
+	rt5677->pdata.jd3_gpio = rt5677_parse_acpi_entry(dev, "JD3");
+}
+#else
+static void rt5677_parse_acpi(struct rt5677_priv *rt5677, struct device *dev)
+{
+}
+#endif
+
+struct rt5677_irq_desc {
+	unsigned int enable_mask;
+	unsigned int status_mask;
+	unsigned int polarity_mask;
+};
+
+static const struct rt5677_irq_desc rt5677_irq_descs[] = {
 	[RT5677_IRQ_JD1] = {
-		.reg_offset = 0,
-		.mask = RT5677_EN_IRQ_GPIO_JD1,
+		.enable_mask = RT5677_EN_IRQ_GPIO_JD1,
+		.status_mask = RT5677_STA_GPIO_JD1,
+		.polarity_mask = RT5677_INV_GPIO_JD1,
 	},
 	[RT5677_IRQ_JD2] = {
-		.reg_offset = 0,
-		.mask = RT5677_EN_IRQ_GPIO_JD2,
+		.enable_mask = RT5677_EN_IRQ_GPIO_JD2,
+		.status_mask = RT5677_STA_GPIO_JD2,
+		.polarity_mask = RT5677_INV_GPIO_JD2,
 	},
 	[RT5677_IRQ_JD3] = {
-		.reg_offset = 0,
-		.mask = RT5677_EN_IRQ_GPIO_JD3,
+		.enable_mask = RT5677_EN_IRQ_GPIO_JD3,
+		.status_mask = RT5677_STA_GPIO_JD3,
+		.polarity_mask = RT5677_INV_GPIO_JD3,
 	},
 };
 
-static struct regmap_irq_chip rt5677_irq_chip = {
-	.name = "rt5677",
-	.irqs = rt5677_irqs,
-	.num_irqs = ARRAY_SIZE(rt5677_irqs),
-
-	.num_regs = 1,
-	.status_base = RT5677_IRQ_CTRL1,
-	.mask_base = RT5677_IRQ_CTRL1,
-	.mask_invert = 1,
-};
+bool rt5677_check_hotword(struct rt5677_priv *rt5677)
+{
+	int reg_gpio;
+	if (!rt5677->is_dsp_mode)
+		return false;
 
-static int rt5677_init_irq(struct i2c_client *i2c)
+	if (regmap_read(rt5677->regmap, RT5677_GPIO_CTRL1, &reg_gpio))
+		return false;
+
+	/* Firmware sets GPIO1 pin to be GPIO1 after hotword is detected */
+	if ((reg_gpio & RT5677_GPIO1_PIN_MASK) == RT5677_GPIO1_PIN_IRQ)
+		return false;
+
+	/* Set GPIO1 pin back to be IRQ output for jack detect */
+	regmap_update_bits(rt5677->regmap, RT5677_GPIO_CTRL1,
+			RT5677_GPIO1_PIN_MASK, RT5677_GPIO1_PIN_IRQ);
+
+	rt5677_spi_hotword_detected();
+	return true;
+}
+
+static irqreturn_t rt5677_irq(int unused, void *data)
 {
-	int ret;
-	struct rt5677_priv *rt5677 = i2c_get_clientdata(i2c);
+	struct rt5677_priv *rt5677 = data;
+	int ret = 0, i, loop, reg_irq, virq;
+	bool irq_fired;
 
-	if (!rt5677->pdata.jd1_gpio &&
-		!rt5677->pdata.jd2_gpio &&
-		!rt5677->pdata.jd3_gpio)
-		return 0;
+	mutex_lock(&rt5677->irq_lock);
+	/*
+	 * Loop to handle interrupts until the last i2c read shows no pending
+	 * irqs. The interrupt line is shared by multiple interrupt sources.
+	 * After the regmap_read() below, a new interrupt source line may
+	 * become high before the regmap_write() finishes, so there isn't a
+	 * rising edge on the shared interrupt line for the new interrupt. Thus,
+	 * the loop is needed to avoid missing irqs.
+	 *
+	 * A safeguard of 20 loops is used to avoid hanging in the irq hander
+	 * if there is something wrong with the interrupt status update. The
+	 * interrupt sources here are audio jack plug/unplug events which
+	 * shouldn't happen at a high frequency for a long period of time.
+	 * Empirically, more than 3 loops have never been seen.
+	 */
+	for (loop = 0; loop < 20; loop++) {
+		/* Read interrupt status */
+		ret = regmap_read(rt5677->regmap, RT5677_IRQ_CTRL1, &reg_irq);
+		if (ret)
+			break;
+		/*
+		 * Clear the interrupt by flipping the polarity of the
+		 * interrupt source lines that just fired
+		 */
+		irq_fired = false;
+		for (i = 0; i < RT5677_IRQ_NUM; i++) {
+			if (reg_irq & rt5677_irq_descs[i].status_mask) {
+				reg_irq ^= rt5677_irq_descs[i].polarity_mask;
+				irq_fired = true;
+			}
+		}
 
-	if (!i2c->irq) {
-		dev_err(&i2c->dev, "No interrupt specified\n");
-		return -EINVAL;
+		/* Exit the loop only when we know for sure that GPIO1 pin
+		 * was low at some point since irq_lock was acquired. Any event
+		 * after that point creates a rising edge that triggers another
+		 * call to rt5677_irq().
+		 */
+		if (!irq_fired && !rt5677_check_hotword(rt5677))
+			break;
+
+		ret = regmap_write(rt5677->regmap, RT5677_IRQ_CTRL1, reg_irq);
+		if (ret)
+			break;
+
+		/* Process interrupts */
+		for (i = 0; i < RT5677_IRQ_NUM; i++) {
+			if ((reg_irq & rt5677_irq_descs[i].enable_mask) &&
+			    (reg_irq & rt5677_irq_descs[i].status_mask)) {
+				virq = irq_find_mapping(rt5677->domain, i);
+				if (virq)
+					handle_nested_irq(virq);
+			}
+		}
 	}
+	WARN_ON_ONCE(loop == 20);
+	mutex_unlock(&rt5677->irq_lock);
 
-	ret = regmap_add_irq_chip(rt5677->regmap, i2c->irq,
-		IRQF_TRIGGER_RISING | IRQF_TRIGGER_FALLING | IRQF_ONESHOT, 0,
-		&rt5677_irq_chip, &rt5677->irq_data);
+	return IRQ_HANDLED;
+}
+static void rt5677_resume_irq_check(struct work_struct *work)
+{
+	int i, virq;
+	struct rt5677_priv *rt5677 =
+		container_of(work, struct rt5677_priv, resume_irq_check.work);
 
-	if (ret != 0) {
-		dev_err(&i2c->dev, "Failed to register IRQ chip: %d\n", ret);
-		return ret;
+	/* This is needed to check and clear the interrupt status register
+	 * at resume. If the headset is plugged/unplugged when the device is
+	 * fully suspended, there won't be a rising edge at resume to trigger
+	 * the interrupt. Without this, we miss the next unplug/plug event.
+	 */
+	rt5677_irq(0, rt5677);
+
+	/* Call all enabled jack detect irq handlers again. This is needed in
+	 * addition to the above check for a corner case caused by jack gpio
+	 * debounce. After codec irq is disabled at suspend, the delayed work
+	 * scheduled by soc-jack may run and read wrong jack gpio values, since
+	 * the regmap is in cache only mode. At resume, there is no irq because
+	 * rt5677_irq has already ran and cleared the irq status at suspend.
+	 * Without this explicit check, unplug the headset right after suspend
+	 * starts, then after resume the headset is still shown as plugged in.
+	 */
+	mutex_lock(&rt5677->irq_lock);
+	for (i = 0; i < RT5677_IRQ_NUM; i++) {
+		if (rt5677->irq_en & rt5677_irq_descs[i].enable_mask) {
+			virq = irq_find_mapping(rt5677->domain, i);
+			if (virq)
+				handle_nested_irq(virq);
+		}
 	}
+	mutex_unlock(&rt5677->irq_lock);
+}
 
+static void rt5677_irq_bus_lock(struct irq_data *data)
+{
+	struct rt5677_priv *rt5677 = irq_data_get_irq_chip_data(data);
+	mutex_lock(&rt5677->irq_lock);
+}
+
+static void rt5677_irq_bus_sync_unlock(struct irq_data *data)
+{
+	struct rt5677_priv *rt5677 = irq_data_get_irq_chip_data(data);
+
+	regmap_update_bits(rt5677->regmap, RT5677_IRQ_CTRL1,
+			RT5677_EN_IRQ_GPIO_JD1 | RT5677_EN_IRQ_GPIO_JD2 |
+			RT5677_EN_IRQ_GPIO_JD3, rt5677->irq_en);
+	mutex_unlock(&rt5677->irq_lock);
+}
+
+static void rt5677_irq_enable(struct irq_data *data)
+{
+	struct rt5677_priv *rt5677 = irq_data_get_irq_chip_data(data);
+	rt5677->irq_en |= rt5677_irq_descs[data->hwirq].enable_mask;
+}
+
+static void rt5677_irq_disable(struct irq_data *data)
+{
+	struct rt5677_priv *rt5677 = irq_data_get_irq_chip_data(data);
+	rt5677->irq_en &= ~rt5677_irq_descs[data->hwirq].enable_mask;
+}
+
+static struct irq_chip rt5677_irq_chip = {
+	.name			= "rt5677_irq_chip",
+	.irq_bus_lock		= rt5677_irq_bus_lock,
+	.irq_bus_sync_unlock	= rt5677_irq_bus_sync_unlock,
+	.irq_disable		= rt5677_irq_disable,
+	.irq_enable		= rt5677_irq_enable,
+};
+
+static int rt5677_irq_map(struct irq_domain *h, unsigned int virq,
+			  irq_hw_number_t hw)
+{
+	struct rt5677_priv *rt5677 = h->host_data;
+
+	irq_set_chip_data(virq, rt5677);
+	irq_set_chip(virq, &rt5677_irq_chip);
+	irq_set_nested_thread(virq, 1);
+
+	/* ARM needs us to explicitly flag the IRQ as valid
+	 * and will set them noprobe when we do so. */
+#ifdef CONFIG_ARM
+	set_irq_flags(virq, IRQF_VALID);
+#else
+	irq_set_noprobe(virq);
+#endif
 	return 0;
 }
 
-static void rt5677_free_irq(struct i2c_client *i2c)
+static struct irq_domain_ops rt5677_domain_ops = {
+	.map	= rt5677_irq_map,
+	.xlate	= irq_domain_xlate_twocell,
+};
+
+static void rt5677_irq_init(struct i2c_client *i2c)
 {
 	struct rt5677_priv *rt5677 = i2c_get_clientdata(i2c);
+	int ret;
+	unsigned int jd_mask = 0, jd_val = 0;
+
+	/* No irq has been assigned to the codec */
+	if (!i2c->irq)
+		return;
 
-	if (rt5677->irq_data)
-		regmap_del_irq_chip(i2c->irq, rt5677->irq_data);
+	mutex_init(&rt5677->irq_lock);
+	INIT_DELAYED_WORK(&rt5677->resume_irq_check, rt5677_resume_irq_check);
+
+	/*
+	 * Select RC as the debounce clock so that GPIO works even when
+	 * MCLK is gated which happens when there is no audio stream
+	 * (SND_SOC_BIAS_OFF).
+	 */
+	regmap_update_bits(rt5677->regmap, RT5677_DIG_MISC,
+			RT5677_IRQ_DEBOUNCE_SEL_MASK,
+			RT5677_IRQ_DEBOUNCE_SEL_RC);
+	/* Enable auto power on RC when GPIO states are changed */
+	regmap_update_bits(rt5677->regmap, RT5677_GEN_CTRL1, 0xff, 0xff);
+
+	/* Select and enable jack detection sources per platform data */
+	if (rt5677->pdata.jd1_gpio) {
+		jd_mask	|= RT5677_SEL_GPIO_JD1_MASK;
+		jd_val	|= rt5677->pdata.jd1_gpio << RT5677_SEL_GPIO_JD1_SFT;
+	}
+	if (rt5677->pdata.jd2_gpio) {
+		jd_mask	|= RT5677_SEL_GPIO_JD2_MASK;
+		jd_val	|= rt5677->pdata.jd2_gpio << RT5677_SEL_GPIO_JD2_SFT;
+	}
+	if (rt5677->pdata.jd3_gpio) {
+		jd_mask	|= RT5677_SEL_GPIO_JD3_MASK;
+		jd_val	|= rt5677->pdata.jd3_gpio << RT5677_SEL_GPIO_JD3_SFT;
+	}
+	regmap_update_bits(rt5677->regmap, RT5677_JD_CTRL1, jd_mask, jd_val);
+
+	/* Set GPIO1 pin to be IRQ output */
+	regmap_update_bits(rt5677->regmap, RT5677_GPIO_CTRL1,
+			RT5677_GPIO1_PIN_MASK, RT5677_GPIO1_PIN_IRQ);
+
+	/* Ready to listen for interrupts */
+	rt5677->domain = irq_domain_add_linear(i2c->dev.of_node,
+			RT5677_IRQ_NUM, &rt5677_domain_ops, rt5677);
+	if (!rt5677->domain) {
+		dev_err(&i2c->dev, "Failed to create IRQ domain\n");
+		return;
+	}
+	ret = devm_request_threaded_irq(&i2c->dev, i2c->irq, NULL, rt5677_irq,
+			IRQF_TRIGGER_RISING | IRQF_ONESHOT,
+			"rt5677", rt5677);
+	if (ret) {
+		dev_err(&i2c->dev, "Failed to request IRQ: %d\n", ret);
+		return;
+	}
+	rt5677->irq = i2c->irq;
+}
+
+static void rt5677_irq_exit(struct i2c_client *i2c)
+{
+	struct rt5677_priv *rt5677 = i2c_get_clientdata(i2c);
+	cancel_delayed_work_sync(&rt5677->resume_irq_check);
 }
 
 static int rt5677_i2c_probe(struct i2c_client *i2c,
@@ -5028,13 +5519,14 @@
 	if (rt5677 == NULL)
 		return -ENOMEM;
 
+	INIT_DELAYED_WORK(&rt5677->dsp_work, rt5677_dsp_work);
+	rt5677->set_dsp_vad = rt5677_set_dsp_vad;
 	i2c_set_clientdata(i2c, rt5677);
 
-	rt5677->type = id->driver_data;
-
 	if (pdata)
 		rt5677->pdata = *pdata;
 
+	rt5677->pow_ldo2 = -EINVAL;
 	if (i2c->dev.of_node) {
 		ret = rt5677_parse_dt(rt5677, i2c->dev.of_node);
 		if (ret) {
@@ -5042,8 +5534,8 @@
 				ret);
 			return ret;
 		}
-	} else {
-		rt5677->pow_ldo2 = -EINVAL;
+	} else if (ACPI_HANDLE(&i2c->dev)) {
+		rt5677_parse_acpi(rt5677, &i2c->dev);
 	}
 
 	if (gpio_is_valid(rt5677->pow_ldo2)) {
@@ -5093,6 +5585,18 @@
 	if (ret != 0)
 		dev_warn(&i2c->dev, "Failed to apply regmap patch: %d\n", ret);
 
+	regmap_update_bits(rt5677->regmap, RT5677_MICBIAS,
+			RT5677_MICBIAS1_OUTVOLT_MASK |
+			RT5677_MICBIAS1_CTRL_VDD_MASK,
+			rt5677->pdata.micbias1 << RT5677_MICBIAS1_CTRL_VDD_SFT);
+
+	if (rt5677->pdata.internal_dacref_en) {
+		regmap_update_bits(rt5677->regmap, RT5677_PR_BASE +
+				RT5677_TEST_CTRL1, 1 << 9, 1 << 9);
+		regmap_update_bits(rt5677->regmap, RT5677_PR_BASE +
+				RT5677_SOFT_DEPOP_DAC_CLK_CTRL, 1 << 5, 1 << 5);
+	}
+
 	if (rt5677->pdata.in1_diff)
 		regmap_update_bits(rt5677->regmap, RT5677_IN1,
 					RT5677_IN_DF1, RT5677_IN_DF1);
@@ -5122,13 +5626,18 @@
 					RT5677_GPIO5_DIR_OUT);
 	}
 
-	if (rt5677->pdata.micbias1_vdd_3v3)
-		regmap_update_bits(rt5677->regmap, RT5677_MICBIAS,
-			RT5677_MICBIAS1_CTRL_VDD_MASK,
-			RT5677_MICBIAS1_CTRL_VDD_3_3V);
+	regmap_update_bits(rt5677->regmap, RT5677_PDM_DATA_CTRL1,
+			RT5677_PDM_DIV_MASK, rt5677->pdata.pdm_clk_div);
+
+	if (rt5677->pdata.asrc_en) {
+		/* Initial value of ASRC tracking for I2S1 of 48K sample rate
+		and 24M MCLK */
+		regmap_write(rt5677->regmap, RT5677_ASRC_13, 0x126e);
+		regmap_write(rt5677->regmap, RT5677_ASRC_19, 0x0003);
+	}
 
 	rt5677_init_gpio(i2c);
-	rt5677_init_irq(i2c);
+	rt5677_irq_init(i2c);
 
 	return snd_soc_register_codec(&i2c->dev, &soc_codec_dev_rt5677,
 				      rt5677_dai, ARRAY_SIZE(rt5677_dai));
@@ -5136,17 +5645,27 @@
 
 static int rt5677_i2c_remove(struct i2c_client *i2c)
 {
+	rt5677_irq_exit(i2c);
+
 	snd_soc_unregister_codec(&i2c->dev);
-	rt5677_free_irq(i2c);
 	rt5677_free_gpio(i2c);
 
 	return 0;
 }
 
+#ifdef CONFIG_ACPI
+static const struct acpi_device_id rt5677_acpi_id[] = {
+	{ "RT5677CE", 0 },
+	{ }
+};
+MODULE_DEVICE_TABLE(acpi, rt5677_acpi_id);
+#endif
+
 static struct i2c_driver rt5677_i2c_driver = {
 	.driver = {
 		.name = "rt5677",
 		.owner = THIS_MODULE,
+		.acpi_match_table = ACPI_PTR(rt5677_acpi_id),
 	},
 	.probe = rt5677_i2c_probe,
 	.remove   = rt5677_i2c_remove,
diff -Nru a/sound/soc/codecs/rt5677.h b/sound/soc/codecs/rt5677.h
--- a/sound/soc/codecs/rt5677.h	2015-08-16 23:52:51.000000000 -0400
+++ b/sound/soc/codecs/rt5677.h	2015-08-22 16:54:09.945983000 -0400
@@ -1446,6 +1446,16 @@
 #define RT5677_DSP_OB_4_7_CLK_SEL_MASK		(0xf << 8)
 #define RT5677_DSP_OB_4_7_CLK_SEL_SFT		8
 
+/* ASRC Control 8 (0x8a) */
+#define RT5677_I2S1_CLK_SEL_MASK		(0xf << 12)
+#define RT5677_I2S1_CLK_SEL_SFT			12
+#define RT5677_I2S2_CLK_SEL_MASK		(0xf << 8)
+#define RT5677_I2S2_CLK_SEL_SFT			8
+#define RT5677_I2S3_CLK_SEL_MASK		(0xf << 4)
+#define RT5677_I2S3_CLK_SEL_SFT			4
+#define RT5677_I2S4_CLK_SEL_MASK		(0xf)
+#define RT5677_I2S4_CLK_SEL_SFT			0
+
 /* VAD Function Control 4 (0x9f) */
 #define RT5677_VAD_SRC_MASK			(0x7 << 8)
 #define RT5677_VAD_SRC_SFT			8
@@ -1626,6 +1636,12 @@
 #define RT5677_GPIO6_P_NOR			(0x0 << 0)
 #define RT5677_GPIO6_P_INV			(0x1 << 0)
 
+/* General Control (0xfa) */
+#define RT5677_IRQ_DEBOUNCE_SEL_MASK		(0x3 << 3)
+#define RT5677_IRQ_DEBOUNCE_SEL_MCLK		(0x0 << 3)
+#define RT5677_IRQ_DEBOUNCE_SEL_RC		(0x1 << 3)
+#define RT5677_IRQ_DEBOUNCE_SEL_SLIM		(0x2 << 3)
+
 /* Virtual DSP Mixer Control (0xf7 0xf8 0xf9) */
 #define RT5677_DSP_IB_01_H			(0x1 << 15)
 #define RT5677_DSP_IB_01_H_SFT			15
@@ -1687,6 +1703,7 @@
 	RT5677_AIF4,
 	RT5677_AIF5,
 	RT5677_AIFS,
+	RT5677_DSPBUFF,
 };
 
 enum {
@@ -1703,11 +1720,7 @@
 	RT5677_IRQ_JD1,
 	RT5677_IRQ_JD2,
 	RT5677_IRQ_JD3,
-};
-
-enum rt5677_type {
-	RT5677,
-	RT5676,
+	RT5677_IRQ_NUM,
 };
 
 /* ASRC clock source selection */
@@ -1744,6 +1757,10 @@
 	RT5677_AD_MONO_R_FILTER = (0x1 << 12),
 	RT5677_DSP_OB_0_3_FILTER = (0x1 << 13),
 	RT5677_DSP_OB_4_7_FILTER = (0x1 << 14),
+	RT5677_I2S1_SOURCE = (0x1 << 15),
+	RT5677_I2S2_SOURCE = (0x1 << 16),
+	RT5677_I2S3_SOURCE = (0x1 << 17),
+	RT5677_I2S4_SOURCE = (0x1 << 18),
 };
 
 struct rt5677_priv {
@@ -1762,14 +1779,23 @@
 	int pll_in;
 	int pll_out;
 	int pow_ldo2; /* POW_LDO2 pin */
-	enum rt5677_type type;
 #ifdef CONFIG_GPIOLIB
 	struct gpio_chip gpio_chip;
 #endif
-	bool dsp_vad_en;
-	struct regmap_irq_chip_data *irq_data;
+	bool dsp_vad_en_request; /* DSP VAD enable/disable request */
+	bool dsp_vad_en; /* dsp_work parameter */
 	bool is_dsp_mode;
 	bool is_vref_slow;
+	struct delayed_work dsp_work;
+
+	/* Interrupt handling */
+	struct irq_domain *domain;
+	struct mutex irq_lock;
+	unsigned int irq_en;
+	struct delayed_work resume_irq_check;
+	int irq;
+
+	int (*set_dsp_vad)(struct snd_soc_codec *codec, bool on);
 };
 
 int rt5677_sel_asrc_clk_src(struct snd_soc_codec *codec,
diff -Nru a/sound/soc/intel/Kconfig b/sound/soc/intel/Kconfig
--- a/sound/soc/intel/Kconfig	2015-08-16 23:52:51.000000000 -0400
+++ b/sound/soc/intel/Kconfig	2015-08-22 16:54:09.945983000 -0400
@@ -3,7 +3,6 @@
 	depends on INTEL_SCU_IPC
 	select SND_SOC_SN95031
 	select SND_SST_MFLD_PLATFORM
-	select SND_SST_IPC_PCI
 	help
           This adds support for ASoC machine driver for Intel(R) MID Medfield platform
           used as alsa device in audio substem in Intel(R) MID devices
@@ -13,23 +12,10 @@
 config SND_SST_MFLD_PLATFORM
 	tristate
 
-config SND_SST_IPC
-	tristate
-
-config SND_SST_IPC_PCI
-	tristate
-	select SND_SST_IPC
-
-config SND_SST_IPC_ACPI
-	tristate
-	select SND_SST_IPC
-	depends on ACPI
-
 config SND_SOC_INTEL_SST
 	tristate "ASoC support for Intel(R) Smart Sound Technology"
 	select SND_SOC_INTEL_SST_ACPI if ACPI
-	depends on (X86 || COMPILE_TEST)
-	depends on DW_DMAC_CORE
+	depends on (X86 || COMPILE_TEST) && DW_DMAC
 	help
           This adds support for Intel(R) Smart Sound Technology (SST).
           Say Y if you have such a device
@@ -45,20 +31,19 @@
 	tristate
 
 config SND_SOC_INTEL_HASWELL_MACH
-	tristate "ASoC Audio DSP support for Intel Haswell Lynxpoint"
-	depends on SND_SOC_INTEL_SST && X86_INTEL_LPSS && I2C && \
-		   I2C_DESIGNWARE_PLATFORM
+        tristate "ASoC Audio DSP support for Intel Haswell Lynxpoint"
+        depends on SND_SOC_INTEL_SST && X86_INTEL_LPSS
 	select SND_SOC_INTEL_HASWELL
 	select SND_SOC_RT5640
 	help
-	  This adds support for the Lynxpoint Audio DSP on Intel(R) Haswell
+          This adds support for the Lynxpoint Audio DSP on Intel(R) Haswell
 	  Ultrabook platforms.
-	  Say Y if you have such a device
-	  If unsure select "N".
+          Say Y if you have such a device
+          If unsure select "N".
 
 config SND_SOC_INTEL_BYT_RT5640_MACH
 	tristate "ASoC Audio driver for Intel Baytrail with RT5640 codec"
-	depends on SND_SOC_INTEL_SST && X86_INTEL_LPSS && I2C
+	depends on SND_SOC_INTEL_SST && X86_INTEL_LPSS
 	select SND_SOC_INTEL_BAYTRAIL
 	select SND_SOC_RT5640
 	help
@@ -67,16 +52,17 @@
 
 config SND_SOC_INTEL_BYT_MAX98090_MACH
 	tristate "ASoC Audio driver for Intel Baytrail with MAX98090 codec"
-	depends on SND_SOC_INTEL_SST && X86_INTEL_LPSS && I2C
+	depends on SND_SOC_INTEL_SST && X86_INTEL_LPSS
 	select SND_SOC_INTEL_BAYTRAIL
 	select SND_SOC_MAX98090
+	select VLV2_PLAT_CLK
 	help
 	  This adds audio driver for Intel Baytrail platform based boards
 	  with the MAX98090 audio codec.
 
 config SND_SOC_INTEL_BROADWELL_MACH
 	tristate "ASoC Audio DSP support for Intel Broadwell Wildcatpoint"
-	depends on SND_SOC_INTEL_SST && X86_INTEL_LPSS && DW_DMAC && \
+	depends on SND_SOC_INTEL_SST && X86_INTEL_LPSS && DW_DMAC && \\
 		   I2C_DESIGNWARE_PLATFORM
 	select SND_SOC_INTEL_HASWELL
 	select SND_COMPRESS_OFFLOAD
@@ -87,37 +73,13 @@
 	  Say Y if you have such a device
 	  If unsure select "N".
 
-config SND_SOC_INTEL_BYTCR_RT5640_MACH
-	tristate "ASoC Audio DSP Support for MID BYT Platform"
-	depends on X86 && I2C
-	select SND_SOC_RT5640
-	select SND_SST_MFLD_PLATFORM
-	select SND_SST_IPC_ACPI
-	help
-	  This adds support for ASoC machine driver for Intel(R) MID Baytrail platform
-          used as alsa device in audio substem in Intel(R) MID devices
-          Say Y if you have such a device
-          If unsure select "N".
-
-config SND_SOC_INTEL_CHT_BSW_RT5672_MACH
-        tristate "ASoC Audio driver for Intel Cherrytrail & Braswell with RT5672 codec"
-        depends on X86_INTEL_LPSS && I2C
-        select SND_SOC_RT5670
-        select SND_SST_MFLD_PLATFORM
-        select SND_SST_IPC_ACPI
-        help
-          This adds support for ASoC machine driver for Intel(R) Cherrytrail & Braswell
-          platforms with RT5672 audio codec.
-          Say Y if you have such a device
-          If unsure select "N".
-
-config SND_SOC_INTEL_CHT_BSW_RT5645_MACH
-	tristate "ASoC Audio driver for Intel Cherrytrail & Braswell with RT5645 codec"
-	depends on X86_INTEL_LPSS
-	select SND_SOC_RT5645
-	select SND_SST_MFLD_PLATFORM
-	select SND_SST_IPC_ACPI
+config SND_SOC_INTEL_BDW_RT5677_MACH
+	tristate "ASoC driver for Intel Broadwell platforms with RT5677 codec"
+	depends on SND_SOC_INTEL_SST && X86_INTEL_LPSS && DW_DMAC
+	select SND_SOC_INTEL_HASWELL
+	select SND_COMPRESS_OFFLOAD
+	select SND_SOC_RT5677
 	help
-	  This adds support for ASoC machine driver for Intel(R) Cherrytrail & Braswell
-	  platforms with RT5645 audio codec.
+	  This adds the ASoC machine driver for Intel Broadwell platforms with RT5677 codec
+	  Say Y if you have such a device
 	  If unsure select "N".
diff -Nru a/sound/soc/intel/boards/Makefile b/sound/soc/intel/boards/Makefile
--- a/sound/soc/intel/boards/Makefile	2015-08-16 23:52:51.000000000 -0400
+++ b/sound/soc/intel/boards/Makefile	2015-08-22 16:54:09.945983000 -0400
@@ -2,10 +2,10 @@
 snd-soc-sst-byt-rt5640-mach-objs := byt-rt5640.o
 snd-soc-sst-byt-max98090-mach-objs := byt-max98090.o
 snd-soc-sst-broadwell-objs := broadwell.o
-snd-soc-sst-bytcr-rt5640-objs := bytcr_rt5640.o
-snd-soc-sst-cht-bsw-rt5672-objs := cht_bsw_rt5672.o
+snd-soc-sst-bdw-rt5677-mach-objs := bdw-rt5677.o
 snd-soc-sst-cht-bsw-rt5645-objs := cht_bsw_rt5645.o
 
+obj-$(CONFIG_SND_SOC_INTEL_BDW_RT5677_MACH) += snd-soc-sst-bdw-rt5677-mach.o
 obj-$(CONFIG_SND_SOC_INTEL_HASWELL_MACH) += snd-soc-sst-haswell.o
 obj-$(CONFIG_SND_SOC_INTEL_BYT_RT5640_MACH) += snd-soc-sst-byt-rt5640-mach.o
 obj-$(CONFIG_SND_SOC_INTEL_BYT_MAX98090_MACH) += snd-soc-sst-byt-max98090-mach.o
diff -Nru a/sound/soc/intel/boards/Makefile.orig b/sound/soc/intel/boards/Makefile.orig
--- a/sound/soc/intel/boards/Makefile.orig	1969-12-31 19:00:00.000000000 -0500
+++ b/sound/soc/intel/boards/Makefile.orig	2015-08-22 16:54:09.946983000 -0400
@@ -0,0 +1,15 @@
+snd-soc-sst-haswell-objs := haswell.o
+snd-soc-sst-byt-rt5640-mach-objs := byt-rt5640.o
+snd-soc-sst-byt-max98090-mach-objs := byt-max98090.o
+snd-soc-sst-broadwell-objs := broadwell.o
+snd-soc-sst-bytcr-rt5640-objs := bytcr_rt5640.o
+snd-soc-sst-cht-bsw-rt5672-objs := cht_bsw_rt5672.o
+snd-soc-sst-cht-bsw-rt5645-objs := cht_bsw_rt5645.o
+
+obj-$(CONFIG_SND_SOC_INTEL_HASWELL_MACH) += snd-soc-sst-haswell.o
+obj-$(CONFIG_SND_SOC_INTEL_BYT_RT5640_MACH) += snd-soc-sst-byt-rt5640-mach.o
+obj-$(CONFIG_SND_SOC_INTEL_BYT_MAX98090_MACH) += snd-soc-sst-byt-max98090-mach.o
+obj-$(CONFIG_SND_SOC_INTEL_BROADWELL_MACH) += snd-soc-sst-broadwell.o
+obj-$(CONFIG_SND_SOC_INTEL_BYTCR_RT5640_MACH) += snd-soc-sst-bytcr-rt5640.o
+obj-$(CONFIG_SND_SOC_INTEL_CHT_BSW_RT5672_MACH) += snd-soc-sst-cht-bsw-rt5672.o
+obj-$(CONFIG_SND_SOC_INTEL_CHT_BSW_RT5645_MACH) += snd-soc-sst-cht-bsw-rt5645.o
diff -Nru a/sound/soc/intel/boards/bdw-rt5677.c b/sound/soc/intel/boards/bdw-rt5677.c
--- a/sound/soc/intel/boards/bdw-rt5677.c	1969-12-31 19:00:00.000000000 -0500
+++ b/sound/soc/intel/boards/bdw-rt5677.c	2015-08-22 16:54:09.946983000 -0400
@@ -0,0 +1,380 @@
+/*
+ * ASoC machine driver for Intel Broadwell platforms with RT5677 codec
+ */
+
+#include <linux/module.h>
+#include <linux/platform_device.h>
+#include <linux/gpio/consumer.h>
+#include <linux/delay.h>
+#include <sound/core.h>
+#include <sound/pcm.h>
+#include <sound/soc.h>
+#include <sound/pcm_params.h>
+#include <sound/jack.h>
+
+#include "../common/sst-dsp.h"
+#include "../haswell/sst-haswell-ipc.h"
+
+#include "../../codecs/rt5677.h"
+
+/* GPIO indexes defined by ACPI */
+enum {
+	RT5677_GPIO_PLUG_DET,
+	RT5677_GPIO_MIC_PRESENT_L,
+	RT5677_GPIO_HOTWORD_DET_L,
+	RT5677_GPIO_DSP_INT,
+	RT5677_GPIO_HP_AMP_SHDN_L,
+};
+
+struct bdw_rt5677_priv {
+	struct gpio_desc *gpio_hp_en;
+	struct snd_soc_codec *codec;
+};
+
+static int bdw_rt5677_event_hp(struct snd_soc_dapm_widget *w,
+			struct snd_kcontrol *k, int event)
+{
+	struct snd_soc_dapm_context *dapm = w->dapm;
+	struct snd_soc_card *card = dapm->card;
+	struct bdw_rt5677_priv *bdw_rt5677 = snd_soc_card_get_drvdata(card);
+
+	if (SND_SOC_DAPM_EVENT_ON(event))
+		msleep(70);
+
+	gpiod_set_value_cansleep(bdw_rt5677->gpio_hp_en,
+		SND_SOC_DAPM_EVENT_ON(event));
+
+	return 0;
+}
+
+static const struct snd_soc_dapm_widget bdw_rt5677_widgets[] = {
+	SND_SOC_DAPM_HP("Headphone", bdw_rt5677_event_hp),
+	SND_SOC_DAPM_SPK("Speaker", NULL),
+	SND_SOC_DAPM_MIC("Headset Mic", NULL),
+	SND_SOC_DAPM_MIC("Local DMICs", NULL),
+	SND_SOC_DAPM_MIC("Remote DMICs", NULL),
+};
+
+static const struct snd_soc_dapm_route bdw_rt5677_map[] = {
+	/* Speakers */
+	{"Speaker", NULL, "PDM1L"},
+	{"Speaker", NULL, "PDM1R"},
+
+	/* Headset jack connectors */
+	{"Headphone", NULL, "LOUT1"},
+	{"Headphone", NULL, "LOUT2"},
+	{"IN1P", NULL, "Headset Mic"},
+	{"IN1N", NULL, "Headset Mic"},
+
+	/* Digital MICs
+	 * Local DMICs: the two DMICs on the mainboard
+	 * Remote DMICs: the two DMICs on the camera module
+	 */
+	{"DMIC L1", NULL, "Remote DMICs"},
+	{"DMIC R1", NULL, "Remote DMICs"},
+	{"DMIC L2", NULL, "Local DMICs"},
+	{"DMIC R2", NULL, "Local DMICs"},
+
+	/* CODEC BE connections */
+	{"SSP0 CODEC IN", NULL, "AIF1 Capture"},
+	{"AIF1 Playback", NULL, "SSP0 CODEC OUT"},
+};
+
+static const struct snd_kcontrol_new bdw_rt5677_controls[] = {
+	SOC_DAPM_PIN_SWITCH("Speaker"),
+	SOC_DAPM_PIN_SWITCH("Headphone"),
+	SOC_DAPM_PIN_SWITCH("Headset Mic"),
+	SOC_DAPM_PIN_SWITCH("Local DMICs"),
+	SOC_DAPM_PIN_SWITCH("Remote DMICs"),
+};
+
+
+static struct snd_soc_jack headphone_jack;
+static struct snd_soc_jack mic_jack;
+
+static struct snd_soc_jack_pin headphone_jack_pin = {
+	.pin	= "Headphone",
+	.mask	= SND_JACK_HEADPHONE,
+};
+
+static struct snd_soc_jack_pin mic_jack_pin = {
+	.pin	= "Headset Mic",
+	.mask	= SND_JACK_MICROPHONE,
+};
+
+static struct snd_soc_jack_gpio headphone_jack_gpio = {
+	.name			= "RT5677_GPIO_PLUG_DET",
+	.idx			= RT5677_GPIO_PLUG_DET,
+	.report			= SND_JACK_HEADPHONE,
+	.debounce_time		= 200,
+};
+
+static struct snd_soc_jack_gpio mic_jack_gpio = {
+	.name			= "RT5677_GPIO_MIC_PRESENT_L",
+	.idx			= RT5677_GPIO_MIC_PRESENT_L,
+	.report			= SND_JACK_MICROPHONE,
+	.debounce_time		= 200,
+	.invert			= 1,
+};
+
+static int broadwell_ssp0_fixup(struct snd_soc_pcm_runtime *rtd,
+			struct snd_pcm_hw_params *params)
+{
+	struct snd_interval *rate = hw_param_interval(params,
+			SNDRV_PCM_HW_PARAM_RATE);
+	struct snd_interval *channels = hw_param_interval(params,
+						SNDRV_PCM_HW_PARAM_CHANNELS);
+
+	/* The ADSP will covert the FE rate to 48k, stereo */
+	rate->min = rate->max = 48000;
+	channels->min = channels->max = 2;
+
+	/* set SSP0 to 16 bit */
+	snd_mask_set(&params->masks[SNDRV_PCM_HW_PARAM_FORMAT -
+				    SNDRV_PCM_HW_PARAM_FIRST_MASK],
+				    SNDRV_PCM_FORMAT_S16_LE);
+	return 0;
+}
+
+static int bdw_rt5677_hw_params(struct snd_pcm_substream *substream,
+	struct snd_pcm_hw_params *params)
+{
+	struct snd_soc_pcm_runtime *rtd = substream->private_data;
+	struct snd_soc_dai *codec_dai = rtd->codec_dai;
+	int ret;
+
+	ret = snd_soc_dai_set_sysclk(codec_dai, RT5677_SCLK_S_MCLK, 24576000,
+		SND_SOC_CLOCK_IN);
+	if (ret < 0) {
+		dev_err(rtd->dev, "can't set codec sysclk configuration\n");
+		return ret;
+	}
+
+	return ret;
+}
+
+static struct snd_soc_ops bdw_rt5677_ops = {
+	.hw_params = bdw_rt5677_hw_params,
+};
+
+static int bdw_rt5677_rtd_init(struct snd_soc_pcm_runtime *rtd)
+{
+	struct sst_pdata *pdata = dev_get_platdata(rtd->platform->dev);
+	struct sst_hsw *broadwell = pdata->dsp;
+	int ret;
+
+	/* Set ADSP SSP port settings */
+	ret = sst_hsw_device_set_config(broadwell, SST_HSW_DEVICE_SSP_0,
+		SST_HSW_DEVICE_MCLK_FREQ_24_MHZ,
+		SST_HSW_DEVICE_CLOCK_MASTER, 9);
+	if (ret < 0) {
+		dev_err(rtd->dev, "error: failed to set device config\n");
+		return ret;
+	}
+
+	return 0;
+}
+
+static int bdw_rt5677_init(struct snd_soc_pcm_runtime *rtd)
+{
+	struct bdw_rt5677_priv *bdw_rt5677 =
+			snd_soc_card_get_drvdata(rtd->card);
+	struct snd_soc_codec *codec = rtd->codec;
+	struct snd_soc_dapm_context *dapm = &codec->dapm;
+
+	/* Enable codec ASRC function for Stereo DAC/Stereo1 ADC/DMIC/I2S1.
+	 * The ASRC clock source is clk_i2s1_asrc.
+	 */
+	rt5677_sel_asrc_clk_src(codec, RT5677_DA_STEREO_FILTER |
+			RT5677_AD_STEREO1_FILTER | RT5677_I2S1_SOURCE,
+			RT5677_CLK_SEL_I2S1_ASRC);
+
+	/* Request rt5677 GPIO for headphone amp control */
+	bdw_rt5677->gpio_hp_en = devm_gpiod_get_index(codec->dev,
+		"RT5677_GPIO_HP_AMP_SHDN_L", RT5677_GPIO_HP_AMP_SHDN_L);
+	if (IS_ERR(bdw_rt5677->gpio_hp_en)) {
+		dev_err(codec->dev, "Can't find HP_AMP_SHDN_L gpio\n");
+		return PTR_ERR(bdw_rt5677->gpio_hp_en);
+	}
+	gpiod_direction_output(bdw_rt5677->gpio_hp_en, 0);
+
+	/* Create and initialize headphone jack */
+	if (!snd_soc_jack_new(codec, "Headphone Jack", SND_JACK_HEADPHONE,
+			&headphone_jack)) {
+		if (snd_soc_jack_add_pins(&headphone_jack, 1,
+				&headphone_jack_pin))
+			dev_err(codec->dev, "Can't add headphone jack pin\n");
+
+		headphone_jack_gpio.gpiod_dev = codec->dev;
+		if (snd_soc_jack_add_gpios(&headphone_jack, 1,
+				&headphone_jack_gpio))
+			dev_err(codec->dev, "Can't add headphone jack gpio\n");
+	} else {
+		dev_err(codec->dev, "Can't create headphone jack\n");
+	}
+
+	/* Create and initialize mic jack */
+	if (!snd_soc_jack_new(codec, "Mic Jack", SND_JACK_MICROPHONE,
+			&mic_jack)) {
+		if (snd_soc_jack_add_pins(&mic_jack, 1, &mic_jack_pin))
+			dev_err(codec->dev, "Can't add mic jack pin\n");
+
+		mic_jack_gpio.gpiod_dev = codec->dev;
+		if (snd_soc_jack_add_gpios(&mic_jack, 1, &mic_jack_gpio))
+			dev_err(codec->dev, "Can't add mic jack gpio\n");
+	} else {
+		dev_err(codec->dev, "Can't create mic jack\n");
+	}
+	bdw_rt5677->codec = codec;
+
+	snd_soc_dapm_force_enable_pin(dapm, "MICBIAS1");
+	return 0;
+}
+
+/* broadwell digital audio interface glue - connects codec <--> CPU */
+static struct snd_soc_dai_link bdw_rt5677_dais[] = {
+	/* Front End DAI links */
+	{
+		.name = "System PCM",
+		.stream_name = "System Playback",
+		.cpu_dai_name = "System Pin",
+		.platform_name = "haswell-pcm-audio",
+		.dynamic = 1,
+		.codec_name = "snd-soc-dummy",
+		.codec_dai_name = "snd-soc-dummy-dai",
+		.init = bdw_rt5677_rtd_init,
+		.trigger = {
+			SND_SOC_DPCM_TRIGGER_POST,
+			SND_SOC_DPCM_TRIGGER_POST
+		},
+		.dpcm_playback = 1,
+	},
+	{
+		.name = "Capture PCM",
+		.stream_name = "Capture",
+		.cpu_dai_name = "Capture Pin",
+		.platform_name = "haswell-pcm-audio",
+		.dynamic = 1,
+		.codec_name = "snd-soc-dummy",
+		.codec_dai_name = "snd-soc-dummy-dai",
+		.trigger = {
+			SND_SOC_DPCM_TRIGGER_POST,
+			SND_SOC_DPCM_TRIGGER_POST
+		},
+		.dpcm_capture = 1,
+	},
+
+	/* Non-DPCM links */
+	{
+		.name = "Codec DSP",
+		.stream_name = "Wake on Voice",
+		.cpu_name = "spi-RT5677AA:00",
+		.cpu_dai_name = "spi-RT5677AA:00",
+		.codec_name = "i2c-RT5677CE:00",
+		.codec_dai_name = "rt5677-dspbuffer",
+		.platform_name = "spi-RT5677AA:00",
+	},
+
+	/* Back End DAI links */
+	{
+		/* SSP0 - Codec */
+		.name = "Codec",
+		.be_id = 0,
+		.cpu_dai_name = "snd-soc-dummy-dai",
+		.platform_name = "snd-soc-dummy",
+		.no_pcm = 1,
+		.codec_name = "i2c-RT5677CE:00",
+		.codec_dai_name = "rt5677-aif1",
+		.dai_fmt = SND_SOC_DAIFMT_I2S | SND_SOC_DAIFMT_NB_NF |
+			SND_SOC_DAIFMT_CBS_CFS,
+		.ignore_suspend = 1,
+		.ignore_pmdown_time = 1,
+		.be_hw_params_fixup = broadwell_ssp0_fixup,
+		.ops = &bdw_rt5677_ops,
+		.dpcm_playback = 1,
+		.dpcm_capture = 1,
+		.init = bdw_rt5677_init,
+	},
+};
+
+static int bdw_rt5677_suspend_pre(struct snd_soc_card *card)
+{
+	struct bdw_rt5677_priv *bdw_rt5677 = snd_soc_card_get_drvdata(card);
+	struct snd_soc_dapm_context *dapm;
+
+	if (bdw_rt5677->codec) {
+		dapm = &bdw_rt5677->codec->dapm;
+		snd_soc_dapm_disable_pin(dapm, "MICBIAS1");
+	}
+	return 0;
+}
+
+static int bdw_rt5677_resume_post(struct snd_soc_card *card)
+{
+	struct bdw_rt5677_priv *bdw_rt5677 = snd_soc_card_get_drvdata(card);
+	struct snd_soc_dapm_context *dapm;
+
+	if (bdw_rt5677->codec) {
+		dapm = &bdw_rt5677->codec->dapm;
+		snd_soc_dapm_force_enable_pin(dapm, "MICBIAS1");
+	}
+	return 0;
+}
+
+/* ASoC machine driver for Broadwell DSP + RT5677 */
+static struct snd_soc_card bdw_rt5677_card = {
+	.name = "bdw-rt5677",
+	.owner = THIS_MODULE,
+	.dai_link = bdw_rt5677_dais,
+	.num_links = ARRAY_SIZE(bdw_rt5677_dais),
+	.dapm_widgets = bdw_rt5677_widgets,
+	.num_dapm_widgets = ARRAY_SIZE(bdw_rt5677_widgets),
+	.dapm_routes = bdw_rt5677_map,
+	.num_dapm_routes = ARRAY_SIZE(bdw_rt5677_map),
+	.controls = bdw_rt5677_controls,
+	.num_controls = ARRAY_SIZE(bdw_rt5677_controls),
+	.fully_routed = true,
+	.suspend_pre = bdw_rt5677_suspend_pre,
+	.resume_post = bdw_rt5677_resume_post,
+};
+
+static int bdw_rt5677_probe(struct platform_device *pdev)
+{
+	struct bdw_rt5677_priv *bdw_rt5677;
+
+	bdw_rt5677_card.dev = &pdev->dev;
+
+	/* Allocate driver private struct */
+	bdw_rt5677 = devm_kzalloc(&pdev->dev, sizeof(struct bdw_rt5677_priv),
+		GFP_KERNEL);
+	if (!bdw_rt5677) {
+		dev_err(&pdev->dev, "Can't allocate bdw_rt5677\n");
+		return -ENOMEM;
+	}
+	snd_soc_card_set_drvdata(&bdw_rt5677_card, bdw_rt5677);
+
+	return snd_soc_register_card(&bdw_rt5677_card);
+}
+
+static int bdw_rt5677_remove(struct platform_device *pdev)
+{
+	snd_soc_unregister_card(&bdw_rt5677_card);
+	return 0;
+}
+
+static struct platform_driver bdw_rt5677_audio = {
+	.probe = bdw_rt5677_probe,
+	.remove = bdw_rt5677_remove,
+	.driver = {
+		.name = "bdw-rt5677",
+		.owner = THIS_MODULE,
+	},
+};
+
+module_platform_driver(bdw_rt5677_audio)
+
+/* Module information */
+MODULE_AUTHOR("Ben Zhang");
+MODULE_DESCRIPTION("Intel Broadwell RT5677 machine driver");
+MODULE_LICENSE("GPL v2");
+MODULE_ALIAS("platform:bdw-rt5677");
diff -Nru a/sound/soc/intel/boards/broadwell.c b/sound/soc/intel/boards/broadwell.c
--- a/sound/soc/intel/boards/broadwell.c	2015-08-16 23:52:51.000000000 -0400
+++ b/sound/soc/intel/boards/broadwell.c	2015-08-22 16:54:09.946983000 -0400
@@ -27,19 +27,24 @@
 
 #include "../../codecs/rt286.h"
 
-static struct snd_soc_jack broadwell_headset;
+static struct snd_soc_jack broadwell_hp;
+static struct snd_soc_jack broadwell_mic;
+
 /* Headset jack detection DAPM pins */
-static struct snd_soc_jack_pin broadwell_headset_pins[] = {
-	{
-		.pin = "Mic Jack",
-		.mask = SND_JACK_MICROPHONE,
-	},
+static struct snd_soc_jack_pin broadwell_hp_pins[] = {
 	{
 		.pin = "Headphone Jack",
 		.mask = SND_JACK_HEADPHONE,
 	},
 };
 
+static struct snd_soc_jack_pin broadwell_mic_pins[] = {
+	{
+		.pin = "Mic Jack",
+		.mask = SND_JACK_MICROPHONE,
+	},
+};
+
 static const struct snd_kcontrol_new broadwell_controls[] = {
 	SOC_DAPM_PIN_SWITCH("Speaker"),
 	SOC_DAPM_PIN_SWITCH("Headphone Jack"),
@@ -80,13 +85,26 @@
 {
 	struct snd_soc_codec *codec = rtd->codec;
 	int ret = 0;
-	ret = snd_soc_card_jack_new(rtd->card, "Headset",
-		SND_JACK_HEADSET | SND_JACK_BTN_0, &broadwell_headset,
-		broadwell_headset_pins, ARRAY_SIZE(broadwell_headset_pins));
+
+	ret = snd_soc_jack_new(codec, "Headphone Jack", SND_JACK_HEADPHONE,
+				&broadwell_hp);
+	if (ret)
+		return ret;
+
+	ret = snd_soc_jack_add_pins(&broadwell_hp, 1, broadwell_hp_pins);
 	if (ret)
 		return ret;
 
-	rt286_mic_detect(codec, &broadwell_headset);
+	ret = snd_soc_jack_new(codec, "Mic Jack", SND_JACK_MICROPHONE,
+				&broadwell_mic);
+	if (ret)
+		return ret;
+
+	ret = snd_soc_jack_add_pins(&broadwell_mic, 1, broadwell_mic_pins);
+	if (ret)
+		return ret;
+
+	rt286_mic_detect(codec, &broadwell_hp, &broadwell_mic);
 	return 0;
 }
 
@@ -104,7 +122,9 @@
 	channels->min = channels->max = 2;
 
 	/* set SSP0 to 16 bit */
-	params_set_format(params, SNDRV_PCM_FORMAT_S16_LE);
+	snd_mask_set(&params->masks[SNDRV_PCM_HW_PARAM_FORMAT -
+				    SNDRV_PCM_HW_PARAM_FIRST_MASK],
+				    SNDRV_PCM_FORMAT_S16_LE);
 	return 0;
 }
 
@@ -132,6 +152,8 @@
 
 static int broadwell_rtd_init(struct snd_soc_pcm_runtime *rtd)
 {
+	struct snd_soc_codec *codec = rtd->codec;
+	struct snd_soc_dapm_context *dapm = &codec->dapm;
 	struct sst_pdata *pdata = dev_get_platdata(rtd->platform->dev);
 	struct sst_hsw *broadwell = pdata->dsp;
 	int ret;
@@ -145,6 +167,14 @@
 		return ret;
 	}
 
+	/* always connected - check HP for jack detect */
+	snd_soc_dapm_enable_pin(dapm, "Headphone Jack");
+	snd_soc_dapm_enable_pin(dapm, "Speaker");
+	snd_soc_dapm_enable_pin(dapm, "Mic Jack");
+	snd_soc_dapm_enable_pin(dapm, "Line Jack");
+	snd_soc_dapm_enable_pin(dapm, "DMIC1");
+	snd_soc_dapm_enable_pin(dapm, "DMIC2");
+
 	return 0;
 }
 
@@ -153,7 +183,7 @@
 	/* Front End DAI links */
 	{
 		.name = "System PCM",
-		.stream_name = "System Playback/Capture",
+		.stream_name = "System Playback",
 		.cpu_dai_name = "System Pin",
 		.platform_name = "haswell-pcm-audio",
 		.dynamic = 1,
@@ -162,7 +192,6 @@
 		.init = broadwell_rtd_init,
 		.trigger = {SND_SOC_DPCM_TRIGGER_POST, SND_SOC_DPCM_TRIGGER_POST},
 		.dpcm_playback = 1,
-		.dpcm_capture = 1,
 	},
 	{
 		.name = "Offload0",
@@ -197,6 +226,18 @@
 		.trigger = {SND_SOC_DPCM_TRIGGER_POST, SND_SOC_DPCM_TRIGGER_POST},
 		.dpcm_capture = 1,
 	},
+	{
+		.name = "Capture PCM",
+		.stream_name = "Capture",
+		.cpu_dai_name = "Capture Pin",
+		.platform_name = "haswell-pcm-audio",
+		.dynamic = 1,
+		.codec_name = "snd-soc-dummy",
+		.codec_dai_name = "snd-soc-dummy-dai",
+		.trigger = {SND_SOC_DPCM_TRIGGER_POST, SND_SOC_DPCM_TRIGGER_POST},
+		.dpcm_capture = 1,
+	},
+
 	/* Back End DAI links */
 	{
 		/* SSP0 - Codec */
@@ -219,32 +260,6 @@
 	},
 };
 
-static int broadwell_suspend(struct snd_soc_card *card){
-	struct snd_soc_codec *codec;
-
-	list_for_each_entry(codec, &card->codec_dev_list, card_list) {
-		if (!strcmp(codec->component.name, "i2c-INT343A:00")) {
-			dev_dbg(codec->dev, "disabling jack detect before going to suspend.\n");
-			rt286_mic_detect(codec, NULL);
-			break;
-		}
-	}
-	return 0;
-}
-
-static int broadwell_resume(struct snd_soc_card *card){
-	struct snd_soc_codec *codec;
-
-	list_for_each_entry(codec, &card->codec_dev_list, card_list) {
-		if (!strcmp(codec->component.name, "i2c-INT343A:00")) {
-			dev_dbg(codec->dev, "enabling jack detect for resume.\n");
-			rt286_mic_detect(codec, &broadwell_headset);
-			break;
-		}
-	}
-	return 0;
-}
-
 /* broadwell audio machine driver for WPT + RT286S */
 static struct snd_soc_card broadwell_rt286 = {
 	.name = "broadwell-rt286",
@@ -258,8 +273,6 @@
 	.dapm_routes = broadwell_rt286_map,
 	.num_dapm_routes = ARRAY_SIZE(broadwell_rt286_map),
 	.fully_routed = true,
-	.suspend_pre = broadwell_suspend,
-	.resume_post = broadwell_resume,
 };
 
 static int broadwell_audio_probe(struct platform_device *pdev)
@@ -280,6 +293,7 @@
 	.remove = broadwell_audio_remove,
 	.driver = {
 		.name = "broadwell-audio",
+		.owner = THIS_MODULE,
 	},
 };
 
diff -Nru a/sound/soc/intel/common/sst-acpi.c b/sound/soc/intel/common/sst-acpi.c
--- a/sound/soc/intel/common/sst-acpi.c	2015-08-16 23:52:51.000000000 -0400
+++ b/sound/soc/intel/common/sst-acpi.c	2015-08-22 16:54:09.946983000 -0400
@@ -142,7 +142,6 @@
 	sst_acpi->desc = desc;
 	sst_acpi->mach = mach;
 
-	sst_pdata->resindex_dma_base = desc->resindex_dma_base;
 	if (desc->resindex_dma_base >= 0) {
 		sst_pdata->dma_engine = desc->dma_engine;
 		sst_pdata->dma_base = desc->resindex_dma_base;
@@ -230,6 +229,7 @@
 
 static struct sst_acpi_mach broadwell_machines[] = {
 	{ "INT343A", "broadwell-audio", "intel/IntcSST2.bin" },
+	{ "RT5677CE", "bdw-rt5677", "intel/IntcSST2.bin" },
 	{}
 };
 
@@ -247,8 +247,8 @@
 };
 
 static struct sst_acpi_mach baytrail_machines[] = {
-	{ "10EC5640", "byt-rt5640", "intel/fw_sst_0f28.bin-48kHz_i2s_master" },
-	{ "193C9890", "byt-max98090", "intel/fw_sst_0f28.bin-48kHz_i2s_master" },
+	{ "10EC5640", "byt-rt5640", "intel/fw_sst_0f28.bin-i2s_master" },
+	{ "193C9890", "byt-max98090", "intel/fw_sst_0f28.bin-i2s_master" },
 	{}
 };
 
@@ -276,6 +276,7 @@
 	.remove = sst_acpi_remove,
 	.driver = {
 		.name = "sst-acpi",
+		.owner = THIS_MODULE,
 		.acpi_match_table = ACPI_PTR(sst_acpi_match),
 	},
 };
diff -Nru a/sound/soc/intel/common/sst-debugfs.c b/sound/soc/intel/common/sst-debugfs.c
--- a/sound/soc/intel/common/sst-debugfs.c	1969-12-31 19:00:00.000000000 -0500
+++ b/sound/soc/intel/common/sst-debugfs.c	2015-08-22 16:54:09.946983000 -0400
@@ -0,0 +1,170 @@
+/*
+ * Intel Smart Sound Technology (SST) debugfs support
+ *
+ * Copyright (C) 2014, Intel Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License version
+ * 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+#include <linux/slab.h>
+#include <linux/debugfs.h>
+#include <linux/uaccess.h>
+
+static struct dentry *rootdir;
+
+struct sst_dfsentry {
+	struct dentry *dfsentry;
+	size_t size;
+	void *buf;
+};
+
+static int sst_dfsentry_open(struct inode *inode, struct file *file)
+{
+	file->private_data = inode->i_private;
+
+	return 0;
+}
+
+static ssize_t sst_dfsentry_read(struct file *file, char __user *buffer,
+				 size_t count, loff_t *ppos)
+{
+	struct sst_dfsentry *dfse = file->private_data;
+	int i, size;
+	u32 *buf;
+
+	pr_debug("%s: pbuf: %p, *ppos: 0x%llx", __func__, buffer, *ppos);
+
+	size = dfse->size;
+
+	if (*ppos >= size)
+		return 0;
+	if (*ppos + count > size)
+		count = size - *ppos;
+
+	size = (count + 3) & (~3);
+	buf = kzalloc(size, GFP_KERNEL);
+	if (!buf) {
+		pr_err(" %s: kzalloc failed, aborting\n", __func__);
+		return -ENOMEM;
+	}
+
+	for (i = 0; i < size / sizeof(*buf); i++)
+		buf[i] = *(u32 *)(dfse->buf + *ppos + i * sizeof(*buf));
+
+	if (copy_to_user(buffer, buf, count))
+		return 0;
+	kfree(buf);
+
+	*ppos += count;
+
+	pr_debug("%s: *ppos: 0x%llx, count: %zu", __func__, *ppos, count);
+
+	return count;
+}
+
+static ssize_t sst_dfsentry_write(struct file *file, const char __user *buffer,
+				  size_t count, loff_t *ppos)
+{
+	struct sst_dfsentry *dfse = file->private_data;
+	int i, size;
+	u32 *buf;
+
+	pr_debug("%s: pbuf: %p, *ppos: 0x%llx", __func__, buffer, *ppos);
+
+	size = dfse->size;
+
+	if (*ppos >= size)
+		return 0;
+	if (*ppos + count > size)
+		count = size - *ppos;
+
+	size = (count + 3) & (~3);
+	buf = kzalloc(size, GFP_KERNEL);
+	if (!buf) {
+		pr_err(" %s: kzalloc failed, aborting\n", __func__);
+		return -ENOMEM;
+	}
+
+	if (copy_from_user(buf, buffer, count))
+		return 0;
+
+	for (i = 0; i < size / sizeof(*buf); i++)
+		*(u32 *)(dfse->buf + *ppos + i * sizeof(*buf)) = buf[i];
+
+	kfree(buf);
+	*ppos += count;
+
+	pr_debug("%s: *ppos: 0x%llx, count: %zu", __func__, *ppos, count);
+
+	return count;
+}
+
+static const struct file_operations sst_dfs_fops = {
+	.owner = THIS_MODULE,
+	.open = sst_dfsentry_open,
+	.read = sst_dfsentry_read,
+	.write = sst_dfsentry_write,
+};
+
+int sst_debugfs_add_mmio_entry(const char *filename, void *buf,
+			       size_t size, void **ctx)
+{
+	struct sst_dfsentry *dfse;
+
+	dfse = kzalloc(sizeof(*dfse), GFP_KERNEL);
+	if (!dfse) {
+		pr_err("%s: cannot create debugfs entry.\n", __func__);
+		return -ENOMEM;
+	}
+
+	dfse->buf = buf;
+	dfse->size = size;
+	dfse->dfsentry = debugfs_create_file(
+				filename, 0644, rootdir, dfse, &sst_dfs_fops);
+	if (!dfse->dfsentry) {
+		pr_err("%s: cannot create debugfs entry.\n", __func__);
+		return -ENODEV;
+	}
+	*ctx = dfse;
+
+	return 0;
+}
+
+void sst_debugfs_remove_mmio_entry(void *ctx)
+{
+	struct sst_dfsentry *dfse = (struct sst_dfsentry *)ctx;
+
+	debugfs_remove(dfse->dfsentry);
+	kfree(dfse);
+}
+
+int sst_debugfs_init(const char *dirname)
+{
+	if (rootdir) {
+		pr_err("%s: debugfs rootdir already initiated.\n", __func__);
+		return -EEXIST;
+	}
+	rootdir = debugfs_create_dir(dirname, NULL);
+
+	return 0;
+}
+
+void sst_debugfs_exit(void)
+{
+	debugfs_remove_recursive(rootdir);
+}
+
+void sst_debugfs_get_root(struct dentry *root)
+{
+	if (root) {
+		*root = *rootdir;
+	}
+}
+
diff -Nru a/sound/soc/intel/common/sst-debugfs.h b/sound/soc/intel/common/sst-debugfs.h
--- a/sound/soc/intel/common/sst-debugfs.h	1969-12-31 19:00:00.000000000 -0500
+++ b/sound/soc/intel/common/sst-debugfs.h	2015-08-22 16:54:09.946983000 -0400
@@ -0,0 +1,33 @@
+/*
+ * Intel Smart Sound Technology (SST) debugfs support
+ *
+ * Copyright (C) 2014, Intel Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License version
+ * 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+#ifndef __SOUND_SOC_SST_DEBUGFS_H
+#define __SOUND_SOC_SST_DEBUGFS_H
+#ifdef DEBUG
+int sst_debugfs_add_mmio_entry(const char *filename,
+			       void *buf, size_t size, void **ctx);
+void sst_debugfs_remove_mmio_entry(void *ctx);
+int sst_debugfs_init(const char *dirname);
+void sst_debugfs_exit(void);
+void sst_debugfs_get_root(struct dentry *root);
+#else
+#define sst_debugfs_add_mmio_entry(a, b, c, d)
+#define sst_debugfs_remove_mmio_entry(a)
+#define sst_debugfs_init(a)
+#define sst_debugfs_exit()
+#define sst_debugfs_get_root(a)
+#endif
+
+#endif
diff -Nru a/sound/soc/intel/common/sst-dsp-priv.h b/sound/soc/intel/common/sst-dsp-priv.h
--- a/sound/soc/intel/common/sst-dsp-priv.h	2015-08-16 23:52:51.000000000 -0400
+++ b/sound/soc/intel/common/sst-dsp-priv.h	2015-08-22 16:54:09.946983000 -0400
@@ -173,16 +173,6 @@
 };
 
 /*
- * Audio DSP Module State
- */
-enum sst_module_state {
-	SST_MODULE_STATE_UNLOADED = 0,	/* default state */
-	SST_MODULE_STATE_LOADED,
-	SST_MODULE_STATE_INITIALIZED,	/* and inactive */
-	SST_MODULE_STATE_ACTIVE,
-};
-
-/*
  * Audio DSP Generic Module.
  *
  * Each Firmware file can consist of 1..N modules. A module can span multiple
@@ -213,9 +203,6 @@
 	struct list_head list;		/* DSP list of modules */
 	struct list_head list_fw;	/* FW list of modules */
 	struct list_head runtime_list;	/* list of runtime module objects*/
-
-	/* state */
-	enum sst_module_state state;
 };
 
 /*
@@ -299,6 +286,10 @@
 	/* DMA FW loading */
 	struct sst_dma *dma;
 	bool fw_use_dma;
+
+	/* debugfs support */
+	void *debugfs_bar0;	/* DRAM and IRAM */
+	void *debugfs_bar1;	/* configuration space */
 };
 
 /* Size optimised DRAM/IRAM memcpy */
diff -Nru a/sound/soc/intel/common/sst-dsp.c b/sound/soc/intel/common/sst-dsp.c
--- a/sound/soc/intel/common/sst-dsp.c	2015-08-16 23:52:51.000000000 -0400
+++ b/sound/soc/intel/common/sst-dsp.c	2015-08-22 16:54:09.946983000 -0400
@@ -410,7 +410,8 @@
 	if (sst->ops->free)
 		sst->ops->free(sst);
 
-	sst_dma_free(sst->dma);
+	if (sst->dma)
+		sst_dma_free(sst->dma);
 }
 EXPORT_SYMBOL_GPL(sst_dsp_free);
 
diff -Nru a/sound/soc/intel/common/sst-dsp.h b/sound/soc/intel/common/sst-dsp.h
--- a/sound/soc/intel/common/sst-dsp.h	2015-08-16 23:52:51.000000000 -0400
+++ b/sound/soc/intel/common/sst-dsp.h	2015-08-22 16:54:09.947983000 -0400
@@ -28,6 +28,7 @@
 
 /* Supported SST DMA Devices */
 #define SST_DMA_TYPE_DW		1
+#define SST_DMA_TYPE_MID	2
 
 /* autosuspend delay 5s*/
 #define SST_RUNTIME_SUSPEND_DELAY	(5 * 1000)
@@ -160,14 +161,12 @@
 /* VDRTCTL0 */
 #define SST_VDRTCL0_D3PGD		(1 << 0)
 #define SST_VDRTCL0_D3SRAMPGD		(1 << 1)
-#define SST_VDRTCL0_DSRAMPGE_SHIFT	12
-#define SST_VDRTCL0_DSRAMPGE_MASK	(0xfffff << SST_VDRTCL0_DSRAMPGE_SHIFT)
-#define SST_VDRTCL0_ISRAMPGE_SHIFT	2
+#define SST_VDRTCL0_DSRAMPGE_SHIFT	16
+#define SST_VDRTCL0_DSRAMPGE_MASK	(0xffff << SST_VDRTCL0_DSRAMPGE_SHIFT)
+#define SST_VDRTCL0_ISRAMPGE_SHIFT	6
 #define SST_VDRTCL0_ISRAMPGE_MASK	(0x3ff << SST_VDRTCL0_ISRAMPGE_SHIFT)
 
 /* VDRTCTL2 */
-#define SST_VDRTCL2_DCLCGE		(1 << 1)
-#define SST_VDRTCL2_DTCGE		(1 << 10)
 #define SST_VDRTCL2_APLLSE_MASK		(1 << 31)
 
 /* PMCS */
@@ -205,7 +204,6 @@
 	const struct firmware *fw;
 
 	/* DMA */
-	int resindex_dma_base; /* other fields invalid if equals to -1 */
 	u32 dma_base;
 	u32 dma_size;
 	int dma_engine;
diff -Nru a/sound/soc/intel/common/sst-firmware.c b/sound/soc/intel/common/sst-firmware.c
--- a/sound/soc/intel/common/sst-firmware.c	2015-08-16 23:52:51.000000000 -0400
+++ b/sound/soc/intel/common/sst-firmware.c	2015-08-22 16:54:09.947983000 -0400
@@ -13,7 +13,6 @@
  * GNU General Public License for more details.
  *
  */
-
 #include <linux/kernel.h>
 #include <linux/slab.h>
 #include <linux/sched.h>
@@ -50,10 +49,13 @@
 	struct dma_chan *ch;
 };
 
-static inline void sst_memcpy32(volatile void __iomem *dest, void *src, u32 bytes)
+static void sst_memcpy32(volatile void __iomem *dest, void *src, u32 bytes)
 {
-	/* __iowrite32_copy use 32bit size values so divide by 4 */
-	__iowrite32_copy((void *)dest, src, bytes/4);
+	u32 i;
+
+	/* copy one 32 bit word at a time as 64 bit access is not supported */
+	for (i = 0; i < bytes; i += 4)
+		memcpy_toio(dest + i, src + i, 4);
 }
 
 static void sst_dma_transfer_complete(void *arg)
@@ -169,7 +171,7 @@
 	return ret;
 }
 
-static struct dw_dma_platform_data dw_pdata = {
+struct dw_dma_platform_data dw_pdata = {
 	.is_private = 1,
 	.chan_allocation_order = CHAN_ALLOCATION_ASCENDING,
 	.chan_priority = CHAN_PRIORITY_ASCENDING,
@@ -221,6 +223,8 @@
 	dma_cap_mask_t mask;
 	int ret;
 
+	/* The Intel MID DMA engine driver needs the slave config set but
+	 * Synopsis DMA engine driver safely ignores the slave config */
 	dma_cap_zero(mask);
 	dma_cap_set(DMA_SLAVE, mask);
 	dma_cap_set(DMA_MEMCPY, mask);
@@ -269,16 +273,15 @@
 	const char *dma_dev_name;
 	int ret = 0;
 
-	if (sst->pdata->resindex_dma_base == -1)
-		/* DMA is not used, return and squelsh error messages */
-		return 0;
-
 	/* configure the correct platform data for whatever DMA engine
 	* is attached to the ADSP IP. */
 	switch (sst->pdata->dma_engine) {
 	case SST_DMA_TYPE_DW:
 		dma_dev_name = "dw_dmac";
 		break;
+	case SST_DMA_TYPE_MID:
+		dma_dev_name = "Intel MID DMA";
+		break;
 	default:
 		dev_err(sst->dev, "error: invalid DMA engine %d\n",
 			sst->pdata->dma_engine);
@@ -496,8 +499,6 @@
 	sst_module->sst_fw = sst_fw;
 	sst_module->scratch_size = template->scratch_size;
 	sst_module->persistent_size = template->persistent_size;
-	sst_module->entry = template->entry;
-	sst_module->state = SST_MODULE_STATE_UNLOADED;
 
 	INIT_LIST_HEAD(&sst_module->block_list);
 	INIT_LIST_HEAD(&sst_module->runtime_list);
@@ -610,6 +611,7 @@
 	}
 
 	list_splice(&tmp, &dsp->used_block_list);
+
 	return 0;
 }
 
@@ -707,7 +709,6 @@
 	struct list_head *block_list)
 {
 	struct sst_mem_block *block, *tmp;
-	struct sst_block_allocator ba_tmp = *ba;
 	u32 end = ba->offset + ba->size, block_end;
 	int err;
 
@@ -732,9 +733,9 @@
 		if (ba->offset >= block->offset && ba->offset < block_end) {
 
 			/* align ba to block boundary */
-			ba_tmp.size -= block_end - ba->offset;
-			ba_tmp.offset = block_end;
-			err = block_alloc_contiguous(dsp, &ba_tmp, block_list);
+			ba->size -= block_end - ba->offset;
+			ba->offset = block_end;
+			err = block_alloc_contiguous(dsp, ba, block_list);
 			if (err < 0)
 				return -ENOMEM;
 
@@ -765,17 +766,12 @@
 		/* does block span more than 1 section */
 		if (ba->offset >= block->offset && ba->offset < block_end) {
 
-			/* add block */
-			list_move(&block->list, &dsp->used_block_list);
-			list_add(&block->module_list, block_list);
 			/* align ba to block boundary */
-			ba_tmp.size -= block_end - ba->offset;
-			ba_tmp.offset = block_end;
+			ba->offset = block->offset;
 
-			err = block_alloc_contiguous(dsp, &ba_tmp, block_list);
+			err = block_alloc_contiguous(dsp, ba, block_list);
 			if (err < 0)
 				return -ENOMEM;
-
 			return 0;
 		}
 	}
@@ -791,7 +787,6 @@
 	struct sst_block_allocator ba;
 	int ret;
 
-	memset(&ba, 0, sizeof(ba));
 	ba.size = module->size;
 	ba.type = module->type;
 	ba.offset = module->offset;
@@ -833,7 +828,7 @@
 			module->size);
 
 	mutex_unlock(&dsp->mutex);
-	return ret;
+	return 0;
 
 err:
 	block_list_remove(dsp, &module->block_list);
@@ -865,7 +860,6 @@
 	if (module->persistent_size == 0)
 		return 0;
 
-	memset(&ba, 0, sizeof(ba));
 	ba.size = module->persistent_size;
 	ba.type = SST_MEM_DRAM;
 
@@ -1128,7 +1122,6 @@
 	ret = block_list_prepare(dsp, &dsp->scratch_block_list);
 	if (ret < 0) {
 		dev_err(dsp->dev, "error: scratch block prepare failed\n");
-		mutex_unlock(&dsp->mutex);
 		return ret;
 	}
 
diff -Nru a/sound/soc/intel/haswell/Makefile b/sound/soc/intel/haswell/Makefile
--- a/sound/soc/intel/haswell/Makefile	2015-08-16 23:52:51.000000000 -0400
+++ b/sound/soc/intel/haswell/Makefile	2015-08-22 16:54:09.947983000 -0400
@@ -1,4 +1,7 @@
 snd-soc-sst-haswell-pcm-objs := \
-	        sst-haswell-ipc.o sst-haswell-pcm.o sst-haswell-dsp.o
+	sst-haswell-ipc.o sst-haswell-pcm.o sst-haswell-dsp.o
+ifdef CONFIG_DEBUG_FS
+	snd-soc-sst-haswell-pcm-objs += ../common/sst-debugfs.o
+endif
 
 obj-$(CONFIG_SND_SOC_INTEL_HASWELL) += snd-soc-sst-haswell-pcm.o
diff -Nru a/sound/soc/intel/haswell/sst-haswell-dsp.c b/sound/soc/intel/haswell/sst-haswell-dsp.c
--- a/sound/soc/intel/haswell/sst-haswell-dsp.c	2015-08-16 23:52:51.000000000 -0400
+++ b/sound/soc/intel/haswell/sst-haswell-dsp.c	2015-08-22 16:54:09.947983000 -0400
@@ -30,7 +30,8 @@
 
 #include "../common/sst-dsp.h"
 #include "../common/sst-dsp-priv.h"
-#include "../haswell/sst-haswell-ipc.h"
+#include "sst-haswell-ipc.h"
+#include "../common/sst-debugfs.h"
 
 #include <trace/events/hswadsp.h>
 
@@ -100,7 +101,6 @@
 		&& module->type != SST_HSW_MODULE_PCM
 		&& module->type != SST_HSW_MODULE_PCM_REFERENCE
 		&& module->type != SST_HSW_MODULE_PCM_CAPTURE
-		&& module->type != SST_HSW_MODULE_WAVES
 		&& module->type != SST_HSW_MODULE_LPAL)
 		return 0;
 
@@ -140,7 +140,6 @@
 			mod->type = SST_MEM_IRAM;
 			break;
 		case SST_HSW_DRAM:
-		case SST_HSW_REGS:
 			ram = dsp->addr.lpe;
 			mod->offset = block->ram_offset;
 			mod->type = SST_MEM_DRAM;
@@ -171,7 +170,6 @@
 
 		block = (void *)block + sizeof(*block) + block->size;
 	}
-	mod->state = SST_MODULE_STATE_LOADED;
 
 	return 0;
 }
@@ -210,6 +208,9 @@
 		module = (void *)module + sizeof(*module) + module->mod_size;
 	}
 
+	/* allocate scratch mem regions */
+	sst_block_alloc_scratch(dsp);
+
 	return 0;
 }
 
@@ -250,12 +251,6 @@
 static void hsw_set_dsp_D3(struct sst_dsp *sst)
 {
 	u32 val;
-	u32 reg;
-
-	/* Disable core clock gating (VDRTCTL2.DCLCGE = 0) */
-	reg = readl(sst->addr.pci_cfg + SST_VDRTCTL2);
-	reg &= ~(SST_VDRTCL2_DCLCGE | SST_VDRTCL2_DTCGE);
-	writel(reg, sst->addr.pci_cfg + SST_VDRTCTL2);
 
 	/* enable power gating and switch off DRAM & IRAM blocks */
 	val = readl(sst->addr.pci_cfg + SST_VDRTCTL0);
@@ -269,23 +264,10 @@
 	val |= SST_VDRTCL2_APLLSE_MASK;
 	writel(val, sst->addr.pci_cfg + SST_VDRTCTL2);
 
-	/* disable MCLK(clkctl.smos = 0) */
-	sst_dsp_shim_update_bits_unlocked(sst, SST_CLKCTL,
-		SST_CLKCTL_MASK, 0);
-
-	/* Set D3 state, delay 50 us */
+	/* Set D3 state */
 	val = readl(sst->addr.pci_cfg + SST_PMCS);
 	val |= SST_PMCS_PS_MASK;
 	writel(val, sst->addr.pci_cfg + SST_PMCS);
-	udelay(50);
-
-	/* Enable core clock gating (VDRTCTL2.DCLCGE = 1), delay 50 us */
-	reg = readl(sst->addr.pci_cfg + SST_VDRTCTL2);
-	reg |= SST_VDRTCL2_DCLCGE | SST_VDRTCL2_DTCGE;
-	writel(reg, sst->addr.pci_cfg + SST_VDRTCTL2);
-
-	udelay(50);
-
 }
 
 static void hsw_reset(struct sst_dsp *sst)
@@ -306,17 +288,7 @@
 static int hsw_set_dsp_D0(struct sst_dsp *sst)
 {
 	int tries = 10;
-	u32 reg, fw_dump_bit;
-
-	/* Disable core clock gating (VDRTCTL2.DCLCGE = 0) */
-	reg = readl(sst->addr.pci_cfg + SST_VDRTCTL2);
-	reg &= ~(SST_VDRTCL2_DCLCGE | SST_VDRTCL2_DTCGE);
-	writel(reg, sst->addr.pci_cfg + SST_VDRTCTL2);
-
-	/* Disable D3PG (VDRTCTL0.D3PGD = 1) */
-	reg = readl(sst->addr.pci_cfg + SST_VDRTCTL0);
-	reg |= SST_VDRTCL0_D3PGD;
-	writel(reg, sst->addr.pci_cfg + SST_VDRTCTL0);
+	u32 reg;
 
 	/* Set D0 state */
 	reg = readl(sst->addr.pci_cfg + SST_PMCS);
@@ -335,6 +307,17 @@
 	return -ENODEV;
 
 finish:
+	hsw_reset(sst);
+
+	/* switch on audio PLL */
+	reg = readl(sst->addr.pci_cfg + SST_VDRTCTL2);
+	reg &= ~SST_VDRTCL2_APLLSE_MASK;
+	writel(reg, sst->addr.pci_cfg + SST_VDRTCTL2);
+
+	/* set default power gating control, enable power gating control for all blocks. that is,
+	can't be accessed, please enable each block before accessing. */
+	writel(0xffffffff, sst->addr.pci_cfg + SST_VDRTCTL0);
+
 	/* select SSP1 19.2MHz base clock, SSP clock 0, turn off Low Power Clock */
 	sst_dsp_shim_update_bits_unlocked(sst, SST_CSR,
 		SST_CSR_S1IOCS | SST_CSR_SBCS1 | SST_CSR_LPCS, 0x0);
@@ -349,30 +332,6 @@
 		SST_CLKCTL_MASK | SST_CLKCTL_DCPLCG | SST_CLKCTL_SCOE0,
 		SST_CLKCTL_MASK | SST_CLKCTL_DCPLCG | SST_CLKCTL_SCOE0);
 
-	/* Stall and reset core, set CSR */
-	hsw_reset(sst);
-
-	/* Enable core clock gating (VDRTCTL2.DCLCGE = 1), delay 50 us */
-	reg = readl(sst->addr.pci_cfg + SST_VDRTCTL2);
-	reg |= SST_VDRTCL2_DCLCGE | SST_VDRTCL2_DTCGE;
-	writel(reg, sst->addr.pci_cfg + SST_VDRTCTL2);
-
-	udelay(50);
-
-	/* switch on audio PLL */
-	reg = readl(sst->addr.pci_cfg + SST_VDRTCTL2);
-	reg &= ~SST_VDRTCL2_APLLSE_MASK;
-	writel(reg, sst->addr.pci_cfg + SST_VDRTCTL2);
-
-	/* set default power gating control, enable power gating control for all blocks. that is,
-	can't be accessed, please enable each block before accessing. */
-	reg = readl(sst->addr.pci_cfg + SST_VDRTCTL0);
-	reg |= SST_VDRTCL0_DSRAMPGE_MASK | SST_VDRTCL0_ISRAMPGE_MASK;
-	/* for D0, always enable the block(DSRAM[0]) used for FW dump */
-	fw_dump_bit = 1 << SST_VDRTCL0_DSRAMPGE_SHIFT;
-	writel(reg & ~fw_dump_bit, sst->addr.pci_cfg + SST_VDRTCTL0);
-
-
 	/* disable DMA finish function for SSP0 & SSP1 */
 	sst_dsp_shim_update_bits_unlocked(sst, SST_CSR2, SST_CSR2_SDFD_SSP1,
 		SST_CSR2_SDFD_SSP1);
@@ -394,6 +353,9 @@
 	sst_dsp_shim_write(sst, 0x80, 0x6);
 	sst_dsp_shim_write(sst, 0xe0, 0x300a);
 
+	/* disable all clock gating */
+	writel(0x0, sst->addr.pci_cfg + SST_VDRTCTL2);
+
 	return 0;
 }
 
@@ -480,6 +442,13 @@
 
 	/* SST Shim */
 	sst->addr.shim = sst->addr.lpe + sst->addr.shim_offset;
+
+	sst_debugfs_init("intel_adsp");
+	sst_debugfs_add_mmio_entry("mem", sst->addr.lpe, pdata->lpe_size,
+				   &sst->debugfs_bar0);
+	sst_debugfs_add_mmio_entry("cfg", sst->addr.pci_cfg, pdata->pcicfg_size,
+				   &sst->debugfs_bar1);
+
 	return 0;
 }
 
@@ -493,7 +462,6 @@
 	{SST_DEV_ID_LYNX_POINT, 6, 16}, /* lp */
 	{SST_DEV_ID_WILDCAT_POINT, 2, 12}, /* wpt */
 };
-
 static u32 hsw_block_get_bit(struct sst_mem_block *block)
 {
 	u32 bit = 0, shift = 0, index;
@@ -546,11 +514,6 @@
 	dev_dbg(block->dsp->dev, " enabled block %d:%d at offset 0x%x\n",
 		block->type, block->index, block->offset);
 
-	/* Disable core clock gating (VDRTCTL2.DCLCGE = 0) */
-	val = readl(sst->addr.pci_cfg + SST_VDRTCTL2);
-	val &= ~SST_VDRTCL2_DCLCGE;
-	writel(val, sst->addr.pci_cfg + SST_VDRTCTL2);
-
 	val = readl(sst->addr.pci_cfg + SST_VDRTCTL0);
 	bit = hsw_block_get_bit(block);
 	writel(val & ~bit, sst->addr.pci_cfg + SST_VDRTCTL0);
@@ -558,13 +521,6 @@
 	/* wait 18 DSP clock ticks */
 	udelay(10);
 
-	/* Enable core clock gating (VDRTCTL2.DCLCGE = 1), delay 50 us */
-	val = readl(sst->addr.pci_cfg + SST_VDRTCTL2);
-	val |= SST_VDRTCL2_DCLCGE;
-	writel(val, sst->addr.pci_cfg + SST_VDRTCTL2);
-
-	udelay(50);
-
 	/*add a dummy read before the SRAM block is written, otherwise the writing may miss bytes sometimes.*/
 	sst_mem_block_dummy_read(block);
 	return 0;
@@ -582,27 +538,9 @@
 	dev_dbg(block->dsp->dev, " disabled block %d:%d at offset 0x%x\n",
 		block->type, block->index, block->offset);
 
-	/* Disable core clock gating (VDRTCTL2.DCLCGE = 0) */
-	val = readl(sst->addr.pci_cfg + SST_VDRTCTL2);
-	val &= ~SST_VDRTCL2_DCLCGE;
-	writel(val, sst->addr.pci_cfg + SST_VDRTCTL2);
-
-
 	val = readl(sst->addr.pci_cfg + SST_VDRTCTL0);
 	bit = hsw_block_get_bit(block);
-	/* don't disable DSRAM[0], keep it always enable for FW dump*/
-	if (bit != (1 << SST_VDRTCL0_DSRAMPGE_SHIFT))
-		writel(val | bit, sst->addr.pci_cfg + SST_VDRTCTL0);
-
-	/* wait 18 DSP clock ticks */
-	udelay(10);
-
-	/* Enable core clock gating (VDRTCTL2.DCLCGE = 1), delay 50 us */
-	val = readl(sst->addr.pci_cfg + SST_VDRTCTL2);
-	val |= SST_VDRTCL2_DCLCGE;
-	writel(val, sst->addr.pci_cfg + SST_VDRTCTL2);
-
-	udelay(50);
+	writel(val | bit, sst->addr.pci_cfg + SST_VDRTCTL0);
 
 	return 0;
 }
@@ -617,7 +555,7 @@
 	const struct sst_adsp_memregion *region;
 	struct device *dev;
 	int ret = -ENODEV, i, j, region_count;
-	u32 offset, size, fw_dump_bit;
+	u32 offset, size;
 
 	dev = sst->dma_dev;
 
@@ -674,17 +612,18 @@
 		}
 	}
 
-	/* always enable the block(DSRAM[0]) used for FW dump */
-	fw_dump_bit = 1 << SST_VDRTCL0_DSRAMPGE_SHIFT;
 	/* set default power gating control, enable power gating control for all blocks. that is,
 	can't be accessed, please enable each block before accessing. */
-	writel(0xffffffff & ~fw_dump_bit, sst->addr.pci_cfg + SST_VDRTCTL0);
+	writel(0xffffffff, sst->addr.pci_cfg + SST_VDRTCTL0);
 
 	return 0;
 }
 
 static void hsw_free(struct sst_dsp *sst)
 {
+	sst_debugfs_remove_mmio_entry(sst->debugfs_bar0);
+	sst_debugfs_remove_mmio_entry(sst->debugfs_bar1);
+	sst_debugfs_exit();
 	sst_mem_block_unregister_all(sst);
 	iounmap(sst->addr.lpe);
 	iounmap(sst->addr.pci_cfg);
diff -Nru a/sound/soc/intel/haswell/sst-haswell-ipc.c b/sound/soc/intel/haswell/sst-haswell-ipc.c
--- a/sound/soc/intel/haswell/sst-haswell-ipc.c	2015-08-16 23:52:51.000000000 -0400
+++ b/sound/soc/intel/haswell/sst-haswell-ipc.c	2015-08-22 16:54:09.948983000 -0400
@@ -31,12 +31,14 @@
 #include <linux/dma-mapping.h>
 #include <linux/debugfs.h>
 #include <linux/pm_runtime.h>
-#include <sound/asound.h>
+//#include <asm/page.h>
+//#include <asm/pgtable.h>
+#include <sound/memalloc.h>
+
 
 #include "sst-haswell-ipc.h"
 #include "../common/sst-dsp.h"
 #include "../common/sst-dsp-priv.h"
-#include "../common/sst-ipc.h"
 
 /* Global Message - Generic */
 #define IPC_GLB_TYPE_SHIFT	24
@@ -80,15 +82,6 @@
 #define IPC_LOG_ID_MASK		(0xf << IPC_LOG_ID_SHIFT)
 #define IPC_LOG_ID(x)		(x << IPC_LOG_ID_SHIFT)
 
-/* Module Message */
-#define IPC_MODULE_OPERATION_SHIFT	20
-#define IPC_MODULE_OPERATION_MASK	(0xf << IPC_MODULE_OPERATION_SHIFT)
-#define IPC_MODULE_OPERATION(x)	(x << IPC_MODULE_OPERATION_SHIFT)
-
-#define IPC_MODULE_ID_SHIFT	16
-#define IPC_MODULE_ID_MASK	(0xf << IPC_MODULE_ID_SHIFT)
-#define IPC_MODULE_ID(x)	(x << IPC_MODULE_ID_SHIFT)
-
 /* IPC message timeout (msecs) */
 #define IPC_TIMEOUT_MSECS	300
 #define IPC_BOOT_MSECS		200
@@ -125,7 +118,6 @@
 	IPC_GLB_ENTER_DX_STATE = 12,
 	IPC_GLB_GET_MIXER_STREAM_INFO = 13,	/* Request mixer stream params */
 	IPC_GLB_DEBUG_LOG_MESSAGE = 14,		/* Message to or from the debug logger. */
-	IPC_GLB_MODULE_OPERATION = 15,		/* Message to loadable fw module */
 	IPC_GLB_REQUEST_TRANSFER = 16, 		/* < Request Transfer for host */
 	IPC_GLB_MAX_IPC_MESSAGE_TYPE = 17,	/* Maximum message number */
 };
@@ -144,16 +136,6 @@
 	IPC_GLB_REPLY_SOURCE_NOT_STARTED = 10,	/* Source was not started. */
 };
 
-enum ipc_module_operation {
-	IPC_MODULE_NOTIFICATION = 0,
-	IPC_MODULE_ENABLE = 1,
-	IPC_MODULE_DISABLE = 2,
-	IPC_MODULE_GET_PARAMETER = 3,
-	IPC_MODULE_SET_PARAMETER = 4,
-	IPC_MODULE_GET_INFO = 5,
-	IPC_MODULE_MAX_MESSAGE
-};
-
 /* Stream Message - Types */
 enum ipc_str_operation {
 	IPC_STR_RESET = 0,
@@ -201,6 +183,13 @@
 	IPC_DEBUG_MAX_DEBUG_LOG
 };
 
+enum dx_state {
+	d0_state = 0,
+	idle_state = 1,
+	d3_state = 3,
+	unknown_state,
+};
+
 /* Firmware Ready */
 struct sst_hsw_ipc_fw_ready {
 	u32 inbox_offset;
@@ -211,6 +200,23 @@
 	u8 fw_info[IPC_MAX_MAILBOX_BYTES - 5 * sizeof(u32)];
 } __attribute__((packed));
 
+struct ipc_message {
+	struct list_head list;
+	u32 header;
+
+	/* direction wrt host CPU */
+	char tx_data[IPC_MAX_MAILBOX_BYTES];
+	size_t tx_size;
+	char rx_data[IPC_MAX_MAILBOX_BYTES];
+	size_t rx_size;
+
+	wait_queue_head_t waitq;
+	bool pending;
+	bool complete;
+	bool wait;
+	int errno;
+};
+
 struct sst_hsw_stream;
 struct sst_hsw;
 
@@ -247,9 +253,6 @@
 	u32 (*notify_position)(struct sst_hsw_stream *stream, void *data);
 	void *pdata;
 
-	/* record the fw read position when playback */
-	snd_pcm_uframes_t old_position;
-	bool play_silence;
 	struct list_head node;
 };
 
@@ -285,6 +288,7 @@
 	/* FW config */
 	struct sst_hsw_ipc_fw_ready fw_ready;
 	struct sst_hsw_ipc_fw_version version;
+	struct sst_module *scratch;
 	bool fw_done;
 	struct sst_fw *sst_fw;
 
@@ -302,6 +306,12 @@
 	struct sst_hsw_ipc_dx_reply dx;
 	void *dx_context;
 	dma_addr_t dx_context_paddr;
+	int dx_state;
+	int cnt_state_idle;
+	int cnt_state_d0;
+	int cnt_state_d3;
+	int cnt_state_s0;
+	int cnt_state_s3;
 
 	/* boot */
 	wait_queue_head_t boot_wait;
@@ -309,19 +319,18 @@
 	bool shutdown;
 
 	/* IPC messaging */
-	struct sst_generic_ipc ipc;
+	struct list_head tx_list;
+	struct list_head rx_list;
+	struct list_head empty_list;
+	wait_queue_head_t wait_txq;
+	struct task_struct *tx_thread;
+	struct kthread_worker kworker;
+	struct kthread_work kwork;
+	bool pending;
+	struct ipc_message *msg;
 
 	/* FW log stream */
 	struct sst_hsw_log_stream log_stream;
-
-	/* flags bit field to track module state when resume from RTD3,
-	 * each bit represent state (enabled/disabled) of single module */
-	u32 enabled_modules_rtd3;
-
-	/* buffer to store parameter lines */
-	u32 param_idx_w;	/* write index */
-	u32 param_idx_r;	/* read index */
-	u8 param_buf[WAVES_PARAM_LINES][WAVES_PARAM_COUNT];
 };
 
 #define CREATE_TRACE_POINTS
@@ -347,6 +356,12 @@
 	return (msg & IPC_STG_TYPE_MASK) >>  IPC_STG_TYPE_SHIFT;
 }
 
+static inline u32 msg_set_stage_type(u32 msg, u32 type)
+{
+	return (msg & ~IPC_STG_TYPE_MASK) +
+		(type << IPC_STG_TYPE_SHIFT);
+}
+
 static inline u32 msg_get_stream_id(u32 msg)
 {
 	return (msg & IPC_STR_ID_MASK) >>  IPC_STR_ID_SHIFT;
@@ -357,16 +372,6 @@
 	return (msg & IPC_STG_TYPE_MASK) >> IPC_STG_TYPE_SHIFT;
 }
 
-static inline u32 msg_get_module_operation(u32 msg)
-{
-	return (msg & IPC_MODULE_OPERATION_MASK) >> IPC_MODULE_OPERATION_SHIFT;
-}
-
-static inline u32 msg_get_module_id(u32 msg)
-{
-	return (msg & IPC_MODULE_ID_MASK) >> IPC_MODULE_ID_SHIFT;
-}
-
 u32 create_channel_map(enum sst_hsw_channel_config config)
 {
 	switch (config) {
@@ -432,6 +437,166 @@
 	return NULL;
 }
 
+static void ipc_shim_dbg(struct sst_hsw *hsw, const char *text)
+{
+	struct sst_dsp *sst = hsw->dsp;
+	u32 isr, ipcd, imrx, ipcx;
+
+	ipcx = sst_dsp_shim_read_unlocked(sst, SST_IPCX);
+	isr = sst_dsp_shim_read_unlocked(sst, SST_ISRX);
+	ipcd = sst_dsp_shim_read_unlocked(sst, SST_IPCD);
+	imrx = sst_dsp_shim_read_unlocked(sst, SST_IMRX);
+
+	dev_err(hsw->dev, "ipc: --%s-- ipcx 0x%8.8x isr 0x%8.8x ipcd 0x%8.8x imrx 0x%8.8x\n",
+		text, ipcx, isr, ipcd, imrx);
+}
+
+/* locks held by caller */
+static struct ipc_message *msg_get_empty(struct sst_hsw *hsw)
+{
+	struct ipc_message *msg = NULL;
+
+	if (!list_empty(&hsw->empty_list)) {
+		msg = list_first_entry(&hsw->empty_list, struct ipc_message,
+			list);
+		list_del(&msg->list);
+	}
+
+	return msg;
+}
+
+static void ipc_tx_msgs(struct kthread_work *work)
+{
+	struct sst_hsw *hsw =
+		container_of(work, struct sst_hsw, kwork);
+	struct ipc_message *msg;
+	unsigned long flags;
+	u32 ipcx;
+
+	/* This delay is to avoid message timeout error during repeated arecord.
+	 * Binary search on the delay value shows that timeouts start to happen
+	 * when delay is at ~70us. At 100us delay, tested 500 arecord without
+	 * timeout error.
+	 */
+	udelay(100);
+
+	spin_lock_irqsave(&hsw->dsp->spinlock, flags);
+
+	if (list_empty(&hsw->tx_list) || hsw->pending) {
+		spin_unlock_irqrestore(&hsw->dsp->spinlock, flags);
+		return;
+	}
+
+	/* if the DSP is busy, we will TX messages after IRQ.
+	 * also postpone if we are in the middle of procesing completion irq*/
+	ipcx = sst_dsp_shim_read_unlocked(hsw->dsp, SST_IPCX);
+	if (ipcx & (SST_IPCX_BUSY | SST_IPCX_DONE)) {
+		spin_unlock_irqrestore(&hsw->dsp->spinlock, flags);
+		return;
+	}
+
+	msg = list_first_entry(&hsw->tx_list, struct ipc_message, list);
+
+	list_move(&msg->list, &hsw->rx_list);
+
+	/* send the message */
+	sst_dsp_outbox_write(hsw->dsp, msg->tx_data, msg->tx_size);
+	sst_dsp_ipc_msg_tx(hsw->dsp, msg->header | SST_IPCX_BUSY);
+
+	spin_unlock_irqrestore(&hsw->dsp->spinlock, flags);
+}
+
+/* locks held by caller */
+static void tx_msg_reply_complete(struct sst_hsw *hsw, struct ipc_message *msg)
+{
+	msg->complete = true;
+	trace_ipc_reply("completed", msg->header);
+
+	if (!msg->wait)
+		list_add_tail(&msg->list, &hsw->empty_list);
+	else
+		wake_up(&msg->waitq);
+}
+
+static int tx_wait_done(struct sst_hsw *hsw, struct ipc_message *msg,
+	void *rx_data)
+{
+	unsigned long flags;
+	int ret;
+
+	/* wait for DSP completion (in all cases atm inc pending) */
+	ret = wait_event_timeout(msg->waitq, msg->complete,
+		msecs_to_jiffies(IPC_TIMEOUT_MSECS));
+
+	spin_lock_irqsave(&hsw->dsp->spinlock, flags);
+	if (ret == 0) {
+		ipc_shim_dbg(hsw, "message timeout");
+
+		trace_ipc_error("error message timeout for", msg->header);
+		list_del(&msg->list);
+		ret = -ETIMEDOUT;
+	} else {
+
+		/* copy the data returned from DSP */
+		if (msg->rx_size)
+			memcpy(rx_data, msg->rx_data, msg->rx_size);
+		ret = msg->errno;
+	}
+
+	list_add_tail(&msg->list, &hsw->empty_list);
+	spin_unlock_irqrestore(&hsw->dsp->spinlock, flags);
+	return ret;
+}
+
+static int ipc_tx_message(struct sst_hsw *hsw, u32 header, void *tx_data,
+	size_t tx_bytes, void *rx_data, size_t rx_bytes, int wait)
+{
+	struct ipc_message *msg;
+	unsigned long flags;
+
+	spin_lock_irqsave(&hsw->dsp->spinlock, flags);
+
+	msg = msg_get_empty(hsw);
+	if (msg == NULL) {
+		spin_unlock_irqrestore(&hsw->dsp->spinlock, flags);
+		return -EBUSY;
+	}
+
+	if (tx_bytes)
+		memcpy(msg->tx_data, tx_data, tx_bytes);
+
+	msg->header = header;
+	msg->tx_size = tx_bytes;
+	msg->rx_size = rx_bytes;
+	msg->wait = wait;
+	msg->errno = 0;
+	msg->pending = false;
+	msg->complete = false;
+
+	list_add_tail(&msg->list, &hsw->tx_list);
+	spin_unlock_irqrestore(&hsw->dsp->spinlock, flags);
+
+	queue_kthread_work(&hsw->kworker, &hsw->kwork);
+
+	if (wait)
+		return tx_wait_done(hsw, msg, rx_data);
+	else
+		return 0;
+}
+
+static inline int ipc_tx_message_wait(struct sst_hsw *hsw, u32 header,
+	void *tx_data, size_t tx_bytes, void *rx_data, size_t rx_bytes)
+{
+	return ipc_tx_message(hsw, header, tx_data, tx_bytes, rx_data,
+		rx_bytes, 1);
+}
+
+static inline int ipc_tx_message_nowait(struct sst_hsw *hsw, u32 header,
+	void *tx_data, size_t tx_bytes)
+{
+	return ipc_tx_message(hsw, header, tx_data, tx_bytes, NULL, 0, 0);
+}
+
 static void hsw_fw_ready(struct sst_hsw *hsw, u32 header)
 {
 	struct sst_hsw_ipc_fw_ready fw_ready;
@@ -466,7 +631,7 @@
 		/* log the FW version info got from the mailbox here. */
 		memcpy(fw_info, fw_ready.fw_info, fw_ready.fw_info_size);
 		pinfo = &fw_info[0];
-		for (i = 0; i < ARRAY_SIZE(tmp); i++)
+		for (i = 0; i < sizeof(tmp) / sizeof(char *); i++)
 			tmp[i] = strsep(&pinfo, " ");
 		dev_info(hsw->dev, "FW loaded, mailbox readback FW info: type %s, - "
 			"version: %s.%s, build %s, source commit id: %s\n",
@@ -519,6 +684,47 @@
 	sst_dsp_shim_update_bits(hsw->dsp, SST_IMRX, SST_IMRX_BUSY, 0);
 }
 
+static void hsw_log_notification_work(struct work_struct *work)
+{
+	struct sst_hsw_log_stream *stream = container_of(work,
+	struct sst_hsw_log_stream, notify_work);
+	struct sst_hsw *hsw = stream->hsw;
+	u32 header;
+	int ret;
+
+	header = IPC_GLB_TYPE(IPC_GLB_DEBUG_LOG_MESSAGE);
+	header |= IPC_LOG_OP_TYPE(IPC_DEBUG_NOTIFY_LOG_DUMP);
+	header |= IPC_LOG_ID(SST_HSW_GLOBAL_LOG);
+	ret = ipc_tx_message_nowait(hsw, header,
+		&stream->curr_pos, sizeof(stream->curr_pos));
+	if (ret < 0)
+		dev_err(hsw->dev,
+			"ipc: send ipc to notify fw log position failed\n");
+
+	wake_up_interruptible(&stream->readers_wait_q);
+}
+
+static struct ipc_message *reply_find_msg(struct sst_hsw *hsw, u32 header)
+{
+	struct ipc_message *msg;
+
+	/* clear reply bits & status bits */
+	header &= ~(IPC_STATUS_MASK | IPC_GLB_REPLY_MASK);
+
+	if (list_empty(&hsw->rx_list)) {
+		dev_err(hsw->dev, "error: rx list empty but received 0x%x\n",
+			header);
+		return NULL;
+	}
+
+	list_for_each_entry(msg, &hsw->rx_list, list) {
+		if (msg->header == header)
+			return msg;
+	}
+
+	return NULL;
+}
+
 static void hsw_stream_update(struct sst_hsw *hsw, struct ipc_message *msg)
 {
 	struct sst_hsw_stream *stream;
@@ -557,7 +763,7 @@
 
 	trace_ipc_reply("processing -->", header);
 
-	msg = sst_ipc_reply_find_msg(&hsw->ipc, header);
+	msg = reply_find_msg(hsw, header);
 	if (msg == NULL) {
 		trace_ipc_error("error: can't find message header", header);
 		return -EIO;
@@ -568,14 +774,14 @@
 	case IPC_GLB_REPLY_PENDING:
 		trace_ipc_pending_reply("received", header);
 		msg->pending = true;
-		hsw->ipc.pending = true;
+		hsw->pending = true;
 		return 1;
 	case IPC_GLB_REPLY_SUCCESS:
 		if (msg->pending) {
 			trace_ipc_pending_reply("completed", header);
 			sst_dsp_inbox_read(hsw->dsp, msg->rx_data,
 				msg->rx_size);
-			hsw->ipc.pending = false;
+			hsw->pending = false;
 		} else {
 			/* copy data from the DSP */
 			sst_dsp_outbox_read(hsw->dsp, msg->rx_data,
@@ -631,36 +837,11 @@
 
 	/* wake up and return the error if we have waiters on this message ? */
 	list_del(&msg->list);
-	sst_ipc_tx_msg_reply_complete(&hsw->ipc, msg);
+	tx_msg_reply_complete(hsw, msg);
 
 	return 1;
 }
 
-static int hsw_module_message(struct sst_hsw *hsw, u32 header)
-{
-	u32 operation, module_id;
-	int handled = 0;
-
-	operation = msg_get_module_operation(header);
-	module_id = msg_get_module_id(header);
-	dev_dbg(hsw->dev, "received module message header: 0x%8.8x\n",
-			header);
-	dev_dbg(hsw->dev, "operation: 0x%8.8x module_id: 0x%8.8x\n",
-			operation, module_id);
-
-	switch (operation) {
-	case IPC_MODULE_NOTIFICATION:
-		dev_dbg(hsw->dev, "module notification received");
-		handled = 1;
-		break;
-	default:
-		handled = hsw_process_reply(hsw, header);
-		break;
-	}
-
-	return handled;
-}
-
 static int hsw_stream_message(struct sst_hsw *hsw, u32 header)
 {
 	u32 stream_msg, stream_id, stage_type;
@@ -756,9 +937,6 @@
 	case IPC_GLB_DEBUG_LOG_MESSAGE:
 		handled = hsw_log_message(hsw, header);
 		break;
-	case IPC_GLB_MODULE_OPERATION:
-		handled = hsw_module_message(hsw, header);
-		break;
 	default:
 		dev_err(hsw->dev, "error: unexpected type %d hdr 0x%8.8x\n",
 			type, header);
@@ -772,7 +950,6 @@
 {
 	struct sst_dsp *sst = (struct sst_dsp *) context;
 	struct sst_hsw *hsw = sst_dsp_get_thread_context(sst);
-	struct sst_generic_ipc *ipc = &hsw->ipc;
 	u32 ipcx, ipcd;
 	int handled;
 	unsigned long flags;
@@ -819,7 +996,7 @@
 	spin_unlock_irqrestore(&sst->spinlock, flags);
 
 	/* continue to send any remaining messages... */
-	queue_kthread_work(&ipc->kworker, &ipc->kwork);
+	queue_kthread_work(&hsw->kworker, &hsw->kwork);
 
 	return IRQ_HANDLED;
 }
@@ -829,8 +1006,7 @@
 {
 	int ret;
 
-	ret = sst_ipc_tx_message_wait(&hsw->ipc,
-		IPC_GLB_TYPE(IPC_GLB_GET_FW_VERSION),
+	ret = ipc_tx_message_wait(hsw, IPC_GLB_TYPE(IPC_GLB_GET_FW_VERSION),
 		NULL, 0, version, sizeof(*version));
 	if (ret < 0)
 		dev_err(hsw->dev, "error: get version failed\n");
@@ -839,6 +1015,45 @@
 }
 
 /* Mixer Controls */
+int sst_hsw_stream_mute(struct sst_hsw *hsw, struct sst_hsw_stream *stream,
+	u32 stage_id, u32 channel)
+{
+	int ret;
+
+	ret = sst_hsw_stream_get_volume(hsw, stream, stage_id, channel,
+		&stream->mute_volume[channel]);
+	if (ret < 0)
+		return ret;
+
+	ret = sst_hsw_stream_set_volume(hsw, stream, stage_id, channel, 0);
+	if (ret < 0) {
+		dev_err(hsw->dev, "error: can't unmute stream %d channel %d\n",
+			stream->reply.stream_hw_id, channel);
+		return ret;
+	}
+
+	stream->mute[channel] = 1;
+	return 0;
+}
+
+int sst_hsw_stream_unmute(struct sst_hsw *hsw, struct sst_hsw_stream *stream,
+	u32 stage_id, u32 channel)
+
+{
+	int ret;
+
+	stream->mute[channel] = 0;
+	ret = sst_hsw_stream_set_volume(hsw, stream, stage_id, channel,
+		stream->mute_volume[channel]);
+	if (ret < 0) {
+		dev_err(hsw->dev, "error: can't unmute stream %d channel %d\n",
+			stream->reply.stream_hw_id, channel);
+		return ret;
+	}
+
+	return 0;
+}
+
 int sst_hsw_stream_get_volume(struct sst_hsw *hsw, struct sst_hsw_stream *stream,
 	u32 stage_id, u32 channel, u32 *volume)
 {
@@ -852,6 +1067,17 @@
 	return 0;
 }
 
+int sst_hsw_stream_set_volume_curve(struct sst_hsw *hsw,
+	struct sst_hsw_stream *stream, u64 curve_duration,
+	enum sst_hsw_volume_curve curve)
+{
+	/* curve duration in steps of 100ns */
+	stream->vol_req.curve_duration = curve_duration;
+	stream->vol_req.curve_type = curve;
+
+	return 0;
+}
+
 /* stream volume */
 int sst_hsw_stream_set_volume(struct sst_hsw *hsw,
 	struct sst_hsw_stream *stream, u32 stage_id, u32 channel, u32 volume)
@@ -862,9 +1088,14 @@
 
 	trace_ipc_request("set stream volume", stream->reply.stream_hw_id);
 
-	if (channel >= 2 && channel != SST_HSW_CHANNELS_ALL)
+	if (channel > 1)
 		return -EINVAL;
 
+	if (stream->mute[channel]) {
+		stream->mute_volume[channel] = volume;
+		return 0;
+	}
+
 	header = IPC_GLB_TYPE(IPC_GLB_STREAM_MESSAGE) |
 		IPC_STR_TYPE(IPC_STR_STAGE_MESSAGE);
 	header |= (stream->reply.stream_hw_id << IPC_STR_ID_SHIFT);
@@ -872,35 +1103,51 @@
 	header |= (stage_id << IPC_STG_ID_SHIFT);
 
 	req = &stream->vol_req;
+	req->channel = channel;
 	req->target_volume = volume;
 
-	/* set both at same time ? */
-	if (channel == SST_HSW_CHANNELS_ALL) {
-		if (hsw->mute[0] && hsw->mute[1]) {
-			hsw->mute_volume[0] = hsw->mute_volume[1] = volume;
-			return 0;
-		} else if (hsw->mute[0])
-			req->channel = 1;
-		else if (hsw->mute[1])
-			req->channel = 0;
-		else
-			req->channel = SST_HSW_CHANNELS_ALL;
-	} else {
-		/* set only 1 channel */
-		if (hsw->mute[channel]) {
-			hsw->mute_volume[channel] = volume;
-			return 0;
-		}
-		req->channel = channel;
+	ret = ipc_tx_message_wait(hsw, header, req, sizeof(*req), NULL, 0);
+	if (ret < 0) {
+		dev_err(hsw->dev, "error: set stream volume failed\n");
+		return ret;
+	}
+
+	return 0;
+}
+
+int sst_hsw_mixer_mute(struct sst_hsw *hsw, u32 stage_id, u32 channel)
+{
+	int ret;
+
+	ret = sst_hsw_mixer_get_volume(hsw, stage_id, channel,
+		&hsw->mute_volume[channel]);
+	if (ret < 0)
+		return ret;
+
+	ret = sst_hsw_mixer_set_volume(hsw, stage_id, channel, 0);
+	if (ret < 0) {
+		dev_err(hsw->dev, "error: failed to unmute mixer channel %d\n",
+			channel);
+		return ret;
 	}
 
-	ret = sst_ipc_tx_message_wait(&hsw->ipc, header, req,
-		sizeof(*req), NULL, 0);
+	hsw->mute[channel] = 1;
+	return 0;
+}
+
+int sst_hsw_mixer_unmute(struct sst_hsw *hsw, u32 stage_id, u32 channel)
+{
+	int ret;
+
+	ret = sst_hsw_mixer_set_volume(hsw, stage_id, channel,
+		hsw->mixer_info.volume_register_address[channel]);
 	if (ret < 0) {
-		dev_err(hsw->dev, "error: set stream volume failed\n");
+		dev_err(hsw->dev, "error: failed to unmute mixer channel %d\n",
+			channel);
 		return ret;
 	}
 
+	hsw->mute[channel] = 0;
 	return 0;
 }
 
@@ -917,6 +1164,16 @@
 	return 0;
 }
 
+int sst_hsw_mixer_set_volume_curve(struct sst_hsw *hsw,
+	 u64 curve_duration, enum sst_hsw_volume_curve curve)
+{
+	/* curve duration in steps of 100ns */
+	hsw->curve_duration = curve_duration;
+	hsw->curve_type = curve;
+
+	return 0;
+}
+
 /* global mixer volume */
 int sst_hsw_mixer_set_volume(struct sst_hsw *hsw, u32 stage_id, u32 channel,
 	u32 volume)
@@ -927,11 +1184,8 @@
 
 	trace_ipc_request("set mixer volume", volume);
 
-	if (channel >= 2 && channel != SST_HSW_CHANNELS_ALL)
-		return -EINVAL;
-
 	/* set both at same time ? */
-	if (channel == SST_HSW_CHANNELS_ALL) {
+	if (channel == 2) {
 		if (hsw->mute[0] && hsw->mute[1]) {
 			hsw->mute_volume[0] = hsw->mute_volume[1] = volume;
 			return 0;
@@ -940,7 +1194,7 @@
 		else if (hsw->mute[1])
 			req.channel = 0;
 		else
-			req.channel = SST_HSW_CHANNELS_ALL;
+			req.channel = 0xffffffff;
 	} else {
 		/* set only 1 channel */
 		if (hsw->mute[channel]) {
@@ -960,8 +1214,7 @@
 	req.curve_type = hsw->curve_type;
 	req.target_volume = volume;
 
-	ret = sst_ipc_tx_message_wait(&hsw->ipc, header, &req,
-		sizeof(req), NULL, 0);
+	ret = ipc_tx_message_wait(hsw, header, &req, sizeof(req), NULL, 0);
 	if (ret < 0) {
 		dev_err(hsw->dev, "error: set mixer volume failed\n");
 		return ret;
@@ -1005,11 +1258,6 @@
 	struct sst_dsp *sst = hsw->dsp;
 	unsigned long flags;
 
-	if (!stream) {
-		dev_warn(hsw->dev, "warning: stream is NULL, no stream to free, ignore it.\n");
-		return 0;
-	}
-
 	/* dont free DSP streams that are not commited */
 	if (!stream->commited)
 		goto out;
@@ -1019,7 +1267,7 @@
 	stream->free_req.stream_id = stream->reply.stream_hw_id;
 	header = IPC_GLB_TYPE(IPC_GLB_FREE_STREAM);
 
-	ret = sst_ipc_tx_message_wait(&hsw->ipc, header, &stream->free_req,
+	ret = ipc_tx_message_wait(hsw, header, &stream->free_req,
 		sizeof(stream->free_req), NULL, 0);
 	if (ret < 0) {
 		dev_err(hsw->dev, "error: free stream %d failed\n",
@@ -1197,22 +1445,12 @@
 	u32 header;
 	int ret;
 
-	if (!stream) {
-		dev_warn(hsw->dev, "warning: stream is NULL, no stream to commit, ignore it.\n");
-		return 0;
-	}
-
-	if (stream->commited) {
-		dev_warn(hsw->dev, "warning: stream is already committed, ignore it.\n");
-		return 0;
-	}
-
 	trace_ipc_request("stream alloc", stream->host_id);
 
 	header = IPC_GLB_TYPE(IPC_GLB_ALLOCATE_STREAM);
 
-	ret = sst_ipc_tx_message_wait(&hsw->ipc, header, str_req,
-		sizeof(*str_req), reply, sizeof(*reply));
+	ret = ipc_tx_message_wait(hsw, header, str_req, sizeof(*str_req),
+		reply, sizeof(*reply));
 	if (ret < 0) {
 		dev_err(hsw->dev, "error: stream commit failed\n");
 		return ret;
@@ -1224,32 +1462,50 @@
 	return 0;
 }
 
-snd_pcm_uframes_t sst_hsw_stream_get_old_position(struct sst_hsw *hsw,
+/* Stream Information - these calls could be inline but we want the IPC
+ ABI to be opaque to client PCM drivers to cope with any future ABI changes */
+int sst_hsw_stream_get_hw_id(struct sst_hsw *hsw,
 	struct sst_hsw_stream *stream)
 {
-	return stream->old_position;
+	return stream->reply.stream_hw_id;
 }
 
-void sst_hsw_stream_set_old_position(struct sst_hsw *hsw,
-	struct sst_hsw_stream *stream, snd_pcm_uframes_t val)
+int sst_hsw_stream_get_mixer_id(struct sst_hsw *hsw,
+	struct sst_hsw_stream *stream)
 {
-	stream->old_position = val;
+	return stream->reply.mixer_hw_id;
 }
 
-bool sst_hsw_stream_get_silence_start(struct sst_hsw *hsw,
+u32 sst_hsw_stream_get_read_reg(struct sst_hsw *hsw,
 	struct sst_hsw_stream *stream)
 {
-	return stream->play_silence;
+	return stream->reply.read_position_register_address;
 }
 
-void sst_hsw_stream_set_silence_start(struct sst_hsw *hsw,
-	struct sst_hsw_stream *stream, bool val)
+u32 sst_hsw_stream_get_pointer_reg(struct sst_hsw *hsw,
+	struct sst_hsw_stream *stream)
 {
-	stream->play_silence = val;
+	return stream->reply.presentation_position_register_address;
+}
+
+u32 sst_hsw_stream_get_peak_reg(struct sst_hsw *hsw,
+	struct sst_hsw_stream *stream, u32 channel)
+{
+	if (channel >= 2)
+		return 0;
+
+	return stream->reply.peak_meter_register_address[channel];
+}
+
+u32 sst_hsw_stream_get_vol_reg(struct sst_hsw *hsw,
+	struct sst_hsw_stream *stream, u32 channel)
+{
+	if (channel >= 2)
+		return 0;
+
+	return stream->reply.volume_register_address[channel];
 }
 
-/* Stream Information - these calls could be inline but we want the IPC
- ABI to be opaque to client PCM drivers to cope with any future ABI changes */
 int sst_hsw_mixer_get_info(struct sst_hsw *hsw)
 {
 	struct sst_hsw_ipc_stream_info_reply *reply;
@@ -1261,8 +1517,7 @@
 
 	trace_ipc_request("get global mixer info", 0);
 
-	ret = sst_ipc_tx_message_wait(&hsw->ipc, header, NULL, 0,
-		reply, sizeof(*reply));
+	ret = ipc_tx_message_wait(hsw, header, NULL, 0, reply, sizeof(*reply));
 	if (ret < 0) {
 		dev_err(hsw->dev, "error: get stream info failed\n");
 		return ret;
@@ -1283,10 +1538,9 @@
 	header |= (stream_id << IPC_STR_ID_SHIFT);
 
 	if (wait)
-		return sst_ipc_tx_message_wait(&hsw->ipc, header,
-			NULL, 0, NULL, 0);
+		return ipc_tx_message_wait(hsw, header, NULL, 0, NULL, 0);
 	else
-		return sst_ipc_tx_message_nowait(&hsw->ipc, header, NULL, 0);
+		return ipc_tx_message_nowait(hsw, header, NULL, 0);
 }
 
 /* Stream ALSA trigger operations */
@@ -1295,11 +1549,6 @@
 {
 	int ret;
 
-	if (!stream) {
-		dev_warn(hsw->dev, "warning: stream is NULL, no stream to pause, ignore it.\n");
-		return 0;
-	}
-
 	trace_ipc_request("stream pause", stream->reply.stream_hw_id);
 
 	ret = sst_hsw_stream_operations(hsw, IPC_STR_PAUSE,
@@ -1316,11 +1565,6 @@
 {
 	int ret;
 
-	if (!stream) {
-		dev_warn(hsw->dev, "warning: stream is NULL, no stream to resume, ignore it.\n");
-		return 0;
-	}
-
 	trace_ipc_request("stream resume", stream->reply.stream_hw_id);
 
 	ret = sst_hsw_stream_operations(hsw, IPC_STR_RESUME,
@@ -1336,11 +1580,6 @@
 {
 	int ret, tries = 10;
 
-	if (!stream) {
-		dev_warn(hsw->dev, "warning: stream is NULL, no stream to reset, ignore it.\n");
-		return 0;
-	}
-
 	/* dont reset streams that are not commited */
 	if (!stream->commited)
 		return 0;
@@ -1389,12 +1628,36 @@
 	return ppos;
 }
 
-/* physical BE config */
-int sst_hsw_device_set_config(struct sst_hsw *hsw,
-	enum sst_hsw_device_id dev, enum sst_hsw_device_mclk mclk,
-	enum sst_hsw_device_mode mode, u32 clock_divider)
+int sst_hsw_stream_set_write_position(struct sst_hsw *hsw,
+	struct sst_hsw_stream *stream, u32 stage_id, u32 position)
 {
-	struct sst_hsw_ipc_device_config_req config;
+	u32 header;
+	int ret;
+
+	trace_stream_write_position(stream->reply.stream_hw_id, position);
+
+	header = IPC_GLB_TYPE(IPC_GLB_STREAM_MESSAGE) |
+		IPC_STR_TYPE(IPC_STR_STAGE_MESSAGE);
+	header |= (stream->reply.stream_hw_id << IPC_STR_ID_SHIFT);
+	header |= (IPC_STG_SET_WRITE_POSITION << IPC_STG_TYPE_SHIFT);
+	header |= (stage_id << IPC_STG_ID_SHIFT);
+	stream->wpos.position = position;
+
+	ret = ipc_tx_message_nowait(hsw, header, &stream->wpos,
+		sizeof(stream->wpos));
+	if (ret < 0)
+		dev_err(hsw->dev, "error: stream %d set position %d failed\n",
+			stream->reply.stream_hw_id, position);
+
+	return ret;
+}
+
+/* physical BE config */
+int sst_hsw_device_set_config(struct sst_hsw *hsw,
+	enum sst_hsw_device_id dev, enum sst_hsw_device_mclk mclk,
+	enum sst_hsw_device_mode mode, u32 clock_divider)
+{
+	struct sst_hsw_ipc_device_config_req config;
 	u32 header;
 	int ret;
 
@@ -1413,8 +1676,8 @@
 
 	header = IPC_GLB_TYPE(IPC_GLB_SET_DEVICE_FORMATS);
 
-	ret = sst_ipc_tx_message_wait(&hsw->ipc, header, &config,
-		sizeof(config), NULL, 0);
+	ret = ipc_tx_message_wait(hsw, header, &config, sizeof(config),
+		NULL, 0);
 	if (ret < 0)
 		dev_err(hsw->dev, "error: set device formats failed\n");
 
@@ -1434,8 +1697,8 @@
 
 	trace_ipc_request("PM enter Dx state", state);
 
-	ret = sst_ipc_tx_message_wait(&hsw->ipc, header, &state_,
-		sizeof(state_), dx, sizeof(*dx));
+	ret = ipc_tx_message_wait(hsw, header, &state_, sizeof(state_),
+		dx, sizeof(*dx));
 	if (ret < 0) {
 		dev_err(hsw->dev, "ipc: error set dx state %d failed\n", state);
 		return ret;
@@ -1495,7 +1758,6 @@
 	sst_module_runtime_free(runtime);
 }
 
-#ifdef CONFIG_PM
 static int sst_hsw_dx_state_dump(struct sst_hsw *hsw)
 {
 	struct sst_dsp *sst = hsw->dsp;
@@ -1508,7 +1770,7 @@
 		dev_err(hsw->dev,
 			"error: number of FW context regions greater than %d\n",
 			SST_HSW_MAX_DX_REGIONS);
-		memset(&hsw->dx, 0, sizeof(hsw->dx));
+		memset(&hsw->dx, sizeof(hsw->dx), 0);
 		return -EINVAL;
 	}
 
@@ -1538,7 +1800,7 @@
 			if (ret < 0) {
 				dev_err(hsw->dev,
 					"error: FW context dump failed\n");
-				memset(&hsw->dx, 0, sizeof(hsw->dx));
+				memset(&hsw->dx, sizeof(hsw->dx), 0);
 				goto out;
 			}
 		}
@@ -1578,531 +1840,562 @@
 	return 0;
 }
 
-int sst_hsw_dsp_load(struct sst_hsw *hsw)
+static int fw_log_open_data(struct inode *inode, struct file *file)
 {
-	struct sst_dsp *dsp = hsw->dsp;
-	struct sst_fw *sst_fw, *t;
+	struct sst_hsw_log_stream *log_stream = inode->i_private;
+	struct sst_hsw_ipc_debug_log_enable_req req;
+	u32 header;
 	int ret;
 
-	dev_dbg(hsw->dev, "loading audio DSP....");
+	pm_runtime_get(log_stream->hsw->dev);
+	file->private_data = inode->i_private;
 
-	ret = sst_dsp_wake(dsp);
-	if (ret < 0) {
-		dev_err(hsw->dev, "error: failed to wake audio DSP\n");
-		return -ENODEV;
-	}
+	req.ringinfo.ring_pt_address = virt_to_phys(log_stream->ring_descr);
+	req.ringinfo.num_pages = log_stream->pages;
+	req.ringinfo.ring_size = log_stream->size;
+	req.ringinfo.ring_offset = 0;
+	req.ringinfo.ring_first_pfn = virt_to_phys(log_stream->dma_area);
+	memcpy(req.config, log_stream->config, sizeof(log_stream->config));
+
+	header = IPC_GLB_TYPE(IPC_GLB_DEBUG_LOG_MESSAGE);
+	header |= IPC_LOG_OP_TYPE(IPC_DEBUG_ENABLE_LOG);
+	header |= IPC_LOG_ID(SST_HSW_GLOBAL_LOG);
 
-	ret = sst_dsp_dma_get_channel(dsp, 0);
+	dev_info(log_stream->hsw->dev, "send ipc to enable fw log\n");
+
+	ret = ipc_tx_message_wait(log_stream->hsw, header, &req, sizeof(req), NULL, 0);
 	if (ret < 0) {
-		dev_err(hsw->dev, "error: cant allocate dma channel %d\n", ret);
+		dev_err(log_stream->hsw->dev, "ipc: enable fw log failed\n");
 		return ret;
 	}
 
-	list_for_each_entry_safe_reverse(sst_fw, t, &dsp->fw_list, list) {
-		ret = sst_fw_reload(sst_fw);
-		if (ret < 0) {
-			dev_err(hsw->dev, "error: SST FW reload failed\n");
-			sst_dsp_dma_put_channel(dsp);
-			return -ENOMEM;
-		}
-	}
-	ret = sst_block_alloc_scratch(hsw->dsp);
-	if (ret < 0)
-		return -EINVAL;
-
-	sst_dsp_dma_put_channel(dsp);
 	return 0;
 }
 
-static int sst_hsw_dsp_restore(struct sst_hsw *hsw)
+static int fw_log_release(struct inode *inode, struct file *file)
 {
-	struct sst_dsp *dsp = hsw->dsp;
+	struct sst_hsw_log_stream *log_stream = inode->i_private;
+	u32 header;
 	int ret;
 
-	dev_dbg(hsw->dev, "restoring audio DSP....");
+	header = IPC_GLB_TYPE(IPC_GLB_DEBUG_LOG_MESSAGE);
+	header |= IPC_LOG_OP_TYPE(IPC_DEBUG_DISABLE_LOG);
+	header |= IPC_LOG_ID(SST_HSW_GLOBAL_LOG);
 
-	ret = sst_dsp_dma_get_channel(dsp, 0);
-	if (ret < 0) {
-		dev_err(hsw->dev, "error: cant allocate dma channel %d\n", ret);
-		return ret;
-	}
+	dev_info(log_stream->hsw->dev, "send ipc to disable fw log\n");
 
-	ret = sst_hsw_dx_state_restore(hsw);
+	ret = ipc_tx_message_nowait(log_stream->hsw, header, NULL, 0);
 	if (ret < 0) {
-		dev_err(hsw->dev, "error: SST FW context restore failed\n");
-		sst_dsp_dma_put_channel(dsp);
-		return -ENOMEM;
+		dev_err(log_stream->hsw->dev,
+			"ipc: disable fw log failed, returned %d\n", ret);
+		return ret;
 	}
-	sst_dsp_dma_put_channel(dsp);
-
-	/* wait for DSP boot completion */
-	sst_dsp_boot(dsp);
 
-	return ret;
+	pm_runtime_put(log_stream->hsw->dev);
+	return 0;
 }
 
-int sst_hsw_dsp_runtime_suspend(struct sst_hsw *hsw)
+static ssize_t fw_log_copy_to_user(struct sst_hsw_log_stream *log_stream,
+					char __user *user_buf, size_t count)
 {
-	int ret;
+	/* check for reader buffer wrap */
+	if (log_stream->reader_pos + count > log_stream->size) {
+		size_t size = log_stream->size - log_stream->reader_pos;
 
-	dev_dbg(hsw->dev, "audio dsp runtime suspend\n");
+		/* wrap */
+		if (copy_to_user(user_buf,
+			log_stream->dma_area + log_stream->reader_pos, size))
+			return -EFAULT;
 
-	ret = sst_hsw_dx_set_state(hsw, SST_HSW_DX_STATE_D3, &hsw->dx);
-	if (ret < 0)
-		return ret;
+		if (copy_to_user(user_buf + size,
+			log_stream->dma_area, count - size))
+			return -EFAULT;
 
-	sst_dsp_stall(hsw->dsp);
+		log_stream->reader_pos = count - size;
 
-	ret = sst_hsw_dx_state_dump(hsw);
-	if (ret < 0)
-		return ret;
+		return count;
+
+	} else {
+		/* no wrap */
+		if (copy_to_user(user_buf,
+			log_stream->dma_area + log_stream->reader_pos, count))
+			return -EFAULT;
 
-	sst_ipc_drop_all(&hsw->ipc);
+		log_stream->reader_pos += count;
 
-	return 0;
+		return count;
+	}
 }
 
-int sst_hsw_dsp_runtime_sleep(struct sst_hsw *hsw)
+static ssize_t fw_log_read_data(struct file *file, char __user *user_buf,
+					size_t count, loff_t *ppos)
 {
-	struct sst_fw *sst_fw, *t;
-	struct sst_dsp *dsp = hsw->dsp;
+	struct sst_hsw_log_stream *log_stream = file->private_data;
+	size_t bytes;
+	ssize_t ret = 0;
 
-	list_for_each_entry_safe(sst_fw, t, &dsp->fw_list, list) {
-		sst_fw_unload(sst_fw);
-	}
-	sst_block_free_scratch(dsp);
+	do {
+		mutex_lock(&log_stream->rw_mutex);
 
-	hsw->boot_complete = false;
+		if (log_stream->last_pos < log_stream->curr_pos) {
+			if (log_stream->reader_pos < log_stream->last_pos
+			|| log_stream->reader_pos > log_stream->curr_pos)
 
-	sst_dsp_sleep(dsp);
+				log_stream->reader_pos = log_stream->last_pos;
+		} else {
+			if (log_stream->reader_pos < log_stream->last_pos
+			&& log_stream->reader_pos > log_stream->curr_pos)
 
-	return 0;
-}
+				log_stream->reader_pos = log_stream->last_pos;
+		}
 
-int sst_hsw_dsp_runtime_resume(struct sst_hsw *hsw)
-{
-	struct device *dev = hsw->dev;
-	int ret;
+		if (log_stream->curr_pos >= log_stream->reader_pos) {
+			bytes = log_stream->curr_pos - log_stream->reader_pos;
+		} else {
+			bytes = log_stream->curr_pos + log_stream->size -
+				log_stream->reader_pos;
+		}
+		mutex_unlock(&log_stream->rw_mutex);
 
-	dev_dbg(dev, "audio dsp runtime resume\n");
+		if (bytes > count)
+			bytes = count;
 
-	if (hsw->boot_complete)
-		return 1; /* tell caller no action is required */
-
-	ret = sst_hsw_dsp_restore(hsw);
-	if (ret < 0)
-		dev_err(dev, "error: audio DSP boot failure\n");
+		if (bytes > 0) {
+			ret = fw_log_copy_to_user(log_stream, user_buf, bytes);
+			break;
+		}
 
-	sst_hsw_init_module_state(hsw);
+		if (file->f_flags & O_NONBLOCK) {
+			ret = -EAGAIN;
+			break;
+		}
 
-	ret = wait_event_timeout(hsw->boot_wait, hsw->boot_complete,
-		msecs_to_jiffies(IPC_BOOT_MSECS));
-	if (ret == 0) {
-		dev_err(hsw->dev, "error: audio DSP boot timeout IPCD 0x%x IPCX 0x%x\n",
-			sst_dsp_shim_read_unlocked(hsw->dsp, SST_IPCD),
-			sst_dsp_shim_read_unlocked(hsw->dsp, SST_IPCX));
-		return -EIO;
-	}
+		if (wait_event_interruptible(log_stream->readers_wait_q,
+			log_stream->curr_pos != log_stream->reader_pos)) {
+			ret = -ERESTARTSYS;
+			break;
+		}
 
-	/* Set ADSP SSP port settings */
-	ret = sst_hsw_device_set_config(hsw, SST_HSW_DEVICE_SSP_0,
-					SST_HSW_DEVICE_MCLK_FREQ_24_MHZ,
-					SST_HSW_DEVICE_CLOCK_MASTER, 9);
-	if (ret < 0)
-		dev_err(dev, "error: SSP re-initialization failed\n");
+	} while (1);
 
 	return ret;
 }
-#endif
 
-struct sst_dsp *sst_hsw_get_dsp(struct sst_hsw *hsw)
+static const struct file_operations fw_log_fops = {
+	.open = fw_log_open_data,
+	.read = fw_log_read_data,
+	.release = fw_log_release,
+};
+
+static int fw_log_config_open(struct inode *inode, struct file *file)
 {
-	return hsw->dsp;
+	file->private_data = inode->i_private;
+	return 0;
 }
 
-void sst_hsw_init_module_state(struct sst_hsw *hsw)
+static ssize_t fw_log_config_read(struct file *file, char __user *buffer,
+						size_t count, loff_t *ppos)
 {
-	struct sst_module *module;
-	enum sst_hsw_module_id id;
+	struct sst_hsw_log_stream *log_stream = file->private_data;
+	int max_size = sizeof(log_stream->config);
 
-	/* the base fw contains several modules */
-	for (id = SST_HSW_MODULE_BASE_FW; id < SST_HSW_MAX_MODULE_ID; id++) {
-		module = sst_module_get_from_id(hsw->dsp, id);
-		if (module) {
-			/* module waves is active only after being enabled */
-			if (id == SST_HSW_MODULE_WAVES)
-				module->state = SST_MODULE_STATE_INITIALIZED;
-			else
-				module->state = SST_MODULE_STATE_ACTIVE;
-		}
-	}
-}
+	if (*ppos >= max_size)
+		return 0;
+	if (*ppos + count > max_size)
+		count = max_size - *ppos;
 
-bool sst_hsw_is_module_loaded(struct sst_hsw *hsw, u32 module_id)
-{
-	struct sst_module *module;
+	if (copy_to_user(buffer, log_stream->config + *ppos, count))
+		return -EFAULT;
 
-	module = sst_module_get_from_id(hsw->dsp, module_id);
-	if (module == NULL || module->state == SST_MODULE_STATE_UNLOADED)
-		return false;
-	else
-		return true;
+	*ppos += count;
+
+	return count;
 }
 
-bool sst_hsw_is_module_active(struct sst_hsw *hsw, u32 module_id)
+static ssize_t fw_log_config_write(struct file *file,
+	const char __user *buffer, size_t count, loff_t *ppos)
 {
-	struct sst_module *module;
+	struct sst_hsw_log_stream *log_stream = file->private_data;
+	struct sst_hsw_ipc_debug_log_enable_req req;
+	u32 header;
+	int max_size = sizeof(log_stream->config);
+	int ret;
 
-	module = sst_module_get_from_id(hsw->dsp, module_id);
-	if (module != NULL && module->state == SST_MODULE_STATE_ACTIVE)
-		return true;
-	else
-		return false;
-}
+	if (*ppos >= max_size)
+		return 0;
+	if (*ppos + count > max_size)
+		count = max_size - *ppos;
 
-void sst_hsw_set_module_enabled_rtd3(struct sst_hsw *hsw, u32 module_id)
-{
-	hsw->enabled_modules_rtd3 |= (1 << module_id);
-}
+	if (copy_from_user(log_stream->config + *ppos, buffer, count))
+		return -EFAULT;
 
-void sst_hsw_set_module_disabled_rtd3(struct sst_hsw *hsw, u32 module_id)
-{
-	hsw->enabled_modules_rtd3 &= ~(1 << module_id);
-}
+	*ppos += count;
 
-bool sst_hsw_is_module_enabled_rtd3(struct sst_hsw *hsw, u32 module_id)
-{
-	return hsw->enabled_modules_rtd3 & (1 << module_id);
+	req.ringinfo.ring_pt_address = virt_to_phys(log_stream->ring_descr);
+	req.ringinfo.num_pages = log_stream->pages;
+	req.ringinfo.ring_size = log_stream->size;
+	req.ringinfo.ring_offset = 0;
+	req.ringinfo.ring_first_pfn = virt_to_phys(log_stream->dma_area);
+	memcpy(req.config, log_stream->config, sizeof(log_stream->config));
+
+	header = IPC_GLB_TYPE(IPC_GLB_DEBUG_LOG_MESSAGE);
+	header |= IPC_LOG_OP_TYPE(IPC_DEBUG_ENABLE_LOG);
+	header |= IPC_LOG_ID(SST_HSW_GLOBAL_LOG);
+
+	dev_info(log_stream->hsw->dev, "send ipc to configure fw log\n");
+
+	ret = ipc_tx_message_nowait(log_stream->hsw, header, &req, sizeof(req));
+	if (ret < 0) {
+		dev_err(log_stream->hsw->dev, "ipc: setting config fw log failed\n");
+		return ret;
+	}
+
+	return count;
 }
 
-void sst_hsw_reset_param_buf(struct sst_hsw *hsw)
+static const struct file_operations fw_log_config_fops = {
+	.open = fw_log_config_open,
+	.read = fw_log_config_read,
+	.write = fw_log_config_write,
+};
+
+#ifdef CONFIG_PM
+static int suspend_stats_open(struct inode *inode, struct file *file)
 {
-	hsw->param_idx_w = 0;
-	hsw->param_idx_r = 0;
-	memset((void *)hsw->param_buf, 0, sizeof(hsw->param_buf));
+	file->private_data = inode->i_private;
+	return 0;
 }
 
-int sst_hsw_store_param_line(struct sst_hsw *hsw, u8 *buf)
+static const char *get_dstate_name(int state)
 {
-	/* save line to the first available position of param buffer */
-	if (hsw->param_idx_w > WAVES_PARAM_LINES - 1) {
-		dev_warn(hsw->dev, "warning: param buffer overflow!\n");
-		return -EPERM;
+	const char *state_name[] = {"D0", "IDLE", "D3", "UNKNOWN"};
+	switch (state) {
+	case d0_state: return state_name[0];
+	case idle_state: return state_name[1];
+	case d3_state: return state_name[2];
+	default: return state_name[3];
 	}
-	memcpy(hsw->param_buf[hsw->param_idx_w], buf, WAVES_PARAM_COUNT);
-	hsw->param_idx_w++;
-	return 0;
 }
 
-int sst_hsw_load_param_line(struct sst_hsw *hsw, u8 *buf)
+static ssize_t suspend_stats_read(struct file *file, char __user *buffer,
+				  size_t count, loff_t *ppos)
 {
-	u8 id = 0;
+	struct sst_hsw_log_stream *log_stream = file->private_data;
+	struct sst_hsw *hsw = log_stream->hsw;
+	char *buf = NULL;
 
-	/* read the first matching line from param buffer */
-	while (hsw->param_idx_r < WAVES_PARAM_LINES) {
-		id = hsw->param_buf[hsw->param_idx_r][0];
-		hsw->param_idx_r++;
-		if (buf[0] == id) {
-			memcpy(buf, hsw->param_buf[hsw->param_idx_r],
-				WAVES_PARAM_COUNT);
-			break;
-		}
-	}
-	if (hsw->param_idx_r > WAVES_PARAM_LINES - 1) {
-		dev_dbg(hsw->dev, "end of buffer, roll to the beginning\n");
-		hsw->param_idx_r = 0;
+	if (*ppos)
 		return 0;
+
+	buf = kzalloc(PAGE_SIZE, GFP_DMA);
+	if (buf == NULL) {
+		pr_err("suspend stats buf kzalloc failed\n");
+		return -ENOMEM;
 	}
-	return 0;
-}
 
-int sst_hsw_launch_param_buf(struct sst_hsw *hsw)
-{
-	int ret, idx;
+	count = snprintf(buf, PAGE_SIZE,
+		"current state %s (%d)\ncount of :\n"
+		"Idle %d\n"
+		"D0 %d\nD3 %d\nS0 %d\nS3 %d\n",
+		get_dstate_name(hsw->dx_state), hsw->dx_state,
+		hsw->cnt_state_idle,
+		hsw->cnt_state_d0, hsw->cnt_state_d3,
+		hsw->cnt_state_s0, hsw->cnt_state_s3);
+
+	if (copy_to_user(buffer, buf, count)) {
+		pr_err("suspend stats copy_to_user failed\n");
+		kfree(buf);
+		return -EFAULT;
+	}
+
+	*ppos = count;
+	kfree(buf);
+
+	return count;
+}
+
+static const struct file_operations suspend_stats_fops = {
+	.open = suspend_stats_open,
+	.read = suspend_stats_read,
+};
+#endif
 
-	if (!sst_hsw_is_module_active(hsw, SST_HSW_MODULE_WAVES)) {
-		dev_dbg(hsw->dev, "module waves is not active\n");
-		return 0;
+/* debug control - sysFS */
+int sst_hsw_dbg_enable(struct sst_hsw *hsw,
+	struct dentry *debugfs_card_root)
+{
+	struct sst_hsw_log_stream *log_stream = &hsw->log_stream;
+	int i;
+	struct snd_dma_buffer *dma_buf[2];
+	static struct dentry *fwdir;
+
+	dma_buf[0] = devm_kzalloc(hsw->dsp->dev, sizeof(*dma_buf[0]), GFP_KERNEL);
+	dma_buf[1] = devm_kzalloc(hsw->dsp->dev, sizeof(*dma_buf[1]), GFP_KERNEL);
+	memset(log_stream->config, 0xFF, sizeof(log_stream->config));
+	log_stream->size = 32 * PAGE_SIZE;
+	log_stream->hsw = hsw;
+
+//	log_stream->dma_area = dma_alloc_coherent(/*hsw->dsp->dma_dev*/log_stream->hsw->dev,
+//		log_stream->size, &log_stream->dma_addr, GFP_KERNEL);
+	snd_dma_alloc_pages(SNDRV_DMA_TYPE_DEV, hsw->dsp->dma_dev,
+				log_stream->size, dma_buf[0]);
+	log_stream->dma_addr = dma_buf[0]->addr;
+	log_stream->dma_area = dma_buf[0]->area;
+	dev_info(log_stream->hsw->dev,
+		"alloc dma buffer: area=%p, addr=%p, size=%d\n",
+		(void *)log_stream->dma_area,
+		(void *)log_stream->dma_addr,
+		log_stream->size);
+
+	if (!log_stream->dma_area) {
+		dev_err(log_stream->hsw->dev, "alloc dma buffer failed\n");
+		return -EINVAL;
+	}
+
+//	log_stream->ring_descr = kzalloc(PAGE_SIZE, GFP_DMA);
+	snd_dma_alloc_pages(SNDRV_DMA_TYPE_DEV, hsw->dsp->dma_dev,
+				PAGE_SIZE, dma_buf[1]);
+	log_stream->ring_descr = dma_buf[1]->area;
+
+	if (!log_stream->ring_descr) {
+		dev_err(log_stream->hsw->dev, "alloc ring descriptor failed\n");
+		return -EINVAL;
 	}
 
-	/* put all param lines to DSP through ipc */
-	for (idx = 0; idx < hsw->param_idx_w; idx++) {
-		ret = sst_hsw_module_set_param(hsw,
-			SST_HSW_MODULE_WAVES, 0, hsw->param_buf[idx][0],
-			WAVES_PARAM_COUNT, hsw->param_buf[idx]);
-		if (ret < 0)
-			return ret;
+	if (log_stream->size % PAGE_SIZE)
+		log_stream->pages = (log_stream->size / PAGE_SIZE) + 1;
+	else
+		log_stream->pages = log_stream->size / PAGE_SIZE;
+
+	dev_info(log_stream->hsw->dev,
+		"generating page table for %p size 0x%x pages %d\n",
+		log_stream->dma_area, log_stream->size, log_stream->pages);
+
+	for (i = 0; i < log_stream->pages; i++) {
+		u32 idx = (((i << 2) + i)) >> 1;
+		u32 pfn = (virt_to_phys(log_stream->dma_area + i * PAGE_SIZE))
+				>> PAGE_SHIFT;
+		u32 *pg_table;
+
+		pg_table = (u32 *)(log_stream->ring_descr + idx);
+
+		if (i & 1)
+			*pg_table |= (pfn << 4);
+		else
+			*pg_table |= pfn;
 	}
+
+	INIT_WORK(&log_stream->notify_work, hsw_log_notification_work);
+	init_waitqueue_head(&log_stream->readers_wait_q);
+	mutex_init(&log_stream->rw_mutex);
+
+	dev_dbg(log_stream->hsw->dev,"debugfs_card_root:%s", debugfs_card_root->d_name.name);
+
+	fwdir = debugfs_create_dir("fw_logs", NULL);
+
+	if (!debugfs_create_file("fw_log", 0444, fwdir,
+			&hsw->log_stream, &fw_log_fops))
+		pr_warn("ASoC: Failed to create fw_log debugfs file\n");
+
+#if 1
+	if (!debugfs_create_file("fw_log_config", 0644, fwdir,
+			&hsw->log_stream, &fw_log_config_fops))
+		pr_warn("ASoC: Failed to create fw_log_config debugfs file\n");
+
+	if (!debugfs_create_file("suspend_stats", 0444, fwdir,
+			&hsw->log_stream, &suspend_stats_fops))
+		pr_warn("ASoC: Failed to create suspend_stats file\n");
+#endif
 	return 0;
 }
+EXPORT_SYMBOL(sst_hsw_dbg_enable);
 
-int sst_hsw_module_load(struct sst_hsw *hsw,
-	u32 module_id, u32 instance_id, char *name)
+int sst_hsw_dbg_disable(struct sst_hsw *hsw,
+	struct sst_hsw_stream *stream, u32 log_id)
 {
-	int ret = 0;
-	const struct firmware *fw = NULL;
-	struct sst_fw *hsw_sst_fw;
-	struct sst_module *module;
-	struct device *dev = hsw->dev;
-	struct sst_dsp *dsp = hsw->dsp;
+	return 0;
+}
 
-	dev_dbg(dev, "sst_hsw_module_load id=%d, name='%s'", module_id, name);
+static void sst_hsw_drop_all(struct sst_hsw *hsw)
+{
+	struct ipc_message *msg, *tmp;
+	unsigned long flags;
+	int tx_drop_cnt = 0, rx_drop_cnt = 0;
 
-	module = sst_module_get_from_id(dsp, module_id);
-	if (module == NULL) {
-		/* loading for the first time */
-		if (module_id == SST_HSW_MODULE_BASE_FW) {
-			/* for base module: use fw requested in acpi probe */
-			fw = dsp->pdata->fw;
-			if (!fw) {
-				dev_err(dev, "request Base fw failed\n");
-				return -ENODEV;
-			}
-		} else {
-			/* try and load any other optional modules if they are
-			 * available. Use dev_info instead of dev_err in case
-			 * request firmware failed */
-			ret = request_firmware(&fw, name, dev);
-			if (ret) {
-				dev_info(dev, "fw image %s not available(%d)\n",
-						name, ret);
-				return ret;
-			}
-		}
-		hsw_sst_fw = sst_fw_new(dsp, fw, hsw);
-		if (hsw_sst_fw  == NULL) {
-			dev_err(dev, "error: failed to load firmware\n");
-			ret = -ENOMEM;
-			goto out;
-		}
-		module = sst_module_get_from_id(dsp, module_id);
-		if (module == NULL) {
-			dev_err(dev, "error: no module %d in firmware %s\n",
-					module_id, name);
-		}
-	} else
-		dev_info(dev, "module %d (%s) already loaded\n",
-				module_id, name);
-out:
-	/* release fw, but base fw should be released by acpi driver */
-	if (fw && module_id != SST_HSW_MODULE_BASE_FW)
-		release_firmware(fw);
+	/* drop all TX and Rx messages before we stall + reset DSP */
+	spin_lock_irqsave(&hsw->dsp->spinlock, flags);
 
-	return ret;
+	list_for_each_entry_safe(msg, tmp, &hsw->tx_list, list) {
+		list_move(&msg->list, &hsw->empty_list);
+		tx_drop_cnt++;
+	}
+
+	list_for_each_entry_safe(msg, tmp, &hsw->rx_list, list) {
+		list_move(&msg->list, &hsw->empty_list);
+		rx_drop_cnt++;
+	}
+
+	spin_unlock_irqrestore(&hsw->dsp->spinlock, flags);
+
+	if (tx_drop_cnt || rx_drop_cnt)
+		dev_err(hsw->dev, "dropped IPC msg RX=%d, TX=%d\n",
+			tx_drop_cnt, rx_drop_cnt);
 }
 
-int sst_hsw_module_enable(struct sst_hsw *hsw,
-	u32 module_id, u32 instance_id)
+int sst_hsw_dsp_load(struct sst_hsw *hsw)
 {
-	int ret;
-	u32 header = 0;
-	struct sst_hsw_ipc_module_config config;
-	struct sst_module *module;
-	struct sst_module_runtime *runtime;
-	struct device *dev = hsw->dev;
 	struct sst_dsp *dsp = hsw->dsp;
+	int ret;
 
-	if (!sst_hsw_is_module_loaded(hsw, module_id)) {
-		dev_dbg(dev, "module %d not loaded\n", module_id);
-		return 0;
-	}
+	dev_dbg(hsw->dev, "loading audio DSP....");
 
-	if (sst_hsw_is_module_active(hsw, module_id)) {
-		dev_info(dev, "module %d already enabled\n", module_id);
-		return 0;
+	ret = sst_dsp_wake(dsp);
+	if (ret < 0) {
+		dev_err(hsw->dev, "error: failed to wake audio DSP\n");
+		return -ENODEV;
 	}
 
-	module = sst_module_get_from_id(dsp, module_id);
-	if (module == NULL) {
-		dev_err(dev, "module %d not valid\n", module_id);
-		return -ENXIO;
+	ret = sst_dsp_dma_get_channel(dsp, 0);
+	if (ret < 0) {
+		dev_err(hsw->dev, "error: cant allocate dma channel %d\n", ret);
+		return ret;
 	}
 
-	runtime = sst_module_runtime_get_from_id(module, module_id);
-	if (runtime == NULL) {
-		dev_err(dev, "runtime %d not valid", module_id);
-		return -ENXIO;
+	ret = sst_fw_reload(hsw->sst_fw);
+	if (ret < 0) {
+		dev_err(hsw->dev, "error: SST FW reload failed\n");
+		sst_dsp_dma_put_channel(dsp);
+		return -ENOMEM;
 	}
 
-	header = IPC_GLB_TYPE(IPC_GLB_MODULE_OPERATION) |
-			IPC_MODULE_OPERATION(IPC_MODULE_ENABLE) |
-			IPC_MODULE_ID(module_id);
-	dev_dbg(dev, "module enable header: %x\n", header);
-
-	config.map.module_entries_count = 1;
-	config.map.module_entries[0].module_id = module->id;
-	config.map.module_entries[0].entry_point = module->entry;
-
-	config.persistent_mem.offset =
-		sst_dsp_get_offset(dsp,
-			runtime->persistent_offset, SST_MEM_DRAM);
-	config.persistent_mem.size = module->persistent_size;
-
-	config.scratch_mem.offset =
-		sst_dsp_get_offset(dsp,
-			dsp->scratch_offset, SST_MEM_DRAM);
-	config.scratch_mem.size = module->scratch_size;
-	dev_dbg(dev, "mod %d enable p:%d @ %x, s:%d @ %x, ep: %x",
-		config.map.module_entries[0].module_id,
-		config.persistent_mem.size,
-		config.persistent_mem.offset,
-		config.scratch_mem.size, config.scratch_mem.offset,
-		config.map.module_entries[0].entry_point);
-
-	ret = sst_ipc_tx_message_wait(&hsw->ipc, header,
-			&config, sizeof(config), NULL, 0);
-	if (ret < 0)
-		dev_err(dev, "ipc: module enable failed - %d\n", ret);
-	else
-		module->state = SST_MODULE_STATE_ACTIVE;
-
-	return ret;
+	sst_dsp_dma_put_channel(dsp);
+	return 0;
 }
 
-int sst_hsw_module_disable(struct sst_hsw *hsw,
-	u32 module_id, u32 instance_id)
+static int sst_hsw_dsp_restore(struct sst_hsw *hsw)
 {
-	int ret;
-	u32 header;
-	struct sst_module *module;
-	struct device *dev = hsw->dev;
 	struct sst_dsp *dsp = hsw->dsp;
+	int ret;
 
-	if (!sst_hsw_is_module_loaded(hsw, module_id)) {
-		dev_dbg(dev, "module %d not loaded\n", module_id);
-		return 0;
-	}
+	dev_dbg(hsw->dev, "restoring audio DSP....");
 
-	if (!sst_hsw_is_module_active(hsw, module_id)) {
-		dev_info(dev, "module %d already disabled\n", module_id);
-		return 0;
+	ret = sst_dsp_dma_get_channel(dsp, 0);
+	if (ret < 0) {
+		dev_err(hsw->dev, "error: cant allocate dma channel %d\n", ret);
+		return ret;
 	}
 
-	module = sst_module_get_from_id(dsp, module_id);
-	if (module == NULL) {
-		dev_err(dev, "module %d not valid\n", module_id);
-		return -ENXIO;
+	ret = sst_hsw_dx_state_restore(hsw);
+	if (ret < 0) {
+		dev_err(hsw->dev, "error: SST FW context restore failed\n");
+		sst_dsp_dma_put_channel(dsp);
+		return -ENOMEM;
 	}
+	sst_dsp_dma_put_channel(dsp);
 
-	header = IPC_GLB_TYPE(IPC_GLB_MODULE_OPERATION) |
-			IPC_MODULE_OPERATION(IPC_MODULE_DISABLE) |
-			IPC_MODULE_ID(module_id);
-
-	ret = sst_ipc_tx_message_wait(&hsw->ipc, header,  NULL, 0, NULL, 0);
-	if (ret < 0)
-		dev_err(dev, "module disable failed - %d\n", ret);
-	else
-		module->state = SST_MODULE_STATE_INITIALIZED;
+	/* wait for DSP boot completion */
+	sst_dsp_boot(dsp);
 
 	return ret;
 }
 
-int sst_hsw_module_set_param(struct sst_hsw *hsw,
-	u32 module_id, u32 instance_id, u32 parameter_id,
-	u32 param_size, char *param)
+int sst_hsw_dsp_runtime_suspend(struct sst_hsw *hsw)
 {
 	int ret;
-	unsigned char *data = NULL;
-	u32 header = 0;
-	u32 payload_size = 0, transfer_parameter_size = 0;
-	dma_addr_t dma_addr = 0;
-	struct sst_hsw_transfer_parameter *parameter;
-	struct device *dev = hsw->dev;
 
-	header = IPC_GLB_TYPE(IPC_GLB_MODULE_OPERATION) |
-			IPC_MODULE_OPERATION(IPC_MODULE_SET_PARAMETER) |
-			IPC_MODULE_ID(module_id);
-	dev_dbg(dev, "sst_hsw_module_set_param header=%x\n", header);
-
-	payload_size = param_size +
-		sizeof(struct sst_hsw_transfer_parameter) -
-		sizeof(struct sst_hsw_transfer_list);
-	dev_dbg(dev, "parameter size : %d\n", param_size);
-	dev_dbg(dev, "payload size   : %d\n", payload_size);
-
-	if (payload_size <= SST_HSW_IPC_MAX_SHORT_PARAMETER_SIZE) {
-		/* short parameter, mailbox can contain data */
-		dev_dbg(dev, "transfer parameter size : %d\n",
-			transfer_parameter_size);
-
-		transfer_parameter_size = ALIGN(payload_size, 4);
-		dev_dbg(dev, "transfer parameter aligned size : %d\n",
-			transfer_parameter_size);
-
-		parameter = kzalloc(transfer_parameter_size, GFP_KERNEL);
-		if (parameter == NULL)
-			return -ENOMEM;
+	dev_dbg(hsw->dev, "audio dsp runtime suspend\n");
 
-		memcpy(parameter->data, param, param_size);
-	} else {
-		dev_warn(dev, "transfer parameter size too large!");
-		return 0;
-	}
+	ret = sst_hsw_dx_set_state(hsw, SST_HSW_DX_STATE_D3, &hsw->dx);
+	if (ret < 0)
+		return ret;
 
-	parameter->parameter_id = parameter_id;
-	parameter->data_size = param_size;
+	sst_dsp_stall(hsw->dsp);
 
-	ret = sst_ipc_tx_message_wait(&hsw->ipc, header,
-		parameter, transfer_parameter_size , NULL, 0);
+	ret = sst_hsw_dx_state_dump(hsw);
 	if (ret < 0)
-		dev_err(dev, "ipc: module set parameter failed - %d\n", ret);
-
-	kfree(parameter);
+		return ret;
 
-	if (data)
-		dma_free_coherent(hsw->dsp->dma_dev,
-			param_size, (void *)data, dma_addr);
+	sst_hsw_drop_all(hsw);
 
-	return ret;
+	return 0;
 }
 
-static struct sst_dsp_device hsw_dev = {
-	.thread = hsw_irq_thread,
-	.ops = &haswell_ops,
-};
-
-static void hsw_tx_msg(struct sst_generic_ipc *ipc, struct ipc_message *msg)
+int sst_hsw_dsp_runtime_sleep(struct sst_hsw *hsw)
 {
-	/* send the message */
-	sst_dsp_outbox_write(ipc->dsp, msg->tx_data, msg->tx_size);
-	sst_dsp_ipc_msg_tx(ipc->dsp, msg->header);
+	sst_fw_unload(hsw->sst_fw);
+	sst_block_free_scratch(hsw->dsp);
+
+	hsw->boot_complete = false;
+
+	sst_dsp_sleep(hsw->dsp);
+
+	return 0;
 }
 
-static void hsw_shim_dbg(struct sst_generic_ipc *ipc, const char *text)
+int sst_hsw_dsp_runtime_resume(struct sst_hsw *hsw)
 {
-	struct sst_dsp *sst = ipc->dsp;
-	u32 isr, ipcd, imrx, ipcx;
+	struct device *dev = hsw->dev;
+	int ret;
 
-	ipcx = sst_dsp_shim_read_unlocked(sst, SST_IPCX);
-	isr = sst_dsp_shim_read_unlocked(sst, SST_ISRX);
-	ipcd = sst_dsp_shim_read_unlocked(sst, SST_IPCD);
-	imrx = sst_dsp_shim_read_unlocked(sst, SST_IMRX);
+	dev_dbg(dev, "audio dsp runtime resume\n");
 
-	dev_err(ipc->dev,
-		"ipc: --%s-- ipcx 0x%8.8x isr 0x%8.8x ipcd 0x%8.8x imrx 0x%8.8x\n",
-		text, ipcx, isr, ipcd, imrx);
+	if (hsw->boot_complete)
+		return 1; /* tell caller no action is required */
+
+	ret = sst_hsw_dsp_restore(hsw);
+	if (ret < 0)
+		dev_err(dev, "error: audio DSP boot failure\n");
+
+	ret = wait_event_timeout(hsw->boot_wait, hsw->boot_complete,
+		msecs_to_jiffies(IPC_BOOT_MSECS));
+	if (ret == 0) {
+		dev_err(hsw->dev, "error: audio DSP boot timeout IPCD 0x%x IPCX 0x%x\n",
+			sst_dsp_shim_read_unlocked(hsw->dsp, SST_IPCD),
+			sst_dsp_shim_read_unlocked(hsw->dsp, SST_IPCX));
+		return -EIO;
+	}
+
+	/* Set ADSP SSP port settings */
+	ret = sst_hsw_device_set_config(hsw, SST_HSW_DEVICE_SSP_0,
+					SST_HSW_DEVICE_MCLK_FREQ_24_MHZ,
+					SST_HSW_DEVICE_CLOCK_MASTER, 9);
+	if (ret < 0)
+		dev_err(dev, "error: SSP re-initialization failed\n");
+
+	return ret;
 }
 
-static void hsw_tx_data_copy(struct ipc_message *msg, char *tx_data,
-	size_t tx_size)
+static int msg_empty_list_init(struct sst_hsw *hsw)
 {
-	memcpy(msg->tx_data, tx_data, tx_size);
+	int i;
+
+	hsw->msg = kzalloc(sizeof(struct ipc_message) *
+		IPC_EMPTY_LIST_SIZE, GFP_KERNEL);
+	if (hsw->msg == NULL)
+		return -ENOMEM;
+
+	for (i = 0; i < IPC_EMPTY_LIST_SIZE; i++) {
+		init_waitqueue_head(&hsw->msg[i].waitq);
+		list_add(&hsw->msg[i].list, &hsw->empty_list);
+	}
+
+	return 0;
 }
 
-static u64 hsw_reply_msg_match(u64 header, u64 *mask)
+struct sst_dsp *sst_hsw_get_dsp(struct sst_hsw *hsw)
 {
-	/* clear reply bits & status bits */
-	header &= ~(IPC_STATUS_MASK | IPC_GLB_REPLY_MASK);
-	*mask = (u64)-1;
-
-	return header;
+	return hsw->dsp;
 }
 
+static struct sst_dsp_device hsw_dev = {
+	.thread = hsw_irq_thread,
+	.ops = &haswell_ops,
+};
+
 int sst_hsw_dsp_init(struct device *dev, struct sst_pdata *pdata)
 {
 	struct sst_hsw_ipc_fw_version version;
 	struct sst_hsw *hsw;
-	struct sst_generic_ipc *ipc;
 	int ret;
 
 	dev_dbg(dev, "initialising Audio DSP IPC\n");
@@ -2111,30 +2404,39 @@
 	if (hsw == NULL)
 		return -ENOMEM;
 
-	ipc = &hsw->ipc;
-	ipc->dev = dev;
-	ipc->ops.tx_msg = hsw_tx_msg;
-	ipc->ops.shim_dbg = hsw_shim_dbg;
-	ipc->ops.tx_data_copy = hsw_tx_data_copy;
-	ipc->ops.reply_msg_match = hsw_reply_msg_match;
-
-	ret = sst_ipc_init(ipc);
-	if (ret != 0)
-		goto ipc_init_err;
-
+	hsw->dev = dev;
 	INIT_LIST_HEAD(&hsw->stream_list);
+	INIT_LIST_HEAD(&hsw->tx_list);
+	INIT_LIST_HEAD(&hsw->rx_list);
+	INIT_LIST_HEAD(&hsw->empty_list);
 	init_waitqueue_head(&hsw->boot_wait);
+	init_waitqueue_head(&hsw->wait_txq);
+
+	ret = msg_empty_list_init(hsw);
+	if (ret < 0)
+		goto list_err;
+
+	/* start the IPC message thread */
+	init_kthread_worker(&hsw->kworker);
+	hsw->tx_thread = kthread_run(kthread_worker_fn,
+					   &hsw->kworker, "%s",
+					   dev_name(hsw->dev));
+	if (IS_ERR(hsw->tx_thread)) {
+		ret = PTR_ERR(hsw->tx_thread);
+		dev_err(hsw->dev, "error: failed to create message TX task\n");
+		goto list_err;
+	}
+	init_kthread_work(&hsw->kwork, ipc_tx_msgs);
+
 	hsw_dev.thread_context = hsw;
 
 	/* init SST shim */
 	hsw->dsp = sst_dsp_new(dev, &hsw_dev, pdata);
 	if (hsw->dsp == NULL) {
 		ret = -ENODEV;
-		goto dsp_new_err;
+		goto list_err;
 	}
 
-	ipc->dsp = hsw->dsp;
-
 	/* allocate DMA buffer for context storage */
 	hsw->dx_context = dma_alloc_coherent(hsw->dsp->dma_dev,
 		SST_HSW_DX_CONTEXT_SIZE, &hsw->dx_context_paddr, GFP_KERNEL);
@@ -2146,21 +2448,12 @@
 	/* keep the DSP in reset state for base FW loading */
 	sst_dsp_reset(hsw->dsp);
 
-	/* load base module and other modules in base firmware image */
-	ret = sst_hsw_module_load(hsw, SST_HSW_MODULE_BASE_FW, 0, "Base");
-	if (ret < 0)
+	hsw->sst_fw = sst_fw_new(hsw->dsp, pdata->fw, hsw);
+	if (hsw->sst_fw == NULL) {
+		ret = -ENODEV;
+		dev_err(dev, "error: failed to load firmware\n");
 		goto fw_err;
-
-	/* try to load module waves */
-	sst_hsw_module_load(hsw, SST_HSW_MODULE_WAVES, 0, "intel/IntcPP01.bin");
-
-	/* allocate scratch mem regions */
-	ret = sst_block_alloc_scratch(hsw->dsp);
-	if (ret < 0)
-		goto boot_err;
-
-	/* init param buffer */
-	sst_hsw_reset_param_buf(hsw);
+	}
 
 	/* wait for DSP boot completion */
 	sst_dsp_boot(hsw->dsp);
@@ -2174,9 +2467,6 @@
 		goto boot_err;
 	}
 
-	/* init module state after boot */
-	sst_hsw_init_module_state(hsw);
-
 	/* get the FW version */
 	sst_hsw_fw_get_version(hsw, &version);
 
@@ -2192,15 +2482,14 @@
 
 boot_err:
 	sst_dsp_reset(hsw->dsp);
-	sst_fw_free_all(hsw->dsp);
+	sst_fw_free(hsw->sst_fw);
 fw_err:
 	dma_free_coherent(hsw->dsp->dma_dev, SST_HSW_DX_CONTEXT_SIZE,
 			hsw->dx_context, hsw->dx_context_paddr);
 dma_err:
 	sst_dsp_free(hsw->dsp);
-dsp_new_err:
-	sst_ipc_fini(ipc);
-ipc_init_err:
+	kfree(hsw->msg);
+list_err:
 	return ret;
 }
 EXPORT_SYMBOL_GPL(sst_hsw_dsp_init);
@@ -2214,6 +2503,7 @@
 	dma_free_coherent(hsw->dsp->dma_dev, SST_HSW_DX_CONTEXT_SIZE,
 			hsw->dx_context, hsw->dx_context_paddr);
 	sst_dsp_free(hsw->dsp);
-	sst_ipc_fini(&hsw->ipc);
+	kfree(hsw->scratch);
+	kfree(hsw->msg);
 }
 EXPORT_SYMBOL_GPL(sst_hsw_dsp_free);
diff -Nru a/sound/soc/intel/haswell/sst-haswell-ipc.h b/sound/soc/intel/haswell/sst-haswell-ipc.h
--- a/sound/soc/intel/haswell/sst-haswell-ipc.h	2015-08-16 23:52:51.000000000 -0400
+++ b/sound/soc/intel/haswell/sst-haswell-ipc.h	2015-08-22 16:54:09.948983000 -0400
@@ -20,12 +20,10 @@
 #include <linux/types.h>
 #include <linux/kernel.h>
 #include <linux/platform_device.h>
-#include <sound/asound.h>
 
-#define SST_HSW_NO_CHANNELS		4
+#define SST_HSW_NO_CHANNELS		2
 #define SST_HSW_MAX_DX_REGIONS		14
 #define SST_HSW_DX_CONTEXT_SIZE        (640 * 1024)
-#define SST_HSW_CHANNELS_ALL		0xffffffff
 
 #define SST_HSW_FW_LOG_CONFIG_DWORDS	12
 #define SST_HSW_GLOBAL_LOG		15
@@ -37,9 +35,6 @@
 #define SST_HSW_IPC_MAX_PAYLOAD_SIZE	400
 #define SST_HSW_MAX_INFO_SIZE		64
 #define SST_HSW_BUILD_HASH_LENGTH	40
-#define SST_HSW_IPC_MAX_SHORT_PARAMETER_SIZE	500
-#define WAVES_PARAM_COUNT		128
-#define WAVES_PARAM_LINES		160
 
 struct sst_hsw;
 struct sst_hsw_stream;
@@ -190,28 +185,6 @@
 	SST_HSW_PERF_STOP = 1,
 };
 
-struct sst_hsw_transfer_info {
-	uint32_t destination;       /* destination address */
-	uint32_t reverse:1;         /* if 1 data flows from destination */
-	uint32_t size:31;           /* transfer size in bytes.*/
-	uint16_t first_page_offset; /* offset to data in the first page. */
-	uint8_t  packed_pages;   /* page addresses. Each occupies 20 bits */
-} __attribute__((packed));
-
-struct sst_hsw_transfer_list {
-	uint32_t transfers_count;
-	struct sst_hsw_transfer_info transfers;
-} __attribute__((packed));
-
-struct sst_hsw_transfer_parameter {
-	uint32_t parameter_id;
-	uint32_t data_size;
-	union {
-		uint8_t data[1];
-		struct sst_hsw_transfer_list transfer_list;
-	};
-} __attribute__((packed));
-
 /* SST firmware module info */
 struct sst_hsw_module_info {
 	u8 name[SST_HSW_MAX_INFO_SIZE];
@@ -240,12 +213,6 @@
 	struct sst_hsw_memory_info persistent_mem;
 } __attribute__((packed));
 
-struct sst_hsw_ipc_module_config {
-	struct sst_hsw_module_map map;
-	struct sst_hsw_memory_info persistent_mem;
-	struct sst_hsw_memory_info scratch_mem;
-} __attribute__((packed));
-
 struct sst_hsw_get_fx_param {
 	u32 parameter_id;
 	u32 param_size;
@@ -408,17 +375,32 @@
 u32 create_channel_map(enum sst_hsw_channel_config config);
 
 /* Stream Mixer Controls - */
+int sst_hsw_stream_mute(struct sst_hsw *hsw, struct sst_hsw_stream *stream,
+	u32 stage_id, u32 channel);
+int sst_hsw_stream_unmute(struct sst_hsw *hsw, struct sst_hsw_stream *stream,
+	u32 stage_id, u32 channel);
+
 int sst_hsw_stream_set_volume(struct sst_hsw *hsw,
 	struct sst_hsw_stream *stream, u32 stage_id, u32 channel, u32 volume);
 int sst_hsw_stream_get_volume(struct sst_hsw *hsw,
 	struct sst_hsw_stream *stream, u32 stage_id, u32 channel, u32 *volume);
 
+int sst_hsw_stream_set_volume_curve(struct sst_hsw *hsw,
+	struct sst_hsw_stream *stream, u64 curve_duration,
+	enum sst_hsw_volume_curve curve);
+
 /* Global Mixer Controls - */
+int sst_hsw_mixer_mute(struct sst_hsw *hsw, u32 stage_id, u32 channel);
+int sst_hsw_mixer_unmute(struct sst_hsw *hsw, u32 stage_id, u32 channel);
+
 int sst_hsw_mixer_set_volume(struct sst_hsw *hsw, u32 stage_id, u32 channel,
 	u32 volume);
 int sst_hsw_mixer_get_volume(struct sst_hsw *hsw, u32 stage_id, u32 channel,
 	u32 *volume);
 
+int sst_hsw_mixer_set_volume_curve(struct sst_hsw *hsw,
+	u64 curve_duration, enum sst_hsw_volume_curve curve);
+
 /* Stream API */
 struct sst_hsw_stream *sst_hsw_stream_new(struct sst_hsw *hsw, int id,
 	u32 (*get_write_position)(struct sst_hsw_stream *stream, void *data),
@@ -457,14 +439,18 @@
 	struct sst_hsw_stream *stream, u32 offset, u32 size);
 int sst_hsw_stream_set_smemory_info(struct sst_hsw *hsw,
 	struct sst_hsw_stream *stream, u32 offset, u32 size);
-snd_pcm_uframes_t sst_hsw_stream_get_old_position(struct sst_hsw *hsw,
+int sst_hsw_stream_get_hw_id(struct sst_hsw *hsw,
 	struct sst_hsw_stream *stream);
-void sst_hsw_stream_set_old_position(struct sst_hsw *hsw,
-	struct sst_hsw_stream *stream, snd_pcm_uframes_t val);
-bool sst_hsw_stream_get_silence_start(struct sst_hsw *hsw,
+int sst_hsw_stream_get_mixer_id(struct sst_hsw *hsw,
 	struct sst_hsw_stream *stream);
-void sst_hsw_stream_set_silence_start(struct sst_hsw *hsw,
-	struct sst_hsw_stream *stream, bool val);
+u32 sst_hsw_stream_get_read_reg(struct sst_hsw *hsw,
+	struct sst_hsw_stream *stream);
+u32 sst_hsw_stream_get_pointer_reg(struct sst_hsw *hsw,
+	struct sst_hsw_stream *stream);
+u32 sst_hsw_stream_get_peak_reg(struct sst_hsw *hsw,
+	struct sst_hsw_stream *stream, u32 channel);
+u32 sst_hsw_stream_get_vol_reg(struct sst_hsw *hsw,
+	struct sst_hsw_stream *stream, u32 channel);
 int sst_hsw_mixer_get_info(struct sst_hsw *hsw);
 
 /* Stream ALSA trigger operations */
@@ -479,6 +465,8 @@
 	struct sst_hsw_stream *stream, u32 *position);
 int sst_hsw_stream_get_write_pos(struct sst_hsw *hsw,
 	struct sst_hsw_stream *stream, u32 *position);
+int sst_hsw_stream_set_write_position(struct sst_hsw *hsw,
+	struct sst_hsw_stream *stream, u32 stage_id, u32 position);
 u32 sst_hsw_get_dsp_position(struct sst_hsw *hsw,
 	struct sst_hsw_stream *stream);
 u64 sst_hsw_get_dsp_presentation_position(struct sst_hsw *hsw,
@@ -492,33 +480,15 @@
 /* DX Config */
 int sst_hsw_dx_set_state(struct sst_hsw *hsw,
 	enum sst_hsw_dx_state state, struct sst_hsw_ipc_dx_reply *dx);
+int sst_hsw_dx_get_state(struct sst_hsw *hsw, u32 item,
+	u32 *offset, u32 *size, u32 *source);
 
 /* init */
 int sst_hsw_dsp_init(struct device *dev, struct sst_pdata *pdata);
 void sst_hsw_dsp_free(struct device *dev, struct sst_pdata *pdata);
 struct sst_dsp *sst_hsw_get_dsp(struct sst_hsw *hsw);
-
-/* fw module function */
-void sst_hsw_init_module_state(struct sst_hsw *hsw);
-bool sst_hsw_is_module_loaded(struct sst_hsw *hsw, u32 module_id);
-bool sst_hsw_is_module_active(struct sst_hsw *hsw, u32 module_id);
-void sst_hsw_set_module_enabled_rtd3(struct sst_hsw *hsw, u32 module_id);
-void sst_hsw_set_module_disabled_rtd3(struct sst_hsw *hsw, u32 module_id);
-bool sst_hsw_is_module_enabled_rtd3(struct sst_hsw *hsw, u32 module_id);
-void sst_hsw_reset_param_buf(struct sst_hsw *hsw);
-int sst_hsw_store_param_line(struct sst_hsw *hsw, u8 *buf);
-int sst_hsw_load_param_line(struct sst_hsw *hsw, u8 *buf);
-int sst_hsw_launch_param_buf(struct sst_hsw *hsw);
-
-int sst_hsw_module_load(struct sst_hsw *hsw,
-	u32 module_id, u32 instance_id, char *name);
-int sst_hsw_module_enable(struct sst_hsw *hsw,
-	u32 module_id, u32 instance_id);
-int sst_hsw_module_disable(struct sst_hsw *hsw,
-	u32 module_id, u32 instance_id);
-int sst_hsw_module_set_param(struct sst_hsw *hsw,
-	u32 module_id, u32 instance_id, u32 parameter_id,
-	u32 param_size, char *param);
+int sst_hsw_dbg_enable(struct sst_hsw *hsw,
+	struct dentry *debugfs_card_root);
 
 /* runtime module management */
 struct sst_module_runtime *sst_hsw_runtime_module_create(struct sst_hsw *hsw,
diff -Nru a/sound/soc/intel/haswell/sst-haswell-pcm.c b/sound/soc/intel/haswell/sst-haswell-pcm.c
--- a/sound/soc/intel/haswell/sst-haswell-pcm.c	2015-08-16 23:52:51.000000000 -0400
+++ b/sound/soc/intel/haswell/sst-haswell-pcm.c	2015-08-22 16:54:09.949983000 -0400
@@ -29,18 +29,14 @@
 #include <sound/tlv.h>
 #include <sound/compress_driver.h>
 
-#include "../haswell/sst-haswell-ipc.h"
+#include "sst-haswell-ipc.h"
 #include "../common/sst-dsp-priv.h"
 #include "../common/sst-dsp.h"
+#include "../common/sst-debugfs.h"
 
 #define HSW_PCM_COUNT		6
 #define HSW_VOLUME_MAX		0x7FFFFFFF	/* 0dB */
 
-#define SST_OLD_POSITION(d, r, o) ((d) +		\
-			frames_to_bytes(r, o))
-#define SST_SAMPLES(r, x) (bytes_to_samples(r,	\
-			frames_to_bytes(r, (x))))
-
 /* simple volume table */
 static const u32 volume_map[] = {
 	HSW_VOLUME_MAX >> 30,
@@ -83,6 +79,7 @@
 #define HSW_PCM_DAI_ID_OFFLOAD0	1
 #define HSW_PCM_DAI_ID_OFFLOAD1	2
 #define HSW_PCM_DAI_ID_LOOPBACK	3
+#define HSW_PCM_DAI_ID_CAPTURE	4
 
 
 static const struct snd_pcm_hardware hsw_pcm_hardware = {
@@ -91,8 +88,7 @@
 				  SNDRV_PCM_INFO_INTERLEAVED |
 				  SNDRV_PCM_INFO_PAUSE |
 				  SNDRV_PCM_INFO_RESUME |
-				  SNDRV_PCM_INFO_NO_PERIOD_WAKEUP |
-				  SNDRV_PCM_INFO_DRAIN_TRIGGER,
+				  SNDRV_PCM_INFO_NO_PERIOD_WAKEUP,
 	.formats		= SNDRV_PCM_FMTBIT_S16_LE | SNDRV_PCM_FMTBIT_S24_LE |
 				  SNDRV_PCM_FMTBIT_S32_LE,
 	.period_bytes_min	= PAGE_SIZE,
@@ -104,7 +100,6 @@
 
 struct hsw_pcm_module_map {
 	int dai_id;
-	int stream;
 	enum sst_hsw_module_id mod_id;
 };
 
@@ -137,23 +132,12 @@
 	struct device *dev;
 	enum hsw_pm_state pm_state;
 	struct snd_soc_card *soc_card;
-	struct sst_module_runtime *runtime_waves; /* sound effect module */
 
 	/* page tables */
 	struct snd_dma_buffer dmab[HSW_PCM_COUNT][2];
 
 	/* DAI data */
-	struct hsw_pcm_data pcm[HSW_PCM_COUNT][2];
-};
-
-
-/* static mappings between PCMs and modules - may be dynamic in future */
-static struct hsw_pcm_module_map mod_map[] = {
-	{HSW_PCM_DAI_ID_SYSTEM, 0, SST_HSW_MODULE_PCM_SYSTEM},
-	{HSW_PCM_DAI_ID_OFFLOAD0, 0, SST_HSW_MODULE_PCM},
-	{HSW_PCM_DAI_ID_OFFLOAD1, 0, SST_HSW_MODULE_PCM},
-	{HSW_PCM_DAI_ID_LOOPBACK, 1, SST_HSW_MODULE_PCM_REFERENCE},
-	{HSW_PCM_DAI_ID_SYSTEM, 1, SST_HSW_MODULE_PCM_CAPTURE},
+	struct hsw_pcm_data pcm[HSW_PCM_COUNT];
 };
 
 static u32 hsw_notify_pointer(struct sst_hsw_stream *stream, void *data);
@@ -186,14 +170,9 @@
 		(struct soc_mixer_control *)kcontrol->private_value;
 	struct hsw_priv_data *pdata =
 		snd_soc_platform_get_drvdata(platform);
-	struct hsw_pcm_data *pcm_data;
+	struct hsw_pcm_data *pcm_data = &pdata->pcm[mc->reg];
 	struct sst_hsw *hsw = pdata->hsw;
 	u32 volume;
-	int dai, stream;
-
-	dai = mod_map[mc->reg].dai_id;
-	stream = mod_map[mc->reg].stream;
-	pcm_data = &pdata->pcm[dai][stream];
 
 	mutex_lock(&pcm_data->mutex);
 	pm_runtime_get_sync(pdata->dev);
@@ -212,8 +191,7 @@
 	if (ucontrol->value.integer.value[0] ==
 		ucontrol->value.integer.value[1]) {
 		volume = hsw_mixer_to_ipc(ucontrol->value.integer.value[0]);
-		/* apply volume value to all channels */
-		sst_hsw_stream_set_volume(hsw, pcm_data->stream, 0, SST_HSW_CHANNELS_ALL, volume);
+		sst_hsw_stream_set_volume(hsw, pcm_data->stream, 0, 2, volume);
 	} else {
 		volume = hsw_mixer_to_ipc(ucontrol->value.integer.value[0]);
 		sst_hsw_stream_set_volume(hsw, pcm_data->stream, 0, 0, volume);
@@ -235,14 +213,9 @@
 		(struct soc_mixer_control *)kcontrol->private_value;
 	struct hsw_priv_data *pdata =
 		snd_soc_platform_get_drvdata(platform);
-	struct hsw_pcm_data *pcm_data;
+	struct hsw_pcm_data *pcm_data = &pdata->pcm[mc->reg];
 	struct sst_hsw *hsw = pdata->hsw;
 	u32 volume;
-	int dai, stream;
-
-	dai = mod_map[mc->reg].dai_id;
-	stream = mod_map[mc->reg].stream;
-	pcm_data = &pdata->pcm[dai][stream];
 
 	mutex_lock(&pcm_data->mutex);
 	pm_runtime_get_sync(pdata->dev);
@@ -284,7 +257,7 @@
 		ucontrol->value.integer.value[1]) {
 
 		volume = hsw_mixer_to_ipc(ucontrol->value.integer.value[0]);
-		sst_hsw_mixer_set_volume(hsw, 0, SST_HSW_CHANNELS_ALL, volume);
+		sst_hsw_mixer_set_volume(hsw, 0, 2, volume);
 
 	} else {
 		volume = hsw_mixer_to_ipc(ucontrol->value.integer.value[0]);
@@ -319,93 +292,6 @@
 	return 0;
 }
 
-static int hsw_waves_switch_get(struct snd_kcontrol *kcontrol,
-				struct snd_ctl_elem_value *ucontrol)
-{
-	struct snd_soc_platform *platform = snd_soc_kcontrol_platform(kcontrol);
-	struct hsw_priv_data *pdata = snd_soc_platform_get_drvdata(platform);
-	struct sst_hsw *hsw = pdata->hsw;
-	enum sst_hsw_module_id id = SST_HSW_MODULE_WAVES;
-
-	ucontrol->value.integer.value[0] =
-		(sst_hsw_is_module_active(hsw, id) ||
-		sst_hsw_is_module_enabled_rtd3(hsw, id));
-	return 0;
-}
-
-static int hsw_waves_switch_put(struct snd_kcontrol *kcontrol,
-				struct snd_ctl_elem_value *ucontrol)
-{
-	struct snd_soc_platform *platform = snd_soc_kcontrol_platform(kcontrol);
-	struct hsw_priv_data *pdata = snd_soc_platform_get_drvdata(platform);
-	struct sst_hsw *hsw = pdata->hsw;
-	int ret = 0;
-	enum sst_hsw_module_id id = SST_HSW_MODULE_WAVES;
-	bool switch_on = (bool)ucontrol->value.integer.value[0];
-
-	/* if module is in RAM on the DSP, apply user settings to module through
-	 * ipc. If module is not in RAM on the DSP, store user setting for
-	 * track */
-	if (sst_hsw_is_module_loaded(hsw, id)) {
-		if (switch_on == sst_hsw_is_module_active(hsw, id))
-			return 0;
-
-		if (switch_on)
-			ret = sst_hsw_module_enable(hsw, id, 0);
-		else
-			ret = sst_hsw_module_disable(hsw, id, 0);
-	} else {
-		if (switch_on == sst_hsw_is_module_enabled_rtd3(hsw, id))
-			return 0;
-
-		if (switch_on)
-			sst_hsw_set_module_enabled_rtd3(hsw, id);
-		else
-			sst_hsw_set_module_disabled_rtd3(hsw, id);
-	}
-
-	return ret;
-}
-
-static int hsw_waves_param_get(struct snd_kcontrol *kcontrol,
-				struct snd_ctl_elem_value *ucontrol)
-{
-	struct snd_soc_platform *platform = snd_soc_kcontrol_platform(kcontrol);
-	struct hsw_priv_data *pdata = snd_soc_platform_get_drvdata(platform);
-	struct sst_hsw *hsw = pdata->hsw;
-
-	/* return a matching line from param buffer */
-	return sst_hsw_load_param_line(hsw, ucontrol->value.bytes.data);
-}
-
-static int hsw_waves_param_put(struct snd_kcontrol *kcontrol,
-				struct snd_ctl_elem_value *ucontrol)
-{
-	struct snd_soc_platform *platform = snd_soc_kcontrol_platform(kcontrol);
-	struct hsw_priv_data *pdata = snd_soc_platform_get_drvdata(platform);
-	struct sst_hsw *hsw = pdata->hsw;
-	int ret;
-	enum sst_hsw_module_id id = SST_HSW_MODULE_WAVES;
-	int param_id = ucontrol->value.bytes.data[0];
-	int param_size = WAVES_PARAM_COUNT;
-
-	/* clear param buffer and reset buffer index */
-	if (param_id == 0xFF) {
-		sst_hsw_reset_param_buf(hsw);
-		return 0;
-	}
-
-	/* store params into buffer */
-	ret = sst_hsw_store_param_line(hsw, ucontrol->value.bytes.data);
-	if (ret < 0)
-		return ret;
-
-	if (sst_hsw_is_module_active(hsw, id))
-		ret = sst_hsw_module_set_param(hsw, id, 0, param_id,
-				param_size, ucontrol->value.bytes.data);
-	return ret;
-}
-
 /* TLV used by both global and stream volumes */
 static const DECLARE_TLV_DB_SCALE(hsw_vol_tlv, -9000, 300, 1);
 
@@ -413,26 +299,24 @@
 static const struct snd_kcontrol_new hsw_volume_controls[] = {
 	/* Global DSP volume */
 	SOC_DOUBLE_EXT_TLV("Master Playback Volume", 0, 0, 8,
-		ARRAY_SIZE(volume_map) - 1, 0,
+		ARRAY_SIZE(volume_map) -1, 0,
 		hsw_volume_get, hsw_volume_put, hsw_vol_tlv),
 	/* Offload 0 volume */
 	SOC_DOUBLE_EXT_TLV("Media0 Playback Volume", 1, 0, 8,
-		ARRAY_SIZE(volume_map) - 1, 0,
+		ARRAY_SIZE(volume_map), 0,
 		hsw_stream_volume_get, hsw_stream_volume_put, hsw_vol_tlv),
 	/* Offload 1 volume */
 	SOC_DOUBLE_EXT_TLV("Media1 Playback Volume", 2, 0, 8,
-		ARRAY_SIZE(volume_map) - 1, 0,
+		ARRAY_SIZE(volume_map), 0,
+		hsw_stream_volume_get, hsw_stream_volume_put, hsw_vol_tlv),
+	/* Loopback volume */
+	SOC_DOUBLE_EXT_TLV("Loopback Capture Volume", 3, 0, 8,
+		ARRAY_SIZE(volume_map), 0,
 		hsw_stream_volume_get, hsw_stream_volume_put, hsw_vol_tlv),
 	/* Mic Capture volume */
 	SOC_DOUBLE_EXT_TLV("Mic Capture Volume", 4, 0, 8,
-		ARRAY_SIZE(volume_map) - 1, 0,
+		ARRAY_SIZE(volume_map), 0,
 		hsw_stream_volume_get, hsw_stream_volume_put, hsw_vol_tlv),
-	/* enable/disable module waves */
-	SOC_SINGLE_BOOL_EXT("Waves Switch", 0,
-		hsw_waves_switch_get, hsw_waves_switch_put),
-	/* set parameters to module waves */
-	SND_SOC_BYTES_EXT("Waves Set Param", WAVES_PARAM_COUNT,
-		hsw_waves_param_get, hsw_waves_param_put),
 };
 
 /* Create DMA buffer page table for DSP */
@@ -474,7 +358,7 @@
 	struct snd_pcm_runtime *runtime = substream->runtime;
 	struct hsw_priv_data *pdata =
 		snd_soc_platform_get_drvdata(rtd->platform);
-	struct hsw_pcm_data *pcm_data;
+	struct hsw_pcm_data *pcm_data = snd_soc_pcm_get_drvdata(rtd);
 	struct sst_hsw *hsw = pdata->hsw;
 	struct sst_module *module_data;
 	struct sst_dsp *dsp;
@@ -483,10 +367,7 @@
 	enum sst_hsw_stream_path_id path_id;
 	u32 rate, bits, map, pages, module_id;
 	u8 channels;
-	int ret, dai;
-
-	dai = mod_map[rtd->cpu_dai->id].dai_id;
-	pcm_data = &pdata->pcm[dai][substream->stream];
+	int ret;
 
 	/* check if we are being called a subsequent time */
 	if (pcm_data->allocated) {
@@ -520,14 +401,8 @@
 	/* DSP stream type depends on DAI ID */
 	switch (rtd->cpu_dai->id) {
 	case 0:
-		if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK) {
-			stream_type = SST_HSW_STREAM_TYPE_SYSTEM;
-			module_id = SST_HSW_MODULE_PCM_SYSTEM;
-		}
-		else {
-			stream_type = SST_HSW_STREAM_TYPE_CAPTURE;
-			module_id = SST_HSW_MODULE_PCM_CAPTURE;
-		}
+		stream_type = SST_HSW_STREAM_TYPE_SYSTEM;
+		module_id = SST_HSW_MODULE_PCM_SYSTEM;
 		break;
 	case 1:
 	case 2:
@@ -540,6 +415,10 @@
 		path_id = SST_HSW_STREAM_PATH_SSP0_OUT;
 		module_id = SST_HSW_MODULE_PCM_REFERENCE;
 		break;
+	case 4:
+		stream_type = SST_HSW_STREAM_TYPE_CAPTURE;
+		module_id = SST_HSW_MODULE_PCM_CAPTURE;
+		break;
 	default:
 		dev_err(rtd->dev, "error: invalid DAI ID %d\n",
 			rtd->cpu_dai->id);
@@ -648,20 +527,18 @@
 		dev_err(rtd->dev, "error: failed to commit stream %d\n", ret);
 		return ret;
 	}
-
-	if (!pcm_data->allocated) {
-		/* Set previous saved volume */
-		sst_hsw_stream_set_volume(hsw, pcm_data->stream, 0,
-				0, pcm_data->volume[0]);
-		sst_hsw_stream_set_volume(hsw, pcm_data->stream, 0,
-				1, pcm_data->volume[1]);
-		pcm_data->allocated = true;
-	}
+	pcm_data->allocated = true;
 
 	ret = sst_hsw_stream_pause(hsw, pcm_data->stream, 1);
 	if (ret < 0)
 		dev_err(rtd->dev, "error: failed to pause %d\n", ret);
 
+	/* Set previous saved volume */
+	sst_hsw_stream_set_volume(hsw, pcm_data->stream, 0,
+			0, pcm_data->volume[0]);
+	sst_hsw_stream_set_volume(hsw, pcm_data->stream, 0,
+			1, pcm_data->volume[1]);
+
 	return 0;
 }
 
@@ -676,35 +553,20 @@
 	struct snd_soc_pcm_runtime *rtd = substream->private_data;
 	struct hsw_priv_data *pdata =
 		snd_soc_platform_get_drvdata(rtd->platform);
-	struct hsw_pcm_data *pcm_data;
-	struct sst_hsw_stream *sst_stream;
+	struct hsw_pcm_data *pcm_data = snd_soc_pcm_get_drvdata(rtd);
 	struct sst_hsw *hsw = pdata->hsw;
-	struct snd_pcm_runtime *runtime = substream->runtime;
-	snd_pcm_uframes_t pos;
-	int dai;
-
-	dai = mod_map[rtd->cpu_dai->id].dai_id;
-	pcm_data = &pdata->pcm[dai][substream->stream];
-	sst_stream = pcm_data->stream;
 
 	switch (cmd) {
-	case SNDRV_PCM_TRIGGER_START:
 	case SNDRV_PCM_TRIGGER_RESUME:
+	case SNDRV_PCM_TRIGGER_START:
 	case SNDRV_PCM_TRIGGER_PAUSE_RELEASE:
-		sst_hsw_stream_set_silence_start(hsw, sst_stream, false);
 		sst_hsw_stream_resume(hsw, pcm_data->stream, 0);
 		break;
 	case SNDRV_PCM_TRIGGER_STOP:
-	case SNDRV_PCM_TRIGGER_SUSPEND:
 	case SNDRV_PCM_TRIGGER_PAUSE_PUSH:
-		sst_hsw_stream_set_silence_start(hsw, sst_stream, false);
+	case SNDRV_PCM_TRIGGER_SUSPEND:
 		sst_hsw_stream_pause(hsw, pcm_data->stream, 0);
 		break;
-	case SNDRV_PCM_TRIGGER_DRAIN:
-		pos = runtime->control->appl_ptr % runtime->buffer_size;
-		sst_hsw_stream_set_old_position(hsw, pcm_data->stream, pos);
-		sst_hsw_stream_set_silence_start(hsw, sst_stream, true);
-		break;
 	default:
 		break;
 	}
@@ -718,62 +580,13 @@
 	struct snd_pcm_substream *substream = pcm_data->substream;
 	struct snd_pcm_runtime *runtime = substream->runtime;
 	struct snd_soc_pcm_runtime *rtd = substream->private_data;
-	struct hsw_priv_data *pdata =
-		snd_soc_platform_get_drvdata(rtd->platform);
-	struct sst_hsw *hsw = pdata->hsw;
 	u32 pos;
-	snd_pcm_uframes_t position = bytes_to_frames(runtime,
-		 sst_hsw_get_dsp_position(hsw, pcm_data->stream));
-	unsigned char *dma_area = runtime->dma_area;
-	snd_pcm_uframes_t dma_frames =
-		bytes_to_frames(runtime, runtime->dma_bytes);
-	snd_pcm_uframes_t old_position;
-	ssize_t samples;
 
 	pos = frames_to_bytes(runtime,
 		(runtime->control->appl_ptr % runtime->buffer_size));
 
 	dev_vdbg(rtd->dev, "PCM: App pointer %d bytes\n", pos);
 
-	/* SST fw don't know where to stop dma
-	 * So, SST driver need to clean the data which has been consumed
-	 */
-	if (dma_area == NULL || dma_frames <= 0
-		|| (substream->stream == SNDRV_PCM_STREAM_CAPTURE)
-		|| !sst_hsw_stream_get_silence_start(hsw, stream)) {
-		snd_pcm_period_elapsed(substream);
-		return pos;
-	}
-
-	old_position = sst_hsw_stream_get_old_position(hsw, stream);
-	if (position > old_position) {
-		if (position < dma_frames) {
-			samples = SST_SAMPLES(runtime, position - old_position);
-			snd_pcm_format_set_silence(runtime->format,
-				SST_OLD_POSITION(dma_area,
-					runtime, old_position),
-				samples);
-		} else
-			dev_err(rtd->dev, "PCM: position is wrong\n");
-	} else {
-		if (old_position < dma_frames) {
-			samples = SST_SAMPLES(runtime,
-				dma_frames - old_position);
-			snd_pcm_format_set_silence(runtime->format,
-				SST_OLD_POSITION(dma_area,
-					runtime, old_position),
-				samples);
-		} else
-			dev_err(rtd->dev, "PCM: dma_bytes is wrong\n");
-		if (position < dma_frames) {
-			samples = SST_SAMPLES(runtime, position);
-			snd_pcm_format_set_silence(runtime->format,
-				dma_area, samples);
-		} else
-			dev_err(rtd->dev, "PCM: position is wrong\n");
-	}
-	sst_hsw_stream_set_old_position(hsw, stream, position);
-
 	/* let alsa know we have play a period */
 	snd_pcm_period_elapsed(substream);
 	return pos;
@@ -785,16 +598,11 @@
 	struct snd_pcm_runtime *runtime = substream->runtime;
 	struct hsw_priv_data *pdata =
 		snd_soc_platform_get_drvdata(rtd->platform);
-	struct hsw_pcm_data *pcm_data;
+	struct hsw_pcm_data *pcm_data = snd_soc_pcm_get_drvdata(rtd);
 	struct sst_hsw *hsw = pdata->hsw;
 	snd_pcm_uframes_t offset;
 	uint64_t ppos;
-	u32 position;
-	int dai;
-
-	dai = mod_map[rtd->cpu_dai->id].dai_id;
-	pcm_data = &pdata->pcm[dai][substream->stream];
-	position = sst_hsw_get_dsp_position(hsw, pcm_data->stream);
+	u32 position = sst_hsw_get_dsp_position(hsw, pcm_data->stream);
 
 	offset = bytes_to_frames(runtime, position);
 	ppos = sst_hsw_get_dsp_presentation_position(hsw, pcm_data->stream);
@@ -811,10 +619,8 @@
 		snd_soc_platform_get_drvdata(rtd->platform);
 	struct hsw_pcm_data *pcm_data;
 	struct sst_hsw *hsw = pdata->hsw;
-	int dai;
 
-	dai = mod_map[rtd->cpu_dai->id].dai_id;
-	pcm_data = &pdata->pcm[dai][substream->stream];
+	pcm_data = &pdata->pcm[rtd->cpu_dai->id];
 
 	mutex_lock(&pcm_data->mutex);
 	pm_runtime_get_sync(pdata->dev);
@@ -843,12 +649,9 @@
 	struct snd_soc_pcm_runtime *rtd = substream->private_data;
 	struct hsw_priv_data *pdata =
 		snd_soc_platform_get_drvdata(rtd->platform);
-	struct hsw_pcm_data *pcm_data;
+	struct hsw_pcm_data *pcm_data = snd_soc_pcm_get_drvdata(rtd);
 	struct sst_hsw *hsw = pdata->hsw;
-	int ret, dai;
-
-	dai = mod_map[rtd->cpu_dai->id].dai_id;
-	pcm_data = &pdata->pcm[dai][substream->stream];
+	int ret;
 
 	mutex_lock(&pcm_data->mutex);
 	ret = sst_hsw_stream_reset(hsw, pcm_data->stream);
@@ -883,6 +686,15 @@
 	.page		= snd_pcm_sgbuf_ops_page,
 };
 
+/* static mappings between PCMs and modules - may be dynamic in future */
+static struct hsw_pcm_module_map mod_map[] = {
+	{HSW_PCM_DAI_ID_SYSTEM, SST_HSW_MODULE_PCM_SYSTEM},
+	{HSW_PCM_DAI_ID_OFFLOAD0, SST_HSW_MODULE_PCM},
+	{HSW_PCM_DAI_ID_OFFLOAD1, SST_HSW_MODULE_PCM},
+	{HSW_PCM_DAI_ID_LOOPBACK, SST_HSW_MODULE_PCM_REFERENCE},
+	{HSW_PCM_DAI_ID_CAPTURE, SST_HSW_MODULE_PCM_CAPTURE},
+};
+
 static int hsw_pcm_create_modules(struct hsw_priv_data *pdata)
 {
 	struct sst_hsw *hsw = pdata->hsw;
@@ -890,7 +702,7 @@
 	int i;
 
 	for (i = 0; i < ARRAY_SIZE(mod_map); i++) {
-		pcm_data = &pdata->pcm[mod_map[i].dai_id][mod_map[i].stream];
+		pcm_data = &pdata->pcm[i];
 
 		/* create new runtime module, use same offset if recreated */
 		pcm_data->runtime = sst_hsw_runtime_module_create(hsw,
@@ -901,19 +713,11 @@
 			pcm_data->runtime->persistent_offset;
 	}
 
-	/* create runtime blocks for module waves */
-	if (sst_hsw_is_module_loaded(hsw, SST_HSW_MODULE_WAVES)) {
-		pdata->runtime_waves = sst_hsw_runtime_module_create(hsw,
-			SST_HSW_MODULE_WAVES, 0);
-		if (pdata->runtime_waves == NULL)
-			goto err;
-	}
-
 	return 0;
 
 err:
 	for (--i; i >= 0; i--) {
-		pcm_data = &pdata->pcm[mod_map[i].dai_id][mod_map[i].stream];
+		pcm_data = &pdata->pcm[i];
 		sst_hsw_runtime_module_free(pcm_data->runtime);
 	}
 
@@ -922,17 +726,19 @@
 
 static void hsw_pcm_free_modules(struct hsw_priv_data *pdata)
 {
-	struct sst_hsw *hsw = pdata->hsw;
 	struct hsw_pcm_data *pcm_data;
 	int i;
 
 	for (i = 0; i < ARRAY_SIZE(mod_map); i++) {
-		pcm_data = &pdata->pcm[mod_map[i].dai_id][mod_map[i].stream];
+		pcm_data = &pdata->pcm[i];
+
 		sst_hsw_runtime_module_free(pcm_data->runtime);
 	}
-	if (sst_hsw_is_module_loaded(hsw, SST_HSW_MODULE_WAVES)) {
-		sst_hsw_runtime_module_free(pdata->runtime_waves);
-	}
+}
+
+static void hsw_pcm_free(struct snd_pcm *pcm)
+{
+	snd_pcm_lib_preallocate_free_for_all(pcm);
 }
 
 static int hsw_pcm_new(struct snd_soc_pcm_runtime *rtd)
@@ -957,10 +763,7 @@
 			return ret;
 		}
 	}
-	if (pcm->streams[SNDRV_PCM_STREAM_PLAYBACK].substream)
-		priv_data->pcm[rtd->cpu_dai->id][SNDRV_PCM_STREAM_PLAYBACK].hsw_pcm = pcm;
-	if (pcm->streams[SNDRV_PCM_STREAM_CAPTURE].substream)
-		priv_data->pcm[rtd->cpu_dai->id][SNDRV_PCM_STREAM_CAPTURE].hsw_pcm = pcm;
+	priv_data->pcm[rtd->cpu_dai->id].hsw_pcm = pcm;
 
 	return ret;
 }
@@ -979,13 +782,6 @@
 			.rates = SNDRV_PCM_RATE_48000,
 			.formats = SNDRV_PCM_FMTBIT_S24_LE | SNDRV_PCM_FMTBIT_S16_LE,
 		},
-		.capture = {
-			.stream_name = "Analog Capture",
-			.channels_min = 2,
-			.channels_max = 4,
-			.rates = SNDRV_PCM_RATE_48000,
-			.formats = SNDRV_PCM_FMTBIT_S24_LE | SNDRV_PCM_FMTBIT_S16_LE,
-		},
 	},
 	{
 		/* PCM */
@@ -1022,6 +818,17 @@
 			.formats = SNDRV_PCM_FMTBIT_S24_LE | SNDRV_PCM_FMTBIT_S16_LE,
 		},
 	},
+	{
+		.name  = "Capture Pin",
+		.id = HSW_PCM_DAI_ID_CAPTURE,
+		.capture = {
+			.stream_name = "Analog Capture",
+			.channels_min = 2,
+			.channels_max = 4,
+			.rates = SNDRV_PCM_RATE_48000,
+			.formats = SNDRV_PCM_FMTBIT_S24_LE | SNDRV_PCM_FMTBIT_S16_LE,
+		},
+	},
 };
 
 static const struct snd_soc_dapm_widget widgets[] = {
@@ -1050,8 +857,8 @@
 
 static int hsw_pcm_probe(struct snd_soc_platform *platform)
 {
-	struct hsw_priv_data *priv_data = snd_soc_platform_get_drvdata(platform);
 	struct sst_pdata *pdata = dev_get_platdata(platform->dev);
+	struct hsw_priv_data *priv_data;
 	struct device *dma_dev, *dev;
 	int i, ret = 0;
 
@@ -1061,17 +868,20 @@
 	dev = platform->dev;
 	dma_dev = pdata->dma_dev;
 
+	priv_data = devm_kzalloc(platform->dev, sizeof(*priv_data), GFP_KERNEL);
 	priv_data->hsw = pdata->dsp;
 	priv_data->dev = platform->dev;
 	priv_data->pm_state = HSW_PM_STATE_D0;
 	priv_data->soc_card = platform->component.card;
+	snd_soc_platform_set_drvdata(platform, priv_data);
 
 	/* allocate DSP buffer page tables */
 	for (i = 0; i < ARRAY_SIZE(hsw_dais); i++) {
 
+		mutex_init(&priv_data->pcm[i].mutex);
+
 		/* playback */
 		if (hsw_dais[i].playback.channels_min) {
-			mutex_init(&priv_data->pcm[i][SNDRV_PCM_STREAM_PLAYBACK].mutex);
 			ret = snd_dma_alloc_pages(SNDRV_DMA_TYPE_DEV, dma_dev,
 				PAGE_SIZE, &priv_data->dmab[i][0]);
 			if (ret < 0)
@@ -1080,7 +890,6 @@
 
 		/* capture */
 		if (hsw_dais[i].capture.channels_min) {
-			mutex_init(&priv_data->pcm[i][SNDRV_PCM_STREAM_CAPTURE].mutex);
 			ret = snd_dma_alloc_pages(SNDRV_DMA_TYPE_DEV, dma_dev,
 				PAGE_SIZE, &priv_data->dmab[i][1]);
 			if (ret < 0)
@@ -1089,9 +898,7 @@
 	}
 
 	/* allocate runtime modules */
-	ret = hsw_pcm_create_modules(priv_data);
-	if (ret < 0)
-		goto err;
+	hsw_pcm_create_modules(priv_data);
 
 	/* enable runtime PM with auto suspend */
 	pm_runtime_set_autosuspend_delay(platform->dev,
@@ -1103,7 +910,7 @@
 	return 0;
 
 err:
-	for (--i; i >= 0; i--) {
+	for (;i >= 0; i--) {
 		if (hsw_dais[i].playback.channels_min)
 			snd_dma_free_pages(&priv_data->dmab[i][0]);
 		if (hsw_dais[i].capture.channels_min)
@@ -1136,38 +943,30 @@
 	.remove		= hsw_pcm_remove,
 	.ops		= &hsw_pcm_ops,
 	.pcm_new	= hsw_pcm_new,
+	.pcm_free	= hsw_pcm_free,
+	.controls	= hsw_volume_controls,
+	.num_controls	= ARRAY_SIZE(hsw_volume_controls),
+	.dapm_widgets	= widgets,
+	.num_dapm_widgets	= ARRAY_SIZE(widgets),
+	.dapm_routes	= graph,
+	.num_dapm_routes	= ARRAY_SIZE(graph),
 };
 
 static const struct snd_soc_component_driver hsw_dai_component = {
-	.name = "haswell-dai",
-	.controls = hsw_volume_controls,
-	.num_controls = ARRAY_SIZE(hsw_volume_controls),
-	.dapm_widgets = widgets,
-	.num_dapm_widgets = ARRAY_SIZE(widgets),
-	.dapm_routes = graph,
-	.num_dapm_routes = ARRAY_SIZE(graph),
+	.name		= "haswell-dai",
 };
 
 static int hsw_pcm_dev_probe(struct platform_device *pdev)
 {
 	struct sst_pdata *sst_pdata = dev_get_platdata(&pdev->dev);
 	struct hsw_priv_data *priv_data;
+	struct dentry root;
 	int ret;
 
-	if (!sst_pdata)
-		return -EINVAL;
-
-	priv_data = devm_kzalloc(&pdev->dev, sizeof(*priv_data), GFP_KERNEL);
-	if (!priv_data)
-		return -ENOMEM;
-
 	ret = sst_hsw_dsp_init(&pdev->dev, sst_pdata);
 	if (ret < 0)
 		return -ENODEV;
 
-	priv_data->hsw = sst_pdata->dsp;
-	platform_set_drvdata(pdev, priv_data);
-
 	ret = snd_soc_register_platform(&pdev->dev, &hsw_soc_platform);
 	if (ret < 0)
 		goto err_plat;
@@ -1177,6 +976,12 @@
 	if (ret < 0)
 		goto err_comp;
 
+#ifdef CONFIG_DEBUG_FS
+	priv_data->hsw = sst_pdata->dsp;
+	sst_debugfs_get_root(&root);
+	sst_hsw_dbg_enable(priv_data->hsw, &root);
+#endif
+
 	return 0;
 
 err_comp:
@@ -1208,18 +1013,10 @@
 {
 	struct hsw_priv_data *pdata = dev_get_drvdata(dev);
 	struct sst_hsw *hsw = pdata->hsw;
-	int ret;
 
 	if (pdata->pm_state >= HSW_PM_STATE_RTD3)
 		return 0;
 
-	/* fw modules will be unloaded on RTD3, set flag to track */
-	if (sst_hsw_is_module_active(hsw, SST_HSW_MODULE_WAVES)) {
-		ret = sst_hsw_module_disable(hsw, SST_HSW_MODULE_WAVES, 0);
-		if (ret < 0)
-			return ret;
-		sst_hsw_set_module_enabled_rtd3(hsw, SST_HSW_MODULE_WAVES);
-	}
 	sst_hsw_dsp_runtime_suspend(hsw);
 	sst_hsw_dsp_runtime_sleep(hsw);
 	pdata->pm_state = HSW_PM_STATE_RTD3;
@@ -1254,31 +1051,10 @@
 	else if (ret == 1) /* no action required */
 		return 0;
 
-	/* check flag when resume */
-	if (sst_hsw_is_module_enabled_rtd3(hsw, SST_HSW_MODULE_WAVES)) {
-		ret = sst_hsw_module_enable(hsw, SST_HSW_MODULE_WAVES, 0);
-		if (ret < 0)
-			return ret;
-		/* put parameters from buffer to dsp */
-		ret = sst_hsw_launch_param_buf(hsw);
-		if (ret < 0)
-			return ret;
-		/* unset flag */
-		sst_hsw_set_module_disabled_rtd3(hsw, SST_HSW_MODULE_WAVES);
-	}
-
 	pdata->pm_state = HSW_PM_STATE_D0;
 	return ret;
 }
 
-#else
-#define hsw_pcm_runtime_idle		NULL
-#define hsw_pcm_runtime_suspend		NULL
-#define hsw_pcm_runtime_resume		NULL
-#endif
-
-#ifdef CONFIG_PM
-
 static void hsw_pcm_complete(struct device *dev)
 {
 	struct hsw_priv_data *pdata = dev_get_drvdata(dev);
@@ -1301,8 +1077,8 @@
 		return;
 	}
 
-	for (i = 0; i < ARRAY_SIZE(mod_map); i++) {
-		pcm_data = &pdata->pcm[mod_map[i].dai_id][mod_map[i].stream];
+	for (i = 0; i < HSW_PCM_DAI_ID_CAPTURE + 1; i++) {
+		pcm_data = &pdata->pcm[i];
 
 		if (!pcm_data->substream)
 			continue;
@@ -1336,8 +1112,8 @@
 		return 0;
 	else if (pdata->pm_state == HSW_PM_STATE_D0) {
 		/* suspend all active streams */
-		for (i = 0; i < ARRAY_SIZE(mod_map); i++) {
-			pcm_data = &pdata->pcm[mod_map[i].dai_id][mod_map[i].stream];
+		for (i = 0; i < HSW_PCM_DAI_ID_CAPTURE + 1; i++) {
+			pcm_data = &pdata->pcm[i];
 
 			if (!pcm_data->substream)
 				continue;
@@ -1349,8 +1125,8 @@
 		}
 
 		/* preserve persistent memory */
-		for (i = 0; i < ARRAY_SIZE(mod_map); i++) {
-			pcm_data = &pdata->pcm[mod_map[i].dai_id][mod_map[i].stream];
+		for (i = 0; i < HSW_PCM_DAI_ID_CAPTURE + 1; i++) {
+			pcm_data = &pdata->pcm[i];
 
 			if (!pcm_data->substream)
 				continue;
@@ -1375,11 +1151,6 @@
 	return 0;
 }
 
-#else
-#define hsw_pcm_prepare		NULL
-#define hsw_pcm_complete	NULL
-#endif
-
 static const struct dev_pm_ops hsw_pcm_pm = {
 	.runtime_idle = hsw_pcm_runtime_idle,
 	.runtime_suspend = hsw_pcm_runtime_suspend,
@@ -1387,11 +1158,16 @@
 	.prepare = hsw_pcm_prepare,
 	.complete = hsw_pcm_complete,
 };
+#else
+#define hsw_pcm_pm	NULL
+#endif
 
 static struct platform_driver hsw_pcm_driver = {
 	.driver = {
 		.name = "haswell-pcm-audio",
+		.owner = THIS_MODULE,
 		.pm = &hsw_pcm_pm,
+
 	},
 
 	.probe = hsw_pcm_dev_probe,
diff -Nru a/sound/soc/soc-cache.c b/sound/soc/soc-cache.c
--- a/sound/soc/soc-cache.c	2015-08-16 23:52:51.000000000 -0400
+++ b/sound/soc/soc-cache.c	2015-08-22 16:54:09.949983000 -0400
@@ -15,6 +15,56 @@
 #include <linux/export.h>
 #include <linux/slab.h>
 
+#include <trace/events/asoc.h>
+
+static bool snd_soc_set_cache_val(void *base, unsigned int idx,
+				  unsigned int val, unsigned int word_size)
+{
+	switch (word_size) {
+	case 1: {
+		u8 *cache = base;
+		if (cache[idx] == val)
+			return true;
+		cache[idx] = val;
+		break;
+	}
+	case 2: {
+		u16 *cache = base;
+		if (cache[idx] == val)
+			return true;
+		cache[idx] = val;
+		break;
+	}
+	default:
+		WARN(1, "Invalid word_size %d\n", word_size);
+		break;
+	}
+	return false;
+}
+
+static unsigned int snd_soc_get_cache_val(const void *base, unsigned int idx,
+		unsigned int word_size)
+{
+	if (!base)
+		return -1;
+
+	switch (word_size) {
+	case 1: {
+		const u8 *cache = base;
+		return cache[idx];
+	}
+	case 2: {
+		const u16 *cache = base;
+		return cache[idx];
+	}
+	default:
+		WARN(1, "Invalid word_size %d\n", word_size);
+		break;
+	}
+	/* unreachable */
+	return -1;
+}
+
 int snd_soc_cache_init(struct snd_soc_codec *codec)
 {
 	const struct snd_soc_codec_driver *codec_drv = codec->driver;
@@ -25,6 +75,8 @@
 	if (!reg_size)
 		return 0;
 
+	mutex_init(&codec->cache_rw_mutex);
+
 	dev_dbg(codec->dev, "ASoC: Initializing cache for %s codec\n",
 				codec->component.name);
 
@@ -51,3 +103,100 @@
 	codec->reg_cache = NULL;
 	return 0;
 }
+
+/**
+ * snd_soc_cache_read: Fetch the value of a given register from the cache.
+ *
+ * @codec: CODEC to configure.
+ * @reg: The register index.
+ * @value: The value to be returned.
+ */
+int snd_soc_cache_read(struct snd_soc_codec *codec,
+		       unsigned int reg, unsigned int *value)
+{
+	if (!value)
+		return -EINVAL;
+
+	mutex_lock(&codec->cache_rw_mutex);
+	if (!ZERO_OR_NULL_PTR(codec->reg_cache))
+		*value = snd_soc_get_cache_val(codec->reg_cache, reg,
+					       codec->driver->reg_word_size);
+	mutex_unlock(&codec->cache_rw_mutex);
+
+	return 0;
+}
+EXPORT_SYMBOL_GPL(snd_soc_cache_read);
+
+/**
+ * snd_soc_cache_write: Set the value of a given register in the cache.
+ *
+ * @codec: CODEC to configure.
+ * @reg: The register index.
+ * @value: The new register value.
+ */
+int snd_soc_cache_write(struct snd_soc_codec *codec,
+			unsigned int reg, unsigned int value)
+{
+	mutex_lock(&codec->cache_rw_mutex);
+	if (!ZERO_OR_NULL_PTR(codec->reg_cache))
+		snd_soc_set_cache_val(codec->reg_cache, reg, value,
+				      codec->driver->reg_word_size);
+	mutex_unlock(&codec->cache_rw_mutex);
+
+	return 0;
+}
+EXPORT_SYMBOL_GPL(snd_soc_cache_write);
+
+static int snd_soc_flat_cache_sync(struct snd_soc_codec *codec)
+{
+	int i;
+	int ret;
+	const struct snd_soc_codec_driver *codec_drv;
+	unsigned int val;
+
+	codec_drv = codec->driver;
+	for (i = 0; i < codec_drv->reg_cache_size; ++i) {
+		ret = snd_soc_cache_read(codec, i, &val);
+		if (ret)
+			return ret;
+		if (codec_drv->reg_cache_default)
+			if (snd_soc_get_cache_val(codec_drv->reg_cache_default,
+						  i, codec_drv->reg_word_size) == val)
+				continue;
+
+		ret = snd_soc_write(codec, i, val);
+		if (ret)
+			return ret;
+		dev_dbg(codec->dev, "ASoC: Synced register %#x, value = %#x\n",
+			i, val);
+	}
+	return 0;
+}
+
+/**
+ * snd_soc_cache_sync: Sync the register cache with the hardware.
+ *
+ * @codec: CODEC to configure.
+ *
+ * Any registers that should not be synced should be marked as
+ * volatile.  In general drivers can choose not to use the provided
+ * syncing functionality if they so require.
+ */
+int snd_soc_cache_sync(struct snd_soc_codec *codec)
+{
+	const char *name = "flat";
+	int ret;
+
+	if (!codec->cache_sync)
+		return 0;
+
+	dev_dbg(codec->dev, "ASoC: Syncing cache for %s codec\n",
+		codec->component.name);
+	trace_snd_soc_cache_sync(codec, name, "start");
+	ret = snd_soc_flat_cache_sync(codec);
+	if (!ret)
+		codec->cache_sync = 0;
+	trace_snd_soc_cache_sync(codec, name, "end");
+	return ret;
+}
+EXPORT_SYMBOL_GPL(snd_soc_cache_sync);
diff -Nru a/sound/soc/soc-compress.c b/sound/soc/soc-compress.c
--- a/sound/soc/soc-compress.c	2015-08-16 23:52:51.000000000 -0400
+++ b/sound/soc/soc-compress.c	2015-08-22 16:54:09.949983000 -0400
@@ -101,12 +101,10 @@
 
 	fe->dpcm[stream].runtime = fe_substream->runtime;
 
-	ret = dpcm_path_get(fe, stream, &list);
-	if (ret < 0)
-		goto fe_err;
-	else if (ret == 0)
+	if (dpcm_path_get(fe, stream, &list) <= 0) {
 		dev_dbg(fe->dev, "ASoC: %s no valid %s route\n",
 			fe->dai_link->name, stream ? "capture" : "playback");
+	}
 
 	/* calculate valid and active FE <-> BE dpcms */
 	dpcm_process_paths(fe, stream, &list, 1);
@@ -258,7 +256,10 @@
 	list_for_each_entry(dpcm, &fe->dpcm[stream].be_clients, list_be)
 		dpcm->state = SND_SOC_DPCM_LINK_STATE_FREE;
 
-	dpcm_dapm_stream_event(fe, stream, SND_SOC_DAPM_STREAM_STOP);
+	if (stream == SNDRV_PCM_STREAM_PLAYBACK)
+		dpcm_dapm_stream_event(fe, stream, SND_SOC_DAPM_STREAM_STOP);
+	else
+		dpcm_dapm_stream_event(fe, stream, SND_SOC_DAPM_STREAM_STOP);
 
 	fe->dpcm[stream].state = SND_SOC_DPCM_STATE_CLOSE;
 	fe->dpcm[stream].runtime_update = SND_SOC_DPCM_UPDATE_NO;
@@ -453,7 +454,11 @@
 	if (ret < 0)
 		goto out;
 
-	dpcm_dapm_stream_event(fe, stream, SND_SOC_DAPM_STREAM_START);
+	if (stream == SNDRV_PCM_STREAM_PLAYBACK)
+		dpcm_dapm_stream_event(fe, stream, SND_SOC_DAPM_STREAM_START);
+	else
+		dpcm_dapm_stream_event(fe, stream, SND_SOC_DAPM_STREAM_START);
+
 	fe->dpcm[stream].state = SND_SOC_DPCM_STATE_PREPARE;
 
 out:
@@ -659,8 +664,7 @@
 			rtd->dai_link->stream_name);
 
 		ret = snd_pcm_new_internal(rtd->card->snd_card, new_name, num,
-				rtd->dai_link->dpcm_playback,
-				rtd->dai_link->dpcm_capture, &be_pcm);
+				1, 0, &be_pcm);
 		if (ret < 0) {
 			dev_err(rtd->card->dev, "ASoC: can't create compressed for %s\n",
 				rtd->dai_link->name);
@@ -669,10 +673,8 @@
 
 		rtd->pcm = be_pcm;
 		rtd->fe_compr = 1;
-		if (rtd->dai_link->dpcm_playback)
-			be_pcm->streams[SNDRV_PCM_STREAM_PLAYBACK].substream->private_data = rtd;
-		else if (rtd->dai_link->dpcm_capture)
-			be_pcm->streams[SNDRV_PCM_STREAM_CAPTURE].substream->private_data = rtd;
+		be_pcm->streams[SNDRV_PCM_STREAM_PLAYBACK].substream->private_data = rtd;
+		be_pcm->streams[SNDRV_PCM_STREAM_CAPTURE].substream->private_data = rtd;
 		memcpy(compr->ops, &soc_compr_dyn_ops, sizeof(soc_compr_dyn_ops));
 	} else
 		memcpy(compr->ops, &soc_compr_ops, sizeof(soc_compr_ops));
diff -Nru a/sound/soc/soc-core.c b/sound/soc/soc-core.c
--- a/sound/soc/soc-core.c	2015-08-16 23:52:51.000000000 -0400
+++ b/sound/soc/soc-core.c	2015-08-22 16:54:09.951983000 -0400
@@ -34,6 +34,9 @@
 #include <linux/ctype.h>
 #include <linux/slab.h>
 #include <linux/of.h>
+#include <linux/gpio.h>
+#include <linux/of_gpio.h>
+#include <sound/ac97_codec.h>
 #include <sound/core.h>
 #include <sound/jack.h>
 #include <sound/pcm.h>
@@ -66,6 +69,16 @@
 module_param(pmdown_time, int, 0);
 MODULE_PARM_DESC(pmdown_time, "DAPM stream powerdown time (msecs)");
 
+struct snd_ac97_reset_cfg {
+	struct pinctrl *pctl;
+	struct pinctrl_state *pstate_reset;
+	struct pinctrl_state *pstate_warm_reset;
+	struct pinctrl_state *pstate_run;
+	int gpio_sdata;
+	int gpio_sync;
+	int gpio_reset;
+};
+
 /* returns the minimum number of bytes needed to represent
  * a particular given value */
 static int min_bytes_needed(unsigned long val)
@@ -191,39 +204,6 @@
 
 static DEVICE_ATTR(pmdown_time, 0644, pmdown_time_show, pmdown_time_set);
 
-static struct attribute *soc_dev_attrs[] = {
-	&dev_attr_codec_reg.attr,
-	&dev_attr_pmdown_time.attr,
-	NULL
-};
-
-static umode_t soc_dev_attr_is_visible(struct kobject *kobj,
-				       struct attribute *attr, int idx)
-{
-	struct device *dev = kobj_to_dev(kobj);
-	struct snd_soc_pcm_runtime *rtd = dev_get_drvdata(dev);
-
-	if (attr == &dev_attr_pmdown_time.attr)
-		return attr->mode; /* always visible */
-	return rtd->codec ? attr->mode : 0; /* enabled only with codec */
-}
-
-static const struct attribute_group soc_dapm_dev_group = {
-	.attrs = soc_dapm_dev_attrs,
-	.is_visible = soc_dev_attr_is_visible,
-};
-
-static const struct attribute_group soc_dev_roup = {
-	.attrs = soc_dev_attrs,
-	.is_visible = soc_dev_attr_is_visible,
-};
-
-static const struct attribute_group *soc_dev_attr_groups[] = {
-	&soc_dapm_dev_group,
-	&soc_dev_roup,
-	NULL
-};
-
 #ifdef CONFIG_DEBUG_FS
 static ssize_t codec_reg_read_file(struct file *file, char __user *user_buf,
 				   size_t count, loff_t *ppos)
@@ -290,54 +270,79 @@
 	.llseek = default_llseek,
 };
 
-static void soc_init_component_debugfs(struct snd_soc_component *component)
+static struct dentry *soc_debugfs_create_dir(struct dentry *parent,
+	const char *fmt, ...)
 {
-	if (!component->card->debugfs_card_root)
-		return;
+	struct dentry *de;
+	va_list ap;
+	char *s;
+
+	va_start(ap, fmt);
+	s = kvasprintf(GFP_KERNEL, fmt, ap);
+	va_end(ap);
 
-	if (component->debugfs_prefix) {
-		char *name;
+	if (!s)
+		return NULL;
 
-		name = kasprintf(GFP_KERNEL, "%s:%s",
-			component->debugfs_prefix, component->name);
-		if (name) {
-			component->debugfs_root = debugfs_create_dir(name,
-				component->card->debugfs_card_root);
-			kfree(name);
-		}
-	} else {
-		component->debugfs_root = debugfs_create_dir(component->name,
-				component->card->debugfs_card_root);
-	}
+	de = debugfs_create_dir(s, parent);
+	kfree(s);
+
+	return de;
+}
+
+static void soc_init_codec_debugfs(struct snd_soc_codec *codec)
+{
+	struct dentry *debugfs_card_root = codec->component.card->debugfs_card_root;
 
-	if (!component->debugfs_root) {
-		dev_warn(component->dev,
-			"ASoC: Failed to create component debugfs directory\n");
+	codec->debugfs_codec_root = soc_debugfs_create_dir(debugfs_card_root,
+						"codec:%s",
+						codec->component.name);
+	if (!codec->debugfs_codec_root) {
+		dev_warn(codec->dev,
+			"ASoC: Failed to create codec debugfs directory\n");
 		return;
 	}
 
-	snd_soc_dapm_debugfs_init(snd_soc_component_get_dapm(component),
-		component->debugfs_root);
+	debugfs_create_bool("cache_sync", 0444, codec->debugfs_codec_root,
+			    &codec->cache_sync);
+	debugfs_create_bool("cache_only", 0444, codec->debugfs_codec_root,
+			    &codec->cache_only);
+
+	codec->debugfs_reg = debugfs_create_file("codec_reg", 0644,
+						 codec->debugfs_codec_root,
+						 codec, &codec_reg_fops);
+	if (!codec->debugfs_reg)
+		dev_warn(codec->dev,
+			"ASoC: Failed to create codec register debugfs file\n");
 
-	if (component->init_debugfs)
-		component->init_debugfs(component);
+	snd_soc_dapm_debugfs_init(&codec->dapm, codec->debugfs_codec_root);
 }
 
-static void soc_cleanup_component_debugfs(struct snd_soc_component *component)
+static void soc_cleanup_codec_debugfs(struct snd_soc_codec *codec)
 {
-	debugfs_remove_recursive(component->debugfs_root);
+	debugfs_remove_recursive(codec->debugfs_codec_root);
 }
 
-static void soc_init_codec_debugfs(struct snd_soc_component *component)
+static void soc_init_platform_debugfs(struct snd_soc_platform *platform)
 {
-	struct snd_soc_codec *codec = snd_soc_component_to_codec(component);
+	struct dentry *debugfs_card_root = platform->component.card->debugfs_card_root;
 
-	codec->debugfs_reg = debugfs_create_file("codec_reg", 0644,
-						 codec->component.debugfs_root,
-						 codec, &codec_reg_fops);
-	if (!codec->debugfs_reg)
-		dev_warn(codec->dev,
-			"ASoC: Failed to create codec register debugfs file\n");
+	platform->debugfs_platform_root = soc_debugfs_create_dir(debugfs_card_root,
+						"platform:%s",
+						platform->component.name);
+	if (!platform->debugfs_platform_root) {
+		dev_warn(platform->dev,
+			"ASoC: Failed to create platform debugfs directory\n");
+		return;
+	}
+
+	snd_soc_dapm_debugfs_init(&platform->component.dapm,
+		platform->debugfs_platform_root);
+}
+
+static void soc_cleanup_platform_debugfs(struct snd_soc_platform *platform)
+{
+	debugfs_remove_recursive(platform->debugfs_platform_root);
 }
 
 static ssize_t codec_list_read_file(struct file *file, char __user *user_buf,
@@ -350,8 +355,6 @@
 	if (!buf)
 		return -ENOMEM;
 
-	mutex_lock(&client_mutex);
-
 	list_for_each_entry(codec, &codec_list, list) {
 		len = snprintf(buf + ret, PAGE_SIZE - ret, "%s\n",
 			       codec->component.name);
@@ -363,8 +366,6 @@
 		}
 	}
 
-	mutex_unlock(&client_mutex);
-
 	if (ret >= 0)
 		ret = simple_read_from_buffer(user_buf, count, ppos, buf, ret);
 
@@ -389,8 +390,6 @@
 	if (!buf)
 		return -ENOMEM;
 
-	mutex_lock(&client_mutex);
-
 	list_for_each_entry(component, &component_list, list) {
 		list_for_each_entry(dai, &component->dai_list, list) {
 			len = snprintf(buf + ret, PAGE_SIZE - ret, "%s\n",
@@ -404,8 +403,6 @@
 		}
 	}
 
-	mutex_unlock(&client_mutex);
-
 	ret = simple_read_from_buffer(user_buf, count, ppos, buf, ret);
 
 	kfree(buf);
@@ -429,8 +426,6 @@
 	if (!buf)
 		return -ENOMEM;
 
-	mutex_lock(&client_mutex);
-
 	list_for_each_entry(platform, &platform_list, list) {
 		len = snprintf(buf + ret, PAGE_SIZE - ret, "%s\n",
 			       platform->component.name);
@@ -442,8 +437,6 @@
 		}
 	}
 
-	mutex_unlock(&client_mutex);
-
 	ret = simple_read_from_buffer(user_buf, count, ppos, buf, ret);
 
 	kfree(buf);
@@ -458,9 +451,6 @@
 
 static void soc_init_card_debugfs(struct snd_soc_card *card)
 {
-	if (!snd_soc_debugfs_root)
-		return;
-
 	card->debugfs_card_root = debugfs_create_dir(card->name,
 						     snd_soc_debugfs_root);
 	if (!card->debugfs_card_root) {
@@ -482,45 +472,21 @@
 	debugfs_remove_recursive(card->debugfs_card_root);
 }
 
+#else
 
-static void snd_soc_debugfs_init(void)
+static inline void soc_init_codec_debugfs(struct snd_soc_codec *codec)
 {
-	snd_soc_debugfs_root = debugfs_create_dir("asoc", NULL);
-	if (IS_ERR(snd_soc_debugfs_root) || !snd_soc_debugfs_root) {
-		pr_warn("ASoC: Failed to create debugfs directory\n");
-		snd_soc_debugfs_root = NULL;
-		return;
-	}
-
-	if (!debugfs_create_file("codecs", 0444, snd_soc_debugfs_root, NULL,
-				 &codec_list_fops))
-		pr_warn("ASoC: Failed to create CODEC list debugfs file\n");
-
-	if (!debugfs_create_file("dais", 0444, snd_soc_debugfs_root, NULL,
-				 &dai_list_fops))
-		pr_warn("ASoC: Failed to create DAI list debugfs file\n");
-
-	if (!debugfs_create_file("platforms", 0444, snd_soc_debugfs_root, NULL,
-				 &platform_list_fops))
-		pr_warn("ASoC: Failed to create platform list debugfs file\n");
 }
 
-static void snd_soc_debugfs_exit(void)
+static inline void soc_cleanup_codec_debugfs(struct snd_soc_codec *codec)
 {
-	debugfs_remove_recursive(snd_soc_debugfs_root);
 }
 
-#else
-
-#define soc_init_codec_debugfs NULL
-
-static inline void soc_init_component_debugfs(
-	struct snd_soc_component *component)
+static inline void soc_init_platform_debugfs(struct snd_soc_platform *platform)
 {
 }
 
-static inline void soc_cleanup_component_debugfs(
-	struct snd_soc_component *component)
+static inline void soc_cleanup_platform_debugfs(struct snd_soc_platform *platform)
 {
 }
 
@@ -531,15 +497,6 @@
 static inline void soc_cleanup_card_debugfs(struct snd_soc_card *card)
 {
 }
-
-static inline void snd_soc_debugfs_init(void)
-{
-}
-
-static inline void snd_soc_debugfs_exit(void)
-{
-}
-
 #endif
 
 struct snd_pcm_substream *snd_soc_get_dai_substream(struct snd_soc_card *card,
@@ -571,6 +528,40 @@
 }
 EXPORT_SYMBOL_GPL(snd_soc_get_pcm_runtime);
 
+#ifdef CONFIG_SND_SOC_AC97_BUS
+/* unregister ac97 codec */
+static int soc_ac97_dev_unregister(struct snd_soc_codec *codec)
+{
+	if (codec->ac97->dev.bus)
+		device_unregister(&codec->ac97->dev);
+	return 0;
+}
+
+/* stop no dev release warning */
+static void soc_ac97_device_release(struct device *dev){}
+
+/* register ac97 codec to bus */
+static int soc_ac97_dev_register(struct snd_soc_codec *codec)
+{
+	int err;
+
+	codec->ac97->dev.bus = &ac97_bus_type;
+	codec->ac97->dev.parent = codec->component.card->dev;
+	codec->ac97->dev.release = soc_ac97_device_release;
+
+	dev_set_name(&codec->ac97->dev, "%d-%d:%s",
+		     codec->component.card->snd_card->number, 0,
+		     codec->component.name);
+	err = device_register(&codec->ac97->dev);
+	if (err < 0) {
+		dev_err(codec->dev, "ASoC: Can't register ac97 bus\n");
+		codec->ac97->dev.bus = NULL;
+		return err;
+	}
+	return 0;
+}
+#endif
+
 static void codec2codec_close_delayed_work(struct work_struct *work)
 {
 	/* Currently nothing to do for c2c links
@@ -588,8 +579,10 @@
 	struct snd_soc_codec *codec;
 	int i, j;
 
-	/* If the card is not initialized yet there is nothing to do */
-	if (!card->instantiated)
+	/* If the initialization of this soc device failed, there is no codec
+	 * associated with it. Just bail out in this case.
+	 */
+	if (list_empty(&card->codec_dev_list))
 		return 0;
 
 	/* Due to the resume being scheduled into a workqueue we could
@@ -630,17 +623,28 @@
 
 	for (i = 0; i < card->num_rtd; i++) {
 		struct snd_soc_dai *cpu_dai = card->rtd[i].cpu_dai;
+		struct snd_soc_platform *platform = card->rtd[i].platform;
 
 		if (card->rtd[i].dai_link->ignore_suspend)
 			continue;
 
-		if (cpu_dai->driver->suspend && !cpu_dai->driver->bus_control)
+		if (cpu_dai->driver->suspend && !cpu_dai->driver->ac97_control)
 			cpu_dai->driver->suspend(cpu_dai);
+		if (platform->driver->suspend && !platform->suspended) {
+			platform->driver->suspend(cpu_dai);
+			platform->suspended = 1;
+		}
 	}
 
-	/* close any waiting streams */
-	for (i = 0; i < card->num_rtd; i++)
+	/* close any waiting streams and save state */
+	for (i = 0; i < card->num_rtd; i++) {
+		struct snd_soc_dai **codec_dais = card->rtd[i].codec_dais;
 		flush_delayed_work(&card->rtd[i].delayed_work);
+		for (j = 0; j < card->rtd[i].num_codecs; j++) {
+			codec_dais[j]->codec->dapm.suspend_bias_level =
+					codec_dais[j]->codec->dapm.bias_level;
+		}
+	}
 
 	for (i = 0; i < card->num_rtd; i++) {
 
@@ -656,15 +660,15 @@
 					  SND_SOC_DAPM_STREAM_SUSPEND);
 	}
 
-	/* Recheck all endpoints too, their state is affected by suspend */
-	dapm_mark_endpoints_dirty(card);
+	/* Recheck all analogue paths too */
+	dapm_mark_io_dirty(&card->dapm);
 	snd_soc_dapm_sync(&card->dapm);
 
 	/* suspend all CODECs */
 	list_for_each_entry(codec, &card->codec_dev_list, card_list) {
 		/* If there are paths active then the CODEC will be held with
 		 * bias _ON and should not be suspended. */
-		if (!codec->suspended) {
+		if (!codec->suspended && codec->driver->suspend) {
 			switch (codec->dapm.bias_level) {
 			case SND_SOC_BIAS_STANDBY:
 				/*
@@ -678,11 +682,10 @@
 						"ASoC: idle_bias_off CODEC on over suspend\n");
 					break;
 				}
-
 			case SND_SOC_BIAS_OFF:
-				if (codec->driver->suspend)
-					codec->driver->suspend(codec);
+				codec->driver->suspend(codec);
 				codec->suspended = 1;
+				codec->cache_sync = 1;
 				if (codec->component.regmap)
 					regcache_mark_dirty(codec->component.regmap);
 				/* deactivate pins to sleep state */
@@ -702,7 +705,7 @@
 		if (card->rtd[i].dai_link->ignore_suspend)
 			continue;
 
-		if (cpu_dai->driver->suspend && cpu_dai->driver->bus_control)
+		if (cpu_dai->driver->suspend && cpu_dai->driver->ac97_control)
 			cpu_dai->driver->suspend(cpu_dai);
 
 		/* deactivate pins to sleep state */
@@ -738,14 +741,14 @@
 	if (card->resume_pre)
 		card->resume_pre(card);
 
-	/* resume control bus DAIs */
+	/* resume AC97 DAIs */
 	for (i = 0; i < card->num_rtd; i++) {
 		struct snd_soc_dai *cpu_dai = card->rtd[i].cpu_dai;
 
 		if (card->rtd[i].dai_link->ignore_suspend)
 			continue;
 
-		if (cpu_dai->driver->resume && cpu_dai->driver->bus_control)
+		if (cpu_dai->driver->resume && cpu_dai->driver->ac97_control)
 			cpu_dai->driver->resume(cpu_dai);
 	}
 
@@ -754,12 +757,11 @@
 		 * left with bias OFF or STANDBY and suspended so we must now
 		 * resume.  Otherwise the suspend was suppressed.
 		 */
-		if (codec->suspended) {
+		if (codec->driver->resume && codec->suspended) {
 			switch (codec->dapm.bias_level) {
 			case SND_SOC_BIAS_STANDBY:
 			case SND_SOC_BIAS_OFF:
-				if (codec->driver->resume)
-					codec->driver->resume(codec);
+				codec->driver->resume(codec);
 				codec->suspended = 0;
 				break;
 			default:
@@ -801,12 +803,17 @@
 
 	for (i = 0; i < card->num_rtd; i++) {
 		struct snd_soc_dai *cpu_dai = card->rtd[i].cpu_dai;
+		struct snd_soc_platform *platform = card->rtd[i].platform;
 
 		if (card->rtd[i].dai_link->ignore_suspend)
 			continue;
 
-		if (cpu_dai->driver->resume && !cpu_dai->driver->bus_control)
+		if (cpu_dai->driver->resume && !cpu_dai->driver->ac97_control)
 			cpu_dai->driver->resume(cpu_dai);
+		if (platform->driver->resume && platform->suspended) {
+			platform->driver->resume(cpu_dai);
+			platform->suspended = 0;
+		}
 	}
 
 	if (card->resume_post)
@@ -817,8 +824,8 @@
 	/* userspace can access us now we are back as we were before */
 	snd_power_change_state(card->snd_card, SNDRV_CTL_POWER_D0);
 
-	/* Recheck all endpoints too, their state is affected by suspend */
-	dapm_mark_endpoints_dirty(card);
+	/* Recheck all analogue paths too */
+	dapm_mark_io_dirty(&card->dapm);
 	snd_soc_dapm_sync(&card->dapm);
 }
 
@@ -826,11 +833,12 @@
 int snd_soc_resume(struct device *dev)
 {
 	struct snd_soc_card *card = dev_get_drvdata(dev);
-	bool bus_control = false;
-	int i;
+	int i, ac97_control = 0;
 
-	/* If the card is not initialized yet there is nothing to do */
-	if (!card->instantiated)
+	/* If the initialization of this soc device failed, there is no codec
+	 * associated with it. Just bail out in this case.
+	 */
+	if (list_empty(&card->codec_dev_list))
 		return 0;
 
 	/* activate pins from sleep state */
@@ -850,18 +858,17 @@
 		}
 	}
 
-	/*
-	 * DAIs that also act as the control bus master might have other drivers
-	 * hanging off them so need to resume immediately. Other drivers don't
-	 * have that problem and may take a substantial amount of time to resume
+	/* AC97 devices might have other drivers hanging off them so
+	 * need to resume immediately.  Other drivers don't have that
+	 * problem and may take a substantial amount of time to resume
 	 * due to I/O costs and anti-pop so handle them out of line.
 	 */
 	for (i = 0; i < card->num_rtd; i++) {
 		struct snd_soc_dai *cpu_dai = card->rtd[i].cpu_dai;
-		bus_control |= cpu_dai->driver->bus_control;
+		ac97_control |= cpu_dai->driver->ac97_control;
 	}
-	if (bus_control) {
-		dev_dbg(dev, "ASoC: Resuming control bus master immediately\n");
+	if (ac97_control) {
+		dev_dbg(dev, "ASoC: Resuming AC97 immediately\n");
 		soc_resume_deferred(&card->deferred_resume_work);
 	} else {
 		dev_dbg(dev, "ASoC: Scheduling resume work\n");
@@ -880,44 +887,35 @@
 static const struct snd_soc_dai_ops null_dai_ops = {
 };
 
-static struct snd_soc_component *soc_find_component(
-	const struct device_node *of_node, const char *name)
+static struct snd_soc_codec *soc_find_codec(
+					const struct device_node *codec_of_node,
+					const char *codec_name)
 {
-	struct snd_soc_component *component;
-
-	lockdep_assert_held(&client_mutex);
+	struct snd_soc_codec *codec;
 
-	list_for_each_entry(component, &component_list, list) {
-		if (of_node) {
-			if (component->dev->of_node == of_node)
-				return component;
-		} else if (strcmp(component->name, name) == 0) {
-			return component;
+	list_for_each_entry(codec, &codec_list, list) {
+		if (codec_of_node) {
+			if (codec->dev->of_node != codec_of_node)
+				continue;
+		} else {
+			if (strcmp(codec->component.name, codec_name))
+				continue;
 		}
+
+		return codec;
 	}
 
 	return NULL;
 }
 
-static struct snd_soc_dai *snd_soc_find_dai(
-	const struct snd_soc_dai_link_component *dlc)
+static struct snd_soc_dai *soc_find_codec_dai(struct snd_soc_codec *codec,
+					      const char *codec_dai_name)
 {
-	struct snd_soc_component *component;
-	struct snd_soc_dai *dai;
-
-	lockdep_assert_held(&client_mutex);
-
-	/* Find CPU DAI from registered DAIs*/
-	list_for_each_entry(component, &component_list, list) {
-		if (dlc->of_node && component->dev->of_node != dlc->of_node)
-			continue;
-		if (dlc->name && strcmp(component->name, dlc->name))
-			continue;
-		list_for_each_entry(dai, &component->dai_list, list) {
-			if (dlc->dai_name && strcmp(dai->name, dlc->dai_name))
-				continue;
+	struct snd_soc_dai *codec_dai;
 
-			return dai;
+	list_for_each_entry(codec_dai, &codec->component.dai_list, list) {
+		if (!strcmp(codec_dai->name, codec_dai_name)) {
+			return codec_dai;
 		}
 	}
 
@@ -928,19 +926,33 @@
 {
 	struct snd_soc_dai_link *dai_link = &card->dai_link[num];
 	struct snd_soc_pcm_runtime *rtd = &card->rtd[num];
+	struct snd_soc_component *component;
 	struct snd_soc_dai_link_component *codecs = dai_link->codecs;
-	struct snd_soc_dai_link_component cpu_dai_component;
 	struct snd_soc_dai **codec_dais = rtd->codec_dais;
 	struct snd_soc_platform *platform;
+	struct snd_soc_dai *cpu_dai;
 	const char *platform_name;
 	int i;
 
 	dev_dbg(card->dev, "ASoC: binding %s at idx %d\n", dai_link->name, num);
 
-	cpu_dai_component.name = dai_link->cpu_name;
-	cpu_dai_component.of_node = dai_link->cpu_of_node;
-	cpu_dai_component.dai_name = dai_link->cpu_dai_name;
-	rtd->cpu_dai = snd_soc_find_dai(&cpu_dai_component);
+	/* Find CPU DAI from registered DAIs*/
+	list_for_each_entry(component, &component_list, list) {
+		if (dai_link->cpu_of_node &&
+			component->dev->of_node != dai_link->cpu_of_node)
+			continue;
+		if (dai_link->cpu_name &&
+			strcmp(dev_name(component->dev), dai_link->cpu_name))
+			continue;
+		list_for_each_entry(cpu_dai, &component->dai_list, list) {
+			if (dai_link->cpu_dai_name &&
+				strcmp(cpu_dai->name, dai_link->cpu_dai_name))
+				continue;
+
+			rtd->cpu_dai = cpu_dai;
+		}
+	}
+
 	if (!rtd->cpu_dai) {
 		dev_err(card->dev, "ASoC: CPU DAI %s not registered\n",
 			dai_link->cpu_dai_name);
@@ -951,7 +963,15 @@
 
 	/* Find CODEC from registered CODECs */
 	for (i = 0; i < rtd->num_codecs; i++) {
-		codec_dais[i] = snd_soc_find_dai(&codecs[i]);
+		struct snd_soc_codec *codec;
+		codec = soc_find_codec(codecs[i].of_node, codecs[i].name);
+		if (!codec) {
+			dev_err(card->dev, "ASoC: CODEC %s not registered\n",
+				codecs[i].name);
+			return -EPROBE_DEFER;
+		}
+
+		codec_dais[i] = soc_find_codec_dai(codec, codecs[i].dai_name);
 		if (!codec_dais[i]) {
 			dev_err(card->dev, "ASoC: CODEC DAI %s not registered\n",
 				codecs[i].dai_name);
@@ -992,58 +1012,95 @@
 	return 0;
 }
 
-static void soc_remove_component(struct snd_soc_component *component)
+static int soc_remove_platform(struct snd_soc_platform *platform)
 {
-	if (!component->probed)
-		return;
+	int ret;
+
+	if (platform->driver->remove) {
+		ret = platform->driver->remove(platform);
+		if (ret < 0)
+			dev_err(platform->dev, "ASoC: failed to remove %d\n",
+				ret);
+	}
 
-	/* This is a HACK and will be removed soon */
-	if (component->codec)
-		list_del(&component->codec->card_list);
+	/* Make sure all DAPM widgets are freed */
+	snd_soc_dapm_free(&platform->component.dapm);
 
-	if (component->remove)
-		component->remove(component);
+	soc_cleanup_platform_debugfs(platform);
+	platform->probed = 0;
+	module_put(platform->dev->driver->owner);
+
+	return 0;
+}
+
+static void soc_remove_codec(struct snd_soc_codec *codec)
+{
+	int err;
+
+	if (codec->driver->remove) {
+		err = codec->driver->remove(codec);
+		if (err < 0)
+			dev_err(codec->dev, "ASoC: failed to remove %d\n", err);
+	}
 
-	snd_soc_dapm_free(snd_soc_component_get_dapm(component));
+	/* Make sure all DAPM widgets are freed */
+	snd_soc_dapm_free(&codec->dapm);
 
-	soc_cleanup_component_debugfs(component);
-	component->probed = 0;
-	module_put(component->dev->driver->owner);
+	soc_cleanup_codec_debugfs(codec);
+	codec->probed = 0;
+	list_del(&codec->card_list);
+	module_put(codec->dev->driver->owner);
 }
 
-static void soc_remove_dai(struct snd_soc_dai *dai, int order)
+static void soc_remove_codec_dai(struct snd_soc_dai *codec_dai, int order)
 {
 	int err;
 
-	if (dai && dai->probed &&
-			dai->driver->remove_order == order) {
-		if (dai->driver->remove) {
-			err = dai->driver->remove(dai);
+	if (codec_dai && codec_dai->probed &&
+			codec_dai->driver->remove_order == order) {
+		if (codec_dai->driver->remove) {
+			err = codec_dai->driver->remove(codec_dai);
 			if (err < 0)
-				dev_err(dai->dev,
+				dev_err(codec_dai->dev,
 					"ASoC: failed to remove %s: %d\n",
-					dai->name, err);
+					codec_dai->name, err);
 		}
-		dai->probed = 0;
+		codec_dai->probed = 0;
 	}
 }
 
 static void soc_remove_link_dais(struct snd_soc_card *card, int num, int order)
 {
 	struct snd_soc_pcm_runtime *rtd = &card->rtd[num];
-	int i;
+	struct snd_soc_dai *cpu_dai = rtd->cpu_dai;
+	int i, err;
 
 	/* unregister the rtd device */
 	if (rtd->dev_registered) {
+		device_remove_file(rtd->dev, &dev_attr_pmdown_time);
+		device_remove_file(rtd->dev, &dev_attr_codec_reg);
 		device_unregister(rtd->dev);
 		rtd->dev_registered = 0;
 	}
 
 	/* remove the CODEC DAI */
 	for (i = 0; i < rtd->num_codecs; i++)
-		soc_remove_dai(rtd->codec_dais[i], order);
+		soc_remove_codec_dai(rtd->codec_dais[i], order);
 
-	soc_remove_dai(rtd->cpu_dai, order);
+	/* remove the cpu_dai */
+	if (cpu_dai && cpu_dai->probed &&
+			cpu_dai->driver->remove_order == order) {
+		if (cpu_dai->driver->remove) {
+			err = cpu_dai->driver->remove(cpu_dai);
+			if (err < 0)
+				dev_err(cpu_dai->dev,
+					"ASoC: failed to remove %s: %d\n",
+					cpu_dai->name, err);
+		}
+		cpu_dai->probed = 0;
+		if (!cpu_dai->codec)
+			module_put(cpu_dai->dev->driver->owner);
+	}
 }
 
 static void soc_remove_link_components(struct snd_soc_card *card, int num,
@@ -1052,24 +1109,29 @@
 	struct snd_soc_pcm_runtime *rtd = &card->rtd[num];
 	struct snd_soc_dai *cpu_dai = rtd->cpu_dai;
 	struct snd_soc_platform *platform = rtd->platform;
-	struct snd_soc_component *component;
+	struct snd_soc_codec *codec;
 	int i;
 
 	/* remove the platform */
-	if (platform && platform->component.driver->remove_order == order)
-		soc_remove_component(&platform->component);
+	if (platform && platform->probed &&
+	    platform->driver->remove_order == order) {
+		soc_remove_platform(platform);
+	}
 
 	/* remove the CODEC-side CODEC */
 	for (i = 0; i < rtd->num_codecs; i++) {
-		component = rtd->codec_dais[i]->component;
-		if (component->driver->remove_order == order)
-			soc_remove_component(component);
+		codec = rtd->codec_dais[i]->codec;
+		if (codec && codec->probed &&
+		    codec->driver->remove_order == order)
+			soc_remove_codec(codec);
 	}
 
 	/* remove any CPU-side CODEC */
 	if (cpu_dai) {
-		if (cpu_dai->component->driver->remove_order == order)
-			soc_remove_component(cpu_dai->component);
+		codec = cpu_dai->codec;
+		if (codec && codec->probed &&
+		    codec->driver->remove_order == order)
+			soc_remove_codec(codec);
 	}
 }
 
@@ -1111,78 +1173,137 @@
 	}
 }
 
-static int soc_probe_component(struct snd_soc_card *card,
-	struct snd_soc_component *component)
+static int soc_probe_codec(struct snd_soc_card *card,
+			   struct snd_soc_codec *codec)
 {
-	struct snd_soc_dapm_context *dapm = snd_soc_component_get_dapm(component);
+	int ret = 0;
+	const struct snd_soc_codec_driver *driver = codec->driver;
 	struct snd_soc_dai *dai;
-	int ret;
-
-	if (component->probed)
-		return 0;
 
-	component->card = card;
-	dapm->card = card;
-	soc_set_name_prefix(card, component);
+	codec->component.card = card;
+	codec->dapm.card = card;
+	soc_set_name_prefix(card, &codec->component);
 
-	if (!try_module_get(component->dev->driver->owner))
+	if (!try_module_get(codec->dev->driver->owner))
 		return -ENODEV;
 
-	soc_init_component_debugfs(component);
+	soc_init_codec_debugfs(codec);
 
-	if (component->dapm_widgets) {
-		ret = snd_soc_dapm_new_controls(dapm, component->dapm_widgets,
-			component->num_dapm_widgets);
+	if (driver->dapm_widgets) {
+		ret = snd_soc_dapm_new_controls(&codec->dapm,
+						driver->dapm_widgets,
+					 	driver->num_dapm_widgets);
 
 		if (ret != 0) {
-			dev_err(component->dev,
+			dev_err(codec->dev,
 				"Failed to create new controls %d\n", ret);
 			goto err_probe;
 		}
 	}
 
-	list_for_each_entry(dai, &component->dai_list, list) {
-		ret = snd_soc_dapm_new_dai_widgets(dapm, dai);
+	/* Create DAPM widgets for each DAI stream */
+	list_for_each_entry(dai, &codec->component.dai_list, list) {
+		ret = snd_soc_dapm_new_dai_widgets(&codec->dapm, dai);
+
 		if (ret != 0) {
-			dev_err(component->dev,
+			dev_err(codec->dev,
 				"Failed to create DAI widgets %d\n", ret);
 			goto err_probe;
 		}
 	}
 
-	if (component->probe) {
-		ret = component->probe(component);
+	codec->dapm.idle_bias_off = driver->idle_bias_off;
+
+	if (driver->probe) {
+		ret = driver->probe(codec);
 		if (ret < 0) {
-			dev_err(component->dev,
-				"ASoC: failed to probe component %d\n", ret);
+			dev_err(codec->dev,
+				"ASoC: failed to probe CODEC %d\n", ret);
 			goto err_probe;
 		}
-
-		WARN(dapm->idle_bias_off &&
-			dapm->bias_level != SND_SOC_BIAS_OFF,
+		WARN(codec->dapm.idle_bias_off &&
+			codec->dapm.bias_level != SND_SOC_BIAS_OFF,
 			"codec %s can not start from non-off bias with idle_bias_off==1\n",
-			component->name);
+			codec->component.name);
+	}
+
+	if (driver->controls)
+		snd_soc_add_codec_controls(codec, driver->controls,
+				     driver->num_controls);
+	if (driver->dapm_routes)
+		snd_soc_dapm_add_routes(&codec->dapm, driver->dapm_routes,
+					driver->num_dapm_routes);
+
+	/* mark codec as probed and add to card codec list */
+	codec->probed = 1;
+	list_add(&codec->card_list, &card->codec_dev_list);
+	list_add(&codec->dapm.list, &card->dapm_list);
+
+	return 0;
+
+err_probe:
+	soc_cleanup_codec_debugfs(codec);
+	module_put(codec->dev->driver->owner);
+
+	return ret;
+}
+
+static int soc_probe_platform(struct snd_soc_card *card,
+			   struct snd_soc_platform *platform)
+{
+	int ret = 0;
+	const struct snd_soc_platform_driver *driver = platform->driver;
+	struct snd_soc_component *component;
+	struct snd_soc_dai *dai;
+
+	platform->component.card = card;
+	platform->component.dapm.card = card;
+
+	if (!try_module_get(platform->dev->driver->owner))
+		return -ENODEV;
+
+	soc_init_platform_debugfs(platform);
+
+	if (driver->dapm_widgets)
+		snd_soc_dapm_new_controls(&platform->component.dapm,
+			driver->dapm_widgets, driver->num_dapm_widgets);
+
+	/* Create DAPM widgets for each DAI stream */
+	list_for_each_entry(component, &component_list, list) {
+		if (component->dev != platform->dev)
+			continue;
+		list_for_each_entry(dai, &component->dai_list, list)
+			snd_soc_dapm_new_dai_widgets(&platform->component.dapm,
+				dai);
+	}
+
+	platform->component.dapm.idle_bias_off = 1;
+
+	if (driver->probe) {
+		ret = driver->probe(platform);
+		if (ret < 0) {
+			dev_err(platform->dev,
+				"ASoC: failed to probe platform %d\n", ret);
+			goto err_probe;
+		}
 	}
 
-	if (component->controls)
-		snd_soc_add_component_controls(component, component->controls,
-				     component->num_controls);
-	if (component->dapm_routes)
-		snd_soc_dapm_add_routes(dapm, component->dapm_routes,
-					component->num_dapm_routes);
-
-	component->probed = 1;
-	list_add(&dapm->list, &card->dapm_list);
-
-	/* This is a HACK and will be removed soon */
-	if (component->codec)
-		list_add(&component->codec->card_list, &card->codec_dev_list);
+	if (driver->controls)
+		snd_soc_add_platform_controls(platform, driver->controls,
+				     driver->num_controls);
+	if (driver->dapm_routes)
+		snd_soc_dapm_add_routes(&platform->component.dapm,
+			driver->dapm_routes, driver->num_dapm_routes);
+
+	/* mark platform as probed and add to card platform list */
+	platform->probed = 1;
+	list_add(&platform->component.dapm.list, &card->dapm_list);
 
 	return 0;
 
 err_probe:
-	soc_cleanup_component_debugfs(component);
-	module_put(component->dev->driver->owner);
+	soc_cleanup_platform_debugfs(platform);
+	module_put(platform->dev->driver->owner);
 
 	return ret;
 }
@@ -1204,8 +1325,7 @@
 	device_initialize(rtd->dev);
 	rtd->dev->parent = rtd->card->dev;
 	rtd->dev->release = rtd_release;
-	rtd->dev->groups = soc_dev_attr_groups;
-	dev_set_name(rtd->dev, "%s", name);
+	rtd->dev->init_name = name;
 	dev_set_drvdata(rtd->dev, rtd);
 	mutex_init(&rtd->pcm_mutex);
 	INIT_LIST_HEAD(&rtd->dpcm[SNDRV_PCM_STREAM_PLAYBACK].be_clients);
@@ -1221,6 +1341,19 @@
 		return ret;
 	}
 	rtd->dev_registered = 1;
+
+	/* add DAPM sysfs entries for this codec */
+	ret = snd_soc_dapm_sys_add(rtd->dev);
+	if (ret < 0)
+		dev_err(rtd->dev,
+			"ASoC: failed to add codec dapm sysfs entries: %d\n", ret);
+
+	/* add codec sysfs entries */
+	ret = device_create_file(rtd->dev, &dev_attr_codec_reg);
+	if (ret < 0)
+		dev_err(rtd->dev,
+			"ASoC: failed to add codec sysfs files: %d\n", ret);
+
 	return 0;
 }
 
@@ -1228,31 +1361,33 @@
 				     int order)
 {
 	struct snd_soc_pcm_runtime *rtd = &card->rtd[num];
+	struct snd_soc_dai *cpu_dai = rtd->cpu_dai;
 	struct snd_soc_platform *platform = rtd->platform;
-	struct snd_soc_component *component;
 	int i, ret;
 
 	/* probe the CPU-side component, if it is a CODEC */
-	component = rtd->cpu_dai->component;
-	if (component->driver->probe_order == order) {
-		ret = soc_probe_component(card, component);
+	if (cpu_dai->codec &&
+	    !cpu_dai->codec->probed &&
+	    cpu_dai->codec->driver->probe_order == order) {
+		ret = soc_probe_codec(card, cpu_dai->codec);
 		if (ret < 0)
 			return ret;
 	}
 
 	/* probe the CODEC-side components */
 	for (i = 0; i < rtd->num_codecs; i++) {
-		component = rtd->codec_dais[i]->component;
-		if (component->driver->probe_order == order) {
-			ret = soc_probe_component(card, component);
+		if (!rtd->codec_dais[i]->codec->probed &&
+		    rtd->codec_dais[i]->codec->driver->probe_order == order) {
+			ret = soc_probe_codec(card, rtd->codec_dais[i]->codec);
 			if (ret < 0)
 				return ret;
 		}
 	}
 
 	/* probe the platform */
-	if (platform->component.driver->probe_order == order) {
-		ret = soc_probe_component(card, &platform->component);
+	if (!platform->probed &&
+	    platform->driver->probe_order == order) {
+		ret = soc_probe_platform(card, platform);
 		if (ret < 0)
 			return ret;
 	}
@@ -1260,22 +1395,25 @@
 	return 0;
 }
 
-static int soc_probe_dai(struct snd_soc_dai *dai, int order)
+static int soc_probe_codec_dai(struct snd_soc_card *card,
+			       struct snd_soc_dai *codec_dai,
+			       int order)
 {
 	int ret;
 
-	if (!dai->probed && dai->driver->probe_order == order) {
-		if (dai->driver->probe) {
-			ret = dai->driver->probe(dai);
+	if (!codec_dai->probed && codec_dai->driver->probe_order == order) {
+		if (codec_dai->driver->probe) {
+			ret = codec_dai->driver->probe(codec_dai);
 			if (ret < 0) {
-				dev_err(dai->dev,
-					"ASoC: failed to probe DAI %s: %d\n",
-					dai->name, ret);
+				dev_err(codec_dai->dev,
+					"ASoC: failed to probe CODEC DAI %s: %d\n",
+					codec_dai->name, ret);
 				return ret;
 			}
 		}
 
-		dai->probed = 1;
+		/* mark codec_dai as probed and add to card dai list */
+		codec_dai->probed = 1;
 	}
 
 	return 0;
@@ -1298,8 +1436,7 @@
 	capture_w = cpu_dai->capture_widget;
 	if (play_w && capture_w) {
 		ret = snd_soc_dapm_new_pcm(card, dai_link->params,
-					   dai_link->num_params, capture_w,
-					   play_w);
+					   capture_w, play_w);
 		if (ret != 0) {
 			dev_err(card->dev, "ASoC: Can't link %s to %s: %d\n",
 				play_w->name, capture_w->name, ret);
@@ -1311,8 +1448,7 @@
 	capture_w = codec_dai->capture_widget;
 	if (play_w && capture_w) {
 		ret = snd_soc_dapm_new_pcm(card, dai_link->params,
-					   dai_link->num_params, capture_w,
-					   play_w);
+					   capture_w, play_w);
 		if (ret != 0) {
 			dev_err(card->dev, "ASoC: Can't link %s to %s: %d\n",
 				play_w->name, capture_w->name, ret);
@@ -1327,22 +1463,46 @@
 {
 	struct snd_soc_dai_link *dai_link = &card->dai_link[num];
 	struct snd_soc_pcm_runtime *rtd = &card->rtd[num];
+	struct snd_soc_platform *platform = rtd->platform;
 	struct snd_soc_dai *cpu_dai = rtd->cpu_dai;
 	int i, ret;
 
 	dev_dbg(card->dev, "ASoC: probe %s dai link %d late %d\n",
 			card->name, num, order);
 
+	/* config components */
+	cpu_dai->platform = platform;
+	cpu_dai->card = card;
+	for (i = 0; i < rtd->num_codecs; i++)
+		rtd->codec_dais[i]->card = card;
+
 	/* set default power off timeout */
 	rtd->pmdown_time = pmdown_time;
 
-	ret = soc_probe_dai(cpu_dai, order);
-	if (ret)
-		return ret;
+	/* probe the cpu_dai */
+	if (!cpu_dai->probed &&
+			cpu_dai->driver->probe_order == order) {
+		if (!cpu_dai->codec) {
+			if (!try_module_get(cpu_dai->dev->driver->owner))
+				return -ENODEV;
+		}
+
+		if (cpu_dai->driver->probe) {
+			ret = cpu_dai->driver->probe(cpu_dai);
+			if (ret < 0) {
+				dev_err(cpu_dai->dev,
+					"ASoC: failed to probe CPU DAI %s: %d\n",
+					cpu_dai->name, ret);
+				module_put(cpu_dai->dev->driver->owner);
+				return ret;
+			}
+		}
+		cpu_dai->probed = 1;
+	}
 
 	/* probe the CODEC DAI */
 	for (i = 0; i < rtd->num_codecs; i++) {
-		ret = soc_probe_dai(rtd->codec_dais[i], order);
+		ret = soc_probe_codec_dai(card, rtd->codec_dais[i], order);
 		if (ret)
 			return ret;
 	}
@@ -1361,19 +1521,28 @@
 		}
 	}
 
-	if (dai_link->dai_fmt)
-		snd_soc_runtime_set_dai_fmt(rtd, dai_link->dai_fmt);
-
 	ret = soc_post_component_init(rtd, dai_link->name);
 	if (ret)
 		return ret;
 
 #ifdef CONFIG_DEBUG_FS
 	/* add DPCM sysfs entries */
-	if (dai_link->dynamic)
-		soc_dpcm_debugfs_add(rtd);
+	if (dai_link->dynamic) {
+		ret = soc_dpcm_debugfs_add(rtd);
+		if (ret < 0) {
+			dev_err(rtd->dev,
+				"ASoC: failed to add dpcm sysfs entries: %d\n",
+				ret);
+			return ret;
+		}
+	}
 #endif
 
+	ret = device_create_file(rtd->dev, &dev_attr_pmdown_time);
+	if (ret < 0)
+		dev_warn(rtd->dev, "ASoC: failed to add pmdown_time sysfs: %d\n",
+			ret);
+
 	if (cpu_dai->driver->compress_dai) {
 		/*create compress_device"*/
 		ret = soc_new_compress(rtd, num);
@@ -1403,47 +1572,120 @@
 		}
 	}
 
+	/* add platform data for AC97 devices */
+	for (i = 0; i < rtd->num_codecs; i++) {
+		if (rtd->codec_dais[i]->driver->ac97_control)
+			snd_ac97_dev_add_pdata(rtd->codec_dais[i]->codec->ac97,
+					       rtd->cpu_dai->ac97_pdata);
+	}
+
 	return 0;
 }
 
-static int soc_bind_aux_dev(struct snd_soc_card *card, int num)
+#ifdef CONFIG_SND_SOC_AC97_BUS
+static int soc_register_ac97_codec(struct snd_soc_codec *codec,
+				   struct snd_soc_dai *codec_dai)
 {
-	struct snd_soc_pcm_runtime *rtd = &card->rtd_aux[num];
-	struct snd_soc_aux_dev *aux_dev = &card->aux_dev[num];
-	const char *name = aux_dev->codec_name;
-
-	rtd->component = soc_find_component(aux_dev->codec_of_node, name);
-	if (!rtd->component) {
-		if (aux_dev->codec_of_node)
-			name = of_node_full_name(aux_dev->codec_of_node);
-
-		dev_err(card->dev, "ASoC: %s not registered\n", name);
-		return -EPROBE_DEFER;
-	}
+	int ret;
 
-	/*
-	 * Some places still reference rtd->codec, so we have to keep that
-	 * initialized if the component is a CODEC. Once all those references
-	 * have been removed, this code can be removed as well.
+	/* Only instantiate AC97 if not already done by the adaptor
+	 * for the generic AC97 subsystem.
 	 */
-	 rtd->codec = rtd->component->codec;
+	if (codec_dai->driver->ac97_control && !codec->ac97_registered) {
+		/*
+		 * It is possible that the AC97 device is already registered to
+		 * the device subsystem. This happens when the device is created
+		 * via snd_ac97_mixer(). Currently only SoC codec that does so
+		 * is the generic AC97 glue but others migh emerge.
+		 *
+		 * In those cases we don't try to register the device again.
+		 */
+		if (!codec->ac97_created)
+			return 0;
 
+		ret = soc_ac97_dev_register(codec);
+		if (ret < 0) {
+			dev_err(codec->dev,
+				"ASoC: AC97 device register failed: %d\n", ret);
+			return ret;
+		}
+
+		codec->ac97_registered = 1;
+	}
 	return 0;
 }
 
-static int soc_probe_aux_dev(struct snd_soc_card *card, int num)
+static void soc_unregister_ac97_codec(struct snd_soc_codec *codec)
 {
-	struct snd_soc_pcm_runtime *rtd = &card->rtd_aux[num];
-	struct snd_soc_aux_dev *aux_dev = &card->aux_dev[num];
+	if (codec->ac97_registered) {
+		soc_ac97_dev_unregister(codec);
+		codec->ac97_registered = 0;
+	}
+}
+
+static int soc_register_ac97_dai_link(struct snd_soc_pcm_runtime *rtd)
+{
+	int i, ret;
+
+	for (i = 0; i < rtd->num_codecs; i++) {
+		struct snd_soc_dai *codec_dai = rtd->codec_dais[i];
+
+		ret = soc_register_ac97_codec(codec_dai->codec, codec_dai);
+		if (ret) {
+			while (--i >= 0)
+				soc_unregister_ac97_codec(codec_dai->codec);
+			return ret;
+		}
+	}
+
+	return 0;
+}
+
+static void soc_unregister_ac97_dai_link(struct snd_soc_pcm_runtime *rtd)
+{
+	int i;
+
+	for (i = 0; i < rtd->num_codecs; i++)
+		soc_unregister_ac97_codec(rtd->codec_dais[i]->codec);
+}
+#endif
+
+static int soc_bind_aux_dev(struct snd_soc_card *card, int num)
+{
+	struct snd_soc_pcm_runtime *rtd = &card->rtd_aux[num];
+	struct snd_soc_aux_dev *aux_dev = &card->aux_dev[num];
+	const char *codecname = aux_dev->codec_name;
+
+	rtd->codec = soc_find_codec(aux_dev->codec_of_node, codecname);
+	if (!rtd->codec) {
+		if (aux_dev->codec_of_node)
+			codecname = of_node_full_name(aux_dev->codec_of_node);
+
+		dev_err(card->dev, "ASoC: %s not registered\n", codecname);
+		return -EPROBE_DEFER;
+	}
+
+	return 0;
+}
+
+static int soc_probe_aux_dev(struct snd_soc_card *card, int num)
+{
+	struct snd_soc_pcm_runtime *rtd = &card->rtd_aux[num];
+	struct snd_soc_aux_dev *aux_dev = &card->aux_dev[num];
 	int ret;
 
-	ret = soc_probe_component(card, rtd->component);
+	if (rtd->codec->probed) {
+		dev_err(rtd->codec->dev, "ASoC: codec already probed\n");
+		return -EBUSY;
+	}
+
+	ret = soc_probe_codec(card, rtd->codec);
 	if (ret < 0)
 		return ret;
 
 	/* do machine specific initialization */
 	if (aux_dev->init) {
-		ret = aux_dev->init(rtd->component);
+		ret = aux_dev->init(&rtd->codec->dapm);
 		if (ret < 0) {
 			dev_err(card->dev, "ASoC: failed to init %s: %d\n",
 				aux_dev->name, ret);
@@ -1457,16 +1699,17 @@
 static void soc_remove_aux_dev(struct snd_soc_card *card, int num)
 {
 	struct snd_soc_pcm_runtime *rtd = &card->rtd_aux[num];
-	struct snd_soc_component *component = rtd->component;
+	struct snd_soc_codec *codec = rtd->codec;
 
 	/* unregister the rtd device */
 	if (rtd->dev_registered) {
+		device_remove_file(rtd->dev, &dev_attr_codec_reg);
 		device_unregister(rtd->dev);
 		rtd->dev_registered = 0;
 	}
 
-	if (component && component->probed)
-		soc_remove_component(component);
+	if (codec && codec->probed)
+		soc_remove_codec(codec);
 }
 
 static int snd_soc_init_codec_cache(struct snd_soc_codec *codec)
@@ -1487,78 +1730,12 @@
 	return 0;
 }
 
-/**
- * snd_soc_runtime_set_dai_fmt() - Change DAI link format for a ASoC runtime
- * @rtd: The runtime for which the DAI link format should be changed
- * @dai_fmt: The new DAI link format
- *
- * This function updates the DAI link format for all DAIs connected to the DAI
- * link for the specified runtime.
- *
- * Note: For setups with a static format set the dai_fmt field in the
- * corresponding snd_dai_link struct instead of using this function.
- *
- * Returns 0 on success, otherwise a negative error code.
- */
-int snd_soc_runtime_set_dai_fmt(struct snd_soc_pcm_runtime *rtd,
-	unsigned int dai_fmt)
-{
-	struct snd_soc_dai **codec_dais = rtd->codec_dais;
-	struct snd_soc_dai *cpu_dai = rtd->cpu_dai;
-	unsigned int i;
-	int ret;
-
-	for (i = 0; i < rtd->num_codecs; i++) {
-		struct snd_soc_dai *codec_dai = codec_dais[i];
-
-		ret = snd_soc_dai_set_fmt(codec_dai, dai_fmt);
-		if (ret != 0 && ret != -ENOTSUPP) {
-			dev_warn(codec_dai->dev,
-				 "ASoC: Failed to set DAI format: %d\n", ret);
-			return ret;
-		}
-	}
-
-	/* Flip the polarity for the "CPU" end of a CODEC<->CODEC link */
-	if (cpu_dai->codec) {
-		unsigned int inv_dai_fmt;
-
-		inv_dai_fmt = dai_fmt & ~SND_SOC_DAIFMT_MASTER_MASK;
-		switch (dai_fmt & SND_SOC_DAIFMT_MASTER_MASK) {
-		case SND_SOC_DAIFMT_CBM_CFM:
-			inv_dai_fmt |= SND_SOC_DAIFMT_CBS_CFS;
-			break;
-		case SND_SOC_DAIFMT_CBM_CFS:
-			inv_dai_fmt |= SND_SOC_DAIFMT_CBS_CFM;
-			break;
-		case SND_SOC_DAIFMT_CBS_CFM:
-			inv_dai_fmt |= SND_SOC_DAIFMT_CBM_CFS;
-			break;
-		case SND_SOC_DAIFMT_CBS_CFS:
-			inv_dai_fmt |= SND_SOC_DAIFMT_CBM_CFM;
-			break;
-		}
-
-		dai_fmt = inv_dai_fmt;
-	}
-
-	ret = snd_soc_dai_set_fmt(cpu_dai, dai_fmt);
-	if (ret != 0 && ret != -ENOTSUPP) {
-		dev_warn(cpu_dai->dev,
-			 "ASoC: Failed to set DAI format: %d\n", ret);
-		return ret;
-	}
-
-	return 0;
-}
-EXPORT_SYMBOL_GPL(snd_soc_runtime_set_dai_fmt);
-
 static int snd_soc_instantiate_card(struct snd_soc_card *card)
 {
 	struct snd_soc_codec *codec;
-	int ret, i, order;
+	struct snd_soc_dai_link *dai_link;
+	int ret, i, order, dai_fmt;
 
-	mutex_lock(&client_mutex);
 	mutex_lock_nested(&card->mutex, SND_SOC_CARD_CLASS_INIT);
 
 	/* bind DAIs */
@@ -1594,8 +1771,6 @@
 		goto base_error;
 	}
 
-	soc_init_card_debugfs(card);
-
 	card->dapm.bias_level = SND_SOC_BIAS_OFF;
 	card->dapm.dev = card->dev;
 	card->dapm.card = card;
@@ -1614,10 +1789,6 @@
 		snd_soc_dapm_new_controls(&card->dapm, card->dapm_widgets,
 					  card->num_dapm_widgets);
 
-	if (card->of_dapm_widgets)
-		snd_soc_dapm_new_controls(&card->dapm, card->of_dapm_widgets,
-					  card->num_of_dapm_widgets);
-
 	/* initialise the sound card only once */
 	if (card->probe) {
 		ret = card->probe(card);
@@ -1673,9 +1844,62 @@
 		snd_soc_dapm_add_routes(&card->dapm, card->dapm_routes,
 					card->num_dapm_routes);
 
-	if (card->of_dapm_routes)
-		snd_soc_dapm_add_routes(&card->dapm, card->of_dapm_routes,
-					card->num_of_dapm_routes);
+	for (i = 0; i < card->num_links; i++) {
+		struct snd_soc_pcm_runtime *rtd = &card->rtd[i];
+		dai_link = &card->dai_link[i];
+		dai_fmt = dai_link->dai_fmt;
+
+		if (dai_fmt) {
+			struct snd_soc_dai **codec_dais = rtd->codec_dais;
+			int j;
+
+			for (j = 0; j < rtd->num_codecs; j++) {
+				struct snd_soc_dai *codec_dai = codec_dais[j];
+
+				ret = snd_soc_dai_set_fmt(codec_dai, dai_fmt);
+				if (ret != 0 && ret != -ENOTSUPP)
+					dev_warn(codec_dai->dev,
+						 "ASoC: Failed to set DAI format: %d\n",
+						 ret);
+			}
+		}
+
+		/* If this is a regular CPU link there will be a platform */
+		if (dai_fmt &&
+		    (dai_link->platform_name || dai_link->platform_of_node)) {
+			ret = snd_soc_dai_set_fmt(card->rtd[i].cpu_dai,
+						  dai_fmt);
+			if (ret != 0 && ret != -ENOTSUPP)
+				dev_warn(card->rtd[i].cpu_dai->dev,
+					 "ASoC: Failed to set DAI format: %d\n",
+					 ret);
+		} else if (dai_fmt) {
+			/* Flip the polarity for the "CPU" end */
+			dai_fmt &= ~SND_SOC_DAIFMT_MASTER_MASK;
+			switch (dai_link->dai_fmt &
+				SND_SOC_DAIFMT_MASTER_MASK) {
+			case SND_SOC_DAIFMT_CBM_CFM:
+				dai_fmt |= SND_SOC_DAIFMT_CBS_CFS;
+				break;
+			case SND_SOC_DAIFMT_CBM_CFS:
+				dai_fmt |= SND_SOC_DAIFMT_CBS_CFM;
+				break;
+			case SND_SOC_DAIFMT_CBS_CFM:
+				dai_fmt |= SND_SOC_DAIFMT_CBM_CFS;
+				break;
+			case SND_SOC_DAIFMT_CBS_CFS:
+				dai_fmt |= SND_SOC_DAIFMT_CBM_CFM;
+				break;
+			}
+
+			ret = snd_soc_dai_set_fmt(card->rtd[i].cpu_dai,
+						  dai_fmt);
+			if (ret != 0 && ret != -ENOTSUPP)
+				dev_warn(card->rtd[i].cpu_dai->dev,
+					 "ASoC: Failed to set DAI format: %d\n",
+					 ret);
+		}
+	}
 
 	snprintf(card->snd_card->shortname, sizeof(card->snd_card->shortname),
 		 "%s", card->name);
@@ -1705,6 +1929,9 @@
 		}
 	}
 
+	if (card->fully_routed)
+		snd_soc_dapm_auto_nc_pins(card);
+
 	snd_soc_dapm_new_widgets(card);
 
 	ret = snd_card_register(card->snd_card);
@@ -1714,10 +1941,23 @@
 		goto probe_aux_dev_err;
 	}
 
+#ifdef CONFIG_SND_SOC_AC97_BUS
+	/* register any AC97 codecs */
+	for (i = 0; i < card->num_rtd; i++) {
+		ret = soc_register_ac97_dai_link(&card->rtd[i]);
+		if (ret < 0) {
+			dev_err(card->dev,
+				"ASoC: failed to register AC97: %d\n", ret);
+			while (--i >= 0)
+				soc_unregister_ac97_dai_link(&card->rtd[i]);
+			goto probe_aux_dev_err;
+		}
+	}
+#endif
+
 	card->instantiated = 1;
 	snd_soc_dapm_sync(&card->dapm);
 	mutex_unlock(&card->mutex);
-	mutex_unlock(&client_mutex);
 
 	return 0;
 
@@ -1732,12 +1972,10 @@
 	if (card->remove)
 		card->remove(card);
 
-	soc_cleanup_card_debugfs(card);
 	snd_card_free(card->snd_card);
 
 base_error:
 	mutex_unlock(&card->mutex);
-	mutex_unlock(&client_mutex);
 
 	return ret;
 }
@@ -1851,6 +2089,7 @@
 static struct platform_driver soc_driver = {
 	.driver		= {
 		.name		= "soc-audio",
+		.owner		= THIS_MODULE,
 		.pm		= &snd_soc_pm_ops,
 	},
 	.probe		= soc_probe,
@@ -1858,6 +2097,224 @@
 };
 
 /**
+ * snd_soc_new_ac97_codec - initailise AC97 device
+ * @codec: audio codec
+ * @ops: AC97 bus operations
+ * @num: AC97 codec number
+ *
+ * Initialises AC97 codec resources for use by ad-hoc devices only.
+ */
+int snd_soc_new_ac97_codec(struct snd_soc_codec *codec,
+	struct snd_ac97_bus_ops *ops, int num)
+{
+	mutex_lock(&codec->mutex);
+
+	codec->ac97 = kzalloc(sizeof(struct snd_ac97), GFP_KERNEL);
+	if (codec->ac97 == NULL) {
+		mutex_unlock(&codec->mutex);
+		return -ENOMEM;
+	}
+
+	codec->ac97->bus = kzalloc(sizeof(struct snd_ac97_bus), GFP_KERNEL);
+	if (codec->ac97->bus == NULL) {
+		kfree(codec->ac97);
+		codec->ac97 = NULL;
+		mutex_unlock(&codec->mutex);
+		return -ENOMEM;
+	}
+
+	codec->ac97->bus->ops = ops;
+	codec->ac97->num = num;
+
+	/*
+	 * Mark the AC97 device to be created by us. This way we ensure that the
+	 * device will be registered with the device subsystem later on.
+	 */
+	codec->ac97_created = 1;
+
+	mutex_unlock(&codec->mutex);
+	return 0;
+}
+EXPORT_SYMBOL_GPL(snd_soc_new_ac97_codec);
+
+static struct snd_ac97_reset_cfg snd_ac97_rst_cfg;
+
+static void snd_soc_ac97_warm_reset(struct snd_ac97 *ac97)
+{
+	struct pinctrl *pctl = snd_ac97_rst_cfg.pctl;
+
+	pinctrl_select_state(pctl, snd_ac97_rst_cfg.pstate_warm_reset);
+
+	gpio_direction_output(snd_ac97_rst_cfg.gpio_sync, 1);
+
+	udelay(10);
+
+	gpio_direction_output(snd_ac97_rst_cfg.gpio_sync, 0);
+
+	pinctrl_select_state(pctl, snd_ac97_rst_cfg.pstate_run);
+	msleep(2);
+}
+
+static void snd_soc_ac97_reset(struct snd_ac97 *ac97)
+{
+	struct pinctrl *pctl = snd_ac97_rst_cfg.pctl;
+
+	pinctrl_select_state(pctl, snd_ac97_rst_cfg.pstate_reset);
+
+	gpio_direction_output(snd_ac97_rst_cfg.gpio_sync, 0);
+	gpio_direction_output(snd_ac97_rst_cfg.gpio_sdata, 0);
+	gpio_direction_output(snd_ac97_rst_cfg.gpio_reset, 0);
+
+	udelay(10);
+
+	gpio_direction_output(snd_ac97_rst_cfg.gpio_reset, 1);
+
+	pinctrl_select_state(pctl, snd_ac97_rst_cfg.pstate_run);
+	msleep(2);
+}
+
+static int snd_soc_ac97_parse_pinctl(struct device *dev,
+		struct snd_ac97_reset_cfg *cfg)
+{
+	struct pinctrl *p;
+	struct pinctrl_state *state;
+	int gpio;
+	int ret;
+
+	p = devm_pinctrl_get(dev);
+	if (IS_ERR(p)) {
+		dev_err(dev, "Failed to get pinctrl\n");
+		return PTR_ERR(p);
+	}
+	cfg->pctl = p;
+
+	state = pinctrl_lookup_state(p, "ac97-reset");
+	if (IS_ERR(state)) {
+		dev_err(dev, "Can't find pinctrl state ac97-reset\n");
+		return PTR_ERR(state);
+	}
+	cfg->pstate_reset = state;
+
+	state = pinctrl_lookup_state(p, "ac97-warm-reset");
+	if (IS_ERR(state)) {
+		dev_err(dev, "Can't find pinctrl state ac97-warm-reset\n");
+		return PTR_ERR(state);
+	}
+	cfg->pstate_warm_reset = state;
+
+	state = pinctrl_lookup_state(p, "ac97-running");
+	if (IS_ERR(state)) {
+		dev_err(dev, "Can't find pinctrl state ac97-running\n");
+		return PTR_ERR(state);
+	}
+	cfg->pstate_run = state;
+
+	gpio = of_get_named_gpio(dev->of_node, "ac97-gpios", 0);
+	if (gpio < 0) {
+		dev_err(dev, "Can't find ac97-sync gpio\n");
+		return gpio;
+	}
+	ret = devm_gpio_request(dev, gpio, "AC97 link sync");
+	if (ret) {
+		dev_err(dev, "Failed requesting ac97-sync gpio\n");
+		return ret;
+	}
+	cfg->gpio_sync = gpio;
+
+	gpio = of_get_named_gpio(dev->of_node, "ac97-gpios", 1);
+	if (gpio < 0) {
+		dev_err(dev, "Can't find ac97-sdata gpio %d\n", gpio);
+		return gpio;
+	}
+	ret = devm_gpio_request(dev, gpio, "AC97 link sdata");
+	if (ret) {
+		dev_err(dev, "Failed requesting ac97-sdata gpio\n");
+		return ret;
+	}
+	cfg->gpio_sdata = gpio;
+
+	gpio = of_get_named_gpio(dev->of_node, "ac97-gpios", 2);
+	if (gpio < 0) {
+		dev_err(dev, "Can't find ac97-reset gpio\n");
+		return gpio;
+	}
+	ret = devm_gpio_request(dev, gpio, "AC97 link reset");
+	if (ret) {
+		dev_err(dev, "Failed requesting ac97-reset gpio\n");
+		return ret;
+	}
+	cfg->gpio_reset = gpio;
+
+	return 0;
+}
+
+struct snd_ac97_bus_ops *soc_ac97_ops;
+EXPORT_SYMBOL_GPL(soc_ac97_ops);
+
+int snd_soc_set_ac97_ops(struct snd_ac97_bus_ops *ops)
+{
+	if (ops == soc_ac97_ops)
+		return 0;
+
+	if (soc_ac97_ops && ops)
+		return -EBUSY;
+
+	soc_ac97_ops = ops;
+
+	return 0;
+}
+EXPORT_SYMBOL_GPL(snd_soc_set_ac97_ops);
+
+/**
+ * snd_soc_set_ac97_ops_of_reset - Set ac97 ops with generic ac97 reset functions
+ *
+ * This function sets the reset and warm_reset properties of ops and parses
+ * the device node of pdev to get pinctrl states and gpio numbers to use.
+ */
+int snd_soc_set_ac97_ops_of_reset(struct snd_ac97_bus_ops *ops,
+		struct platform_device *pdev)
+{
+	struct device *dev = &pdev->dev;
+	struct snd_ac97_reset_cfg cfg;
+	int ret;
+
+	ret = snd_soc_ac97_parse_pinctl(dev, &cfg);
+	if (ret)
+		return ret;
+
+	ret = snd_soc_set_ac97_ops(ops);
+	if (ret)
+		return ret;
+
+	ops->warm_reset = snd_soc_ac97_warm_reset;
+	ops->reset = snd_soc_ac97_reset;
+
+	snd_ac97_rst_cfg = cfg;
+	return 0;
+}
+EXPORT_SYMBOL_GPL(snd_soc_set_ac97_ops_of_reset);
+
+/**
+ * snd_soc_free_ac97_codec - free AC97 codec device
+ * @codec: audio codec
+ *
+ * Frees AC97 codec device resources.
+ */
+void snd_soc_free_ac97_codec(struct snd_soc_codec *codec)
+{
+	mutex_lock(&codec->mutex);
+#ifdef CONFIG_SND_SOC_AC97_BUS
+	soc_unregister_ac97_codec(codec);
+#endif
+	kfree(codec->ac97->bus);
+	kfree(codec->ac97);
+	codec->ac97 = NULL;
+	codec->ac97_created = 0;
+	mutex_unlock(&codec->mutex);
+}
+EXPORT_SYMBOL_GPL(snd_soc_free_ac97_codec);
+
+/**
  * snd_soc_cnew - create new control
  * @_template: control template
  * @data: control private data
@@ -1894,143 +2351,1153 @@
 
 	kcontrol = snd_ctl_new1(&template, data);
 
-	kfree(name);
+	kfree(name);
+
+	return kcontrol;
+}
+EXPORT_SYMBOL_GPL(snd_soc_cnew);
+
+static int snd_soc_add_controls(struct snd_card *card, struct device *dev,
+	const struct snd_kcontrol_new *controls, int num_controls,
+	const char *prefix, void *data)
+{
+	int err, i;
+
+	for (i = 0; i < num_controls; i++) {
+		const struct snd_kcontrol_new *control = &controls[i];
+		err = snd_ctl_add(card, snd_soc_cnew(control, data,
+						     control->name, prefix));
+		if (err < 0) {
+			dev_err(dev, "ASoC: Failed to add %s: %d\n",
+				control->name, err);
+			return err;
+		}
+	}
+
+	return 0;
+}
+
+struct snd_kcontrol *snd_soc_card_get_kcontrol(struct snd_soc_card *soc_card,
+					       const char *name)
+{
+	struct snd_card *card = soc_card->snd_card;
+	struct snd_kcontrol *kctl;
+
+	if (unlikely(!name))
+		return NULL;
+
+	list_for_each_entry(kctl, &card->controls, list)
+		if (!strncmp(kctl->id.name, name, sizeof(kctl->id.name)))
+			return kctl;
+	return NULL;
+}
+EXPORT_SYMBOL_GPL(snd_soc_card_get_kcontrol);
+
+/**
+ * snd_soc_add_component_controls - Add an array of controls to a component.
+ *
+ * @component: Component to add controls to
+ * @controls: Array of controls to add
+ * @num_controls: Number of elements in the array
+ *
+ * Return: 0 for success, else error.
+ */
+int snd_soc_add_component_controls(struct snd_soc_component *component,
+	const struct snd_kcontrol_new *controls, unsigned int num_controls)
+{
+	struct snd_card *card = component->card->snd_card;
+
+	return snd_soc_add_controls(card, component->dev, controls,
+			num_controls, component->name_prefix, component);
+}
+EXPORT_SYMBOL_GPL(snd_soc_add_component_controls);
+
+/**
+ * snd_soc_add_codec_controls - add an array of controls to a codec.
+ * Convenience function to add a list of controls. Many codecs were
+ * duplicating this code.
+ *
+ * @codec: codec to add controls to
+ * @controls: array of controls to add
+ * @num_controls: number of elements in the array
+ *
+ * Return 0 for success, else error.
+ */
+int snd_soc_add_codec_controls(struct snd_soc_codec *codec,
+	const struct snd_kcontrol_new *controls, unsigned int num_controls)
+{
+	return snd_soc_add_component_controls(&codec->component, controls,
+		num_controls);
+}
+EXPORT_SYMBOL_GPL(snd_soc_add_codec_controls);
+
+/**
+ * snd_soc_add_platform_controls - add an array of controls to a platform.
+ * Convenience function to add a list of controls.
+ *
+ * @platform: platform to add controls to
+ * @controls: array of controls to add
+ * @num_controls: number of elements in the array
+ *
+ * Return 0 for success, else error.
+ */
+int snd_soc_add_platform_controls(struct snd_soc_platform *platform,
+	const struct snd_kcontrol_new *controls, unsigned int num_controls)
+{
+	return snd_soc_add_component_controls(&platform->component, controls,
+		num_controls);
+}
+EXPORT_SYMBOL_GPL(snd_soc_add_platform_controls);
+
+/**
+ * snd_soc_add_card_controls - add an array of controls to a SoC card.
+ * Convenience function to add a list of controls.
+ *
+ * @soc_card: SoC card to add controls to
+ * @controls: array of controls to add
+ * @num_controls: number of elements in the array
+ *
+ * Return 0 for success, else error.
+ */
+int snd_soc_add_card_controls(struct snd_soc_card *soc_card,
+	const struct snd_kcontrol_new *controls, int num_controls)
+{
+	struct snd_card *card = soc_card->snd_card;
+
+	return snd_soc_add_controls(card, soc_card->dev, controls, num_controls,
+			NULL, soc_card);
+}
+EXPORT_SYMBOL_GPL(snd_soc_add_card_controls);
+
+/**
+ * snd_soc_add_dai_controls - add an array of controls to a DAI.
+ * Convienience function to add a list of controls.
+ *
+ * @dai: DAI to add controls to
+ * @controls: array of controls to add
+ * @num_controls: number of elements in the array
+ *
+ * Return 0 for success, else error.
+ */
+int snd_soc_add_dai_controls(struct snd_soc_dai *dai,
+	const struct snd_kcontrol_new *controls, int num_controls)
+{
+	struct snd_card *card = dai->card->snd_card;
+
+	return snd_soc_add_controls(card, dai->dev, controls, num_controls,
+			NULL, dai);
+}
+EXPORT_SYMBOL_GPL(snd_soc_add_dai_controls);
+
+/**
+ * snd_soc_info_enum_double - enumerated double mixer info callback
+ * @kcontrol: mixer control
+ * @uinfo: control element information
+ *
+ * Callback to provide information about a double enumerated
+ * mixer control.
+ *
+ * Returns 0 for success.
+ */
+int snd_soc_info_enum_double(struct snd_kcontrol *kcontrol,
+	struct snd_ctl_elem_info *uinfo)
+{
+	struct soc_enum *e = (struct soc_enum *)kcontrol->private_value;
+
+	uinfo->type = SNDRV_CTL_ELEM_TYPE_ENUMERATED;
+	uinfo->count = e->shift_l == e->shift_r ? 1 : 2;
+	uinfo->value.enumerated.items = e->items;
+
+	if (uinfo->value.enumerated.item >= e->items)
+		uinfo->value.enumerated.item = e->items - 1;
+	strlcpy(uinfo->value.enumerated.name,
+		e->texts[uinfo->value.enumerated.item],
+		sizeof(uinfo->value.enumerated.name));
+	return 0;
+}
+EXPORT_SYMBOL_GPL(snd_soc_info_enum_double);
+
+/**
+ * snd_soc_get_enum_double - enumerated double mixer get callback
+ * @kcontrol: mixer control
+ * @ucontrol: control element information
+ *
+ * Callback to get the value of a double enumerated mixer.
+ *
+ * Returns 0 for success.
+ */
+int snd_soc_get_enum_double(struct snd_kcontrol *kcontrol,
+	struct snd_ctl_elem_value *ucontrol)
+{
+	struct snd_soc_component *component = snd_kcontrol_chip(kcontrol);
+	struct soc_enum *e = (struct soc_enum *)kcontrol->private_value;
+	unsigned int val, item;
+	unsigned int reg_val;
+	int ret;
+
+	ret = snd_soc_component_read(component, e->reg, &reg_val);
+	if (ret)
+		return ret;
+	val = (reg_val >> e->shift_l) & e->mask;
+	item = snd_soc_enum_val_to_item(e, val);
+	ucontrol->value.enumerated.item[0] = item;
+	if (e->shift_l != e->shift_r) {
+		val = (reg_val >> e->shift_l) & e->mask;
+		item = snd_soc_enum_val_to_item(e, val);
+		ucontrol->value.enumerated.item[1] = item;
+	}
+
+	return 0;
+}
+EXPORT_SYMBOL_GPL(snd_soc_get_enum_double);
+
+/**
+ * snd_soc_put_enum_double - enumerated double mixer put callback
+ * @kcontrol: mixer control
+ * @ucontrol: control element information
+ *
+ * Callback to set the value of a double enumerated mixer.
+ *
+ * Returns 0 for success.
+ */
+int snd_soc_put_enum_double(struct snd_kcontrol *kcontrol,
+	struct snd_ctl_elem_value *ucontrol)
+{
+	struct snd_soc_component *component = snd_kcontrol_chip(kcontrol);
+	struct soc_enum *e = (struct soc_enum *)kcontrol->private_value;
+	unsigned int *item = ucontrol->value.enumerated.item;
+	unsigned int val;
+	unsigned int mask;
+
+	if (item[0] >= e->items)
+		return -EINVAL;
+	val = snd_soc_enum_item_to_val(e, item[0]) << e->shift_l;
+	mask = e->mask << e->shift_l;
+	if (e->shift_l != e->shift_r) {
+		if (item[1] >= e->items)
+			return -EINVAL;
+		val |= snd_soc_enum_item_to_val(e, item[1]) << e->shift_r;
+		mask |= e->mask << e->shift_r;
+	}
+
+	return snd_soc_component_update_bits(component, e->reg, mask, val);
+}
+EXPORT_SYMBOL_GPL(snd_soc_put_enum_double);
+
+/**
+ * snd_soc_read_signed - Read a codec register and interprete as signed value
+ * @component: component
+ * @reg: Register to read
+ * @mask: Mask to use after shifting the register value
+ * @shift: Right shift of register value
+ * @sign_bit: Bit that describes if a number is negative or not.
+ * @signed_val: Pointer to where the read value should be stored
+ *
+ * This functions reads a codec register. The register value is shifted right
+ * by 'shift' bits and masked with the given 'mask'. Afterwards it translates
+ * the given registervalue into a signed integer if sign_bit is non-zero.
+ *
+ * Returns 0 on sucess, otherwise an error value
+ */
+static int snd_soc_read_signed(struct snd_soc_component *component,
+	unsigned int reg, unsigned int mask, unsigned int shift,
+	unsigned int sign_bit, int *signed_val)
+{
+	int ret;
+	unsigned int val;
+
+	ret = snd_soc_component_read(component, reg, &val);
+	if (ret < 0)
+		return ret;
+
+	val = (val >> shift) & mask;
+
+	if (!sign_bit) {
+		*signed_val = val;
+		return 0;
+	}
+
+	/* non-negative number */
+	if (!(val & BIT(sign_bit))) {
+		*signed_val = val;
+		return 0;
+	}
+
+	ret = val;
+
+	/*
+	 * The register most probably does not contain a full-sized int.
+	 * Instead we have an arbitrary number of bits in a signed
+	 * representation which has to be translated into a full-sized int.
+	 * This is done by filling up all bits above the sign-bit.
+	 */
+	ret |= ~((int)(BIT(sign_bit) - 1));
+
+	*signed_val = ret;
+
+	return 0;
+}
+
+/**
+ * snd_soc_info_volsw - single mixer info callback
+ * @kcontrol: mixer control
+ * @uinfo: control element information
+ *
+ * Callback to provide information about a single mixer control, or a double
+ * mixer control that spans 2 registers.
+ *
+ * Returns 0 for success.
+ */
+int snd_soc_info_volsw(struct snd_kcontrol *kcontrol,
+	struct snd_ctl_elem_info *uinfo)
+{
+	struct soc_mixer_control *mc =
+		(struct soc_mixer_control *)kcontrol->private_value;
+	int platform_max;
+
+	if (!mc->platform_max)
+		mc->platform_max = mc->max;
+	platform_max = mc->platform_max;
+
+	if (platform_max == 1 && !strstr(kcontrol->id.name, " Volume"))
+		uinfo->type = SNDRV_CTL_ELEM_TYPE_BOOLEAN;
+	else
+		uinfo->type = SNDRV_CTL_ELEM_TYPE_INTEGER;
+
+	uinfo->count = snd_soc_volsw_is_stereo(mc) ? 2 : 1;
+	uinfo->value.integer.min = 0;
+	uinfo->value.integer.max = platform_max - mc->min;
+	return 0;
+}
+EXPORT_SYMBOL_GPL(snd_soc_info_volsw);
+
+/**
+ * snd_soc_get_volsw - single mixer get callback
+ * @kcontrol: mixer control
+ * @ucontrol: control element information
+ *
+ * Callback to get the value of a single mixer control, or a double mixer
+ * control that spans 2 registers.
+ *
+ * Returns 0 for success.
+ */
+int snd_soc_get_volsw(struct snd_kcontrol *kcontrol,
+	struct snd_ctl_elem_value *ucontrol)
+{
+	struct snd_soc_component *component = snd_kcontrol_chip(kcontrol);
+	struct soc_mixer_control *mc =
+		(struct soc_mixer_control *)kcontrol->private_value;
+	unsigned int reg = mc->reg;
+	unsigned int reg2 = mc->rreg;
+	unsigned int shift = mc->shift;
+	unsigned int rshift = mc->rshift;
+	int max = mc->max;
+	int min = mc->min;
+	int sign_bit = mc->sign_bit;
+	unsigned int mask = (1 << fls(max)) - 1;
+	unsigned int invert = mc->invert;
+	int val;
+	int ret;
+
+	if (sign_bit)
+		mask = BIT(sign_bit + 1) - 1;
+
+	ret = snd_soc_read_signed(component, reg, mask, shift, sign_bit, &val);
+	if (ret)
+		return ret;
+
+	ucontrol->value.integer.value[0] = val - min;
+	if (invert)
+		ucontrol->value.integer.value[0] =
+			max - ucontrol->value.integer.value[0];
+
+	if (snd_soc_volsw_is_stereo(mc)) {
+		if (reg == reg2)
+			ret = snd_soc_read_signed(component, reg, mask, rshift,
+				sign_bit, &val);
+		else
+			ret = snd_soc_read_signed(component, reg2, mask, shift,
+				sign_bit, &val);
+		if (ret)
+			return ret;
+
+		ucontrol->value.integer.value[1] = val - min;
+		if (invert)
+			ucontrol->value.integer.value[1] =
+				max - ucontrol->value.integer.value[1];
+	}
+
+	return 0;
+}
+EXPORT_SYMBOL_GPL(snd_soc_get_volsw);
+
+/**
+ * snd_soc_put_volsw - single mixer put callback
+ * @kcontrol: mixer control
+ * @ucontrol: control element information
+ *
+ * Callback to set the value of a single mixer control, or a double mixer
+ * control that spans 2 registers.
+ *
+ * Returns 0 for success.
+ */
+int snd_soc_put_volsw(struct snd_kcontrol *kcontrol,
+	struct snd_ctl_elem_value *ucontrol)
+{
+	struct snd_soc_component *component = snd_kcontrol_chip(kcontrol);
+	struct soc_mixer_control *mc =
+		(struct soc_mixer_control *)kcontrol->private_value;
+	unsigned int reg = mc->reg;
+	unsigned int reg2 = mc->rreg;
+	unsigned int shift = mc->shift;
+	unsigned int rshift = mc->rshift;
+	int max = mc->max;
+	int min = mc->min;
+	unsigned int sign_bit = mc->sign_bit;
+	unsigned int mask = (1 << fls(max)) - 1;
+	unsigned int invert = mc->invert;
+	int err;
+	bool type_2r = false;
+	unsigned int val2 = 0;
+	unsigned int val, val_mask;
+
+	if (sign_bit)
+		mask = BIT(sign_bit + 1) - 1;
+
+	val = ((ucontrol->value.integer.value[0] + min) & mask);
+	if (invert)
+		val = max - val;
+	val_mask = mask << shift;
+	val = val << shift;
+	if (snd_soc_volsw_is_stereo(mc)) {
+		val2 = ((ucontrol->value.integer.value[1] + min) & mask);
+		if (invert)
+			val2 = max - val2;
+		if (reg == reg2) {
+			val_mask |= mask << rshift;
+			val |= val2 << rshift;
+		} else {
+			val2 = val2 << shift;
+			type_2r = true;
+		}
+	}
+	err = snd_soc_component_update_bits(component, reg, val_mask, val);
+	if (err < 0)
+		return err;
+
+	if (type_2r)
+		err = snd_soc_component_update_bits(component, reg2, val_mask,
+			val2);
+
+	return err;
+}
+EXPORT_SYMBOL_GPL(snd_soc_put_volsw);
+
+/**
+ * snd_soc_get_volsw_sx - single mixer get callback
+ * @kcontrol: mixer control
+ * @ucontrol: control element information
+ *
+ * Callback to get the value of a single mixer control, or a double mixer
+ * control that spans 2 registers.
+ *
+ * Returns 0 for success.
+ */
+int snd_soc_get_volsw_sx(struct snd_kcontrol *kcontrol,
+		      struct snd_ctl_elem_value *ucontrol)
+{
+	struct snd_soc_component *component = snd_kcontrol_chip(kcontrol);
+	struct soc_mixer_control *mc =
+	    (struct soc_mixer_control *)kcontrol->private_value;
+	unsigned int reg = mc->reg;
+	unsigned int reg2 = mc->rreg;
+	unsigned int shift = mc->shift;
+	unsigned int rshift = mc->rshift;
+	int max = mc->max;
+	int min = mc->min;
+	int mask = (1 << (fls(min + max) - 1)) - 1;
+	unsigned int val;
+	int ret;
+
+	ret = snd_soc_component_read(component, reg, &val);
+	if (ret < 0)
+		return ret;
+
+	ucontrol->value.integer.value[0] = ((val >> shift) - min) & mask;
+
+	if (snd_soc_volsw_is_stereo(mc)) {
+		ret = snd_soc_component_read(component, reg2, &val);
+		if (ret < 0)
+			return ret;
+
+		val = ((val >> rshift) - min) & mask;
+		ucontrol->value.integer.value[1] = val;
+	}
+
+	return 0;
+}
+EXPORT_SYMBOL_GPL(snd_soc_get_volsw_sx);
+
+/**
+ * snd_soc_put_volsw_sx - double mixer set callback
+ * @kcontrol: mixer control
+ * @uinfo: control element information
+ *
+ * Callback to set the value of a double mixer control that spans 2 registers.
+ *
+ * Returns 0 for success.
+ */
+int snd_soc_put_volsw_sx(struct snd_kcontrol *kcontrol,
+			 struct snd_ctl_elem_value *ucontrol)
+{
+	struct snd_soc_component *component = snd_kcontrol_chip(kcontrol);
+	struct soc_mixer_control *mc =
+	    (struct soc_mixer_control *)kcontrol->private_value;
+
+	unsigned int reg = mc->reg;
+	unsigned int reg2 = mc->rreg;
+	unsigned int shift = mc->shift;
+	unsigned int rshift = mc->rshift;
+	int max = mc->max;
+	int min = mc->min;
+	int mask = (1 << (fls(min + max) - 1)) - 1;
+	int err = 0;
+	unsigned int val, val_mask, val2 = 0;
+
+	val_mask = mask << shift;
+	val = (ucontrol->value.integer.value[0] + min) & mask;
+	val = val << shift;
+
+	err = snd_soc_component_update_bits(component, reg, val_mask, val);
+	if (err < 0)
+		return err;
+
+	if (snd_soc_volsw_is_stereo(mc)) {
+		val_mask = mask << rshift;
+		val2 = (ucontrol->value.integer.value[1] + min) & mask;
+		val2 = val2 << rshift;
+
+		err = snd_soc_component_update_bits(component, reg2, val_mask,
+			val2);
+	}
+	return err;
+}
+EXPORT_SYMBOL_GPL(snd_soc_put_volsw_sx);
+
+/**
+ * snd_soc_info_volsw_s8 - signed mixer info callback
+ * @kcontrol: mixer control
+ * @uinfo: control element information
+ *
+ * Callback to provide information about a signed mixer control.
+ *
+ * Returns 0 for success.
+ */
+int snd_soc_info_volsw_s8(struct snd_kcontrol *kcontrol,
+	struct snd_ctl_elem_info *uinfo)
+{
+	struct soc_mixer_control *mc =
+		(struct soc_mixer_control *)kcontrol->private_value;
+	int platform_max;
+	int min = mc->min;
+
+	if (!mc->platform_max)
+		mc->platform_max = mc->max;
+	platform_max = mc->platform_max;
+
+	uinfo->type = SNDRV_CTL_ELEM_TYPE_INTEGER;
+	uinfo->count = 2;
+	uinfo->value.integer.min = 0;
+	uinfo->value.integer.max = platform_max - min;
+	return 0;
+}
+EXPORT_SYMBOL_GPL(snd_soc_info_volsw_s8);
+
+/**
+ * snd_soc_get_volsw_s8 - signed mixer get callback
+ * @kcontrol: mixer control
+ * @ucontrol: control element information
+ *
+ * Callback to get the value of a signed mixer control.
+ *
+ * Returns 0 for success.
+ */
+int snd_soc_get_volsw_s8(struct snd_kcontrol *kcontrol,
+	struct snd_ctl_elem_value *ucontrol)
+{
+	struct soc_mixer_control *mc =
+		(struct soc_mixer_control *)kcontrol->private_value;
+	struct snd_soc_component *component = snd_kcontrol_chip(kcontrol);
+	unsigned int reg = mc->reg;
+	unsigned int val;
+	int min = mc->min;
+	int ret;
+
+	ret = snd_soc_component_read(component, reg, &val);
+	if (ret)
+		return ret;
+
+	ucontrol->value.integer.value[0] =
+		((signed char)(val & 0xff))-min;
+	ucontrol->value.integer.value[1] =
+		((signed char)((val >> 8) & 0xff))-min;
+	return 0;
+}
+EXPORT_SYMBOL_GPL(snd_soc_get_volsw_s8);
+
+/**
+ * snd_soc_put_volsw_sgn - signed mixer put callback
+ * @kcontrol: mixer control
+ * @ucontrol: control element information
+ *
+ * Callback to set the value of a signed mixer control.
+ *
+ * Returns 0 for success.
+ */
+int snd_soc_put_volsw_s8(struct snd_kcontrol *kcontrol,
+	struct snd_ctl_elem_value *ucontrol)
+{
+	struct soc_mixer_control *mc =
+		(struct soc_mixer_control *)kcontrol->private_value;
+	struct snd_soc_component *component = snd_kcontrol_chip(kcontrol);
+	unsigned int reg = mc->reg;
+	int min = mc->min;
+	unsigned int val;
+
+	val = (ucontrol->value.integer.value[0]+min) & 0xff;
+	val |= ((ucontrol->value.integer.value[1]+min) & 0xff) << 8;
+
+	return snd_soc_component_update_bits(component, reg, 0xffff, val);
+}
+EXPORT_SYMBOL_GPL(snd_soc_put_volsw_s8);
+
+/**
+ * snd_soc_info_volsw_range - single mixer info callback with range.
+ * @kcontrol: mixer control
+ * @uinfo: control element information
+ *
+ * Callback to provide information, within a range, about a single
+ * mixer control.
+ *
+ * returns 0 for success.
+ */
+int snd_soc_info_volsw_range(struct snd_kcontrol *kcontrol,
+	struct snd_ctl_elem_info *uinfo)
+{
+	struct soc_mixer_control *mc =
+		(struct soc_mixer_control *)kcontrol->private_value;
+	int platform_max;
+	int min = mc->min;
+
+	if (!mc->platform_max)
+		mc->platform_max = mc->max;
+	platform_max = mc->platform_max;
+
+	uinfo->type = SNDRV_CTL_ELEM_TYPE_INTEGER;
+	uinfo->count = snd_soc_volsw_is_stereo(mc) ? 2 : 1;
+	uinfo->value.integer.min = 0;
+	uinfo->value.integer.max = platform_max - min;
+
+	return 0;
+}
+EXPORT_SYMBOL_GPL(snd_soc_info_volsw_range);
+
+/**
+ * snd_soc_put_volsw_range - single mixer put value callback with range.
+ * @kcontrol: mixer control
+ * @ucontrol: control element information
+ *
+ * Callback to set the value, within a range, for a single mixer control.
+ *
+ * Returns 0 for success.
+ */
+int snd_soc_put_volsw_range(struct snd_kcontrol *kcontrol,
+	struct snd_ctl_elem_value *ucontrol)
+{
+	struct soc_mixer_control *mc =
+		(struct soc_mixer_control *)kcontrol->private_value;
+	struct snd_soc_component *component = snd_kcontrol_chip(kcontrol);
+	unsigned int reg = mc->reg;
+	unsigned int rreg = mc->rreg;
+	unsigned int shift = mc->shift;
+	int min = mc->min;
+	int max = mc->max;
+	unsigned int mask = (1 << fls(max)) - 1;
+	unsigned int invert = mc->invert;
+	unsigned int val, val_mask;
+	int ret;
+
+	val = ((ucontrol->value.integer.value[0] + min) & mask);
+	if (invert)
+		val = max - val;
+	val_mask = mask << shift;
+	val = val << shift;
+
+	ret = snd_soc_component_update_bits(component, reg, val_mask, val);
+	if (ret < 0)
+		return ret;
+
+	if (snd_soc_volsw_is_stereo(mc)) {
+		val = ((ucontrol->value.integer.value[1] + min) & mask);
+		if (invert)
+			val = max - val;
+		val_mask = mask << shift;
+		val = val << shift;
+
+		ret = snd_soc_component_update_bits(component, rreg, val_mask,
+			val);
+	}
+
+	return ret;
+}
+EXPORT_SYMBOL_GPL(snd_soc_put_volsw_range);
+
+/**
+ * snd_soc_get_volsw_range - single mixer get callback with range
+ * @kcontrol: mixer control
+ * @ucontrol: control element information
+ *
+ * Callback to get the value, within a range, of a single mixer control.
+ *
+ * Returns 0 for success.
+ */
+int snd_soc_get_volsw_range(struct snd_kcontrol *kcontrol,
+	struct snd_ctl_elem_value *ucontrol)
+{
+	struct snd_soc_component *component = snd_kcontrol_chip(kcontrol);
+	struct soc_mixer_control *mc =
+		(struct soc_mixer_control *)kcontrol->private_value;
+	unsigned int reg = mc->reg;
+	unsigned int rreg = mc->rreg;
+	unsigned int shift = mc->shift;
+	int min = mc->min;
+	int max = mc->max;
+	unsigned int mask = (1 << fls(max)) - 1;
+	unsigned int invert = mc->invert;
+	unsigned int val;
+	int ret;
+
+	ret = snd_soc_component_read(component, reg, &val);
+	if (ret)
+		return ret;
+
+	ucontrol->value.integer.value[0] = (val >> shift) & mask;
+	if (invert)
+		ucontrol->value.integer.value[0] =
+			max - ucontrol->value.integer.value[0];
+	ucontrol->value.integer.value[0] =
+		ucontrol->value.integer.value[0] - min;
+
+	if (snd_soc_volsw_is_stereo(mc)) {
+		ret = snd_soc_component_read(component, rreg, &val);
+		if (ret)
+			return ret;
+
+		ucontrol->value.integer.value[1] = (val >> shift) & mask;
+		if (invert)
+			ucontrol->value.integer.value[1] =
+				max - ucontrol->value.integer.value[1];
+		ucontrol->value.integer.value[1] =
+			ucontrol->value.integer.value[1] - min;
+	}
+
+	return 0;
+}
+EXPORT_SYMBOL_GPL(snd_soc_get_volsw_range);
+
+/**
+ * snd_soc_limit_volume - Set new limit to an existing volume control.
+ *
+ * @codec: where to look for the control
+ * @name: Name of the control
+ * @max: new maximum limit
+ *
+ * Return 0 for success, else error.
+ */
+int snd_soc_limit_volume(struct snd_soc_codec *codec,
+	const char *name, int max)
+{
+	struct snd_card *card = codec->component.card->snd_card;
+	struct snd_kcontrol *kctl;
+	struct soc_mixer_control *mc;
+	int found = 0;
+	int ret = -EINVAL;
+
+	/* Sanity check for name and max */
+	if (unlikely(!name || max <= 0))
+		return -EINVAL;
+
+	list_for_each_entry(kctl, &card->controls, list) {
+		if (!strncmp(kctl->id.name, name, sizeof(kctl->id.name))) {
+			found = 1;
+			break;
+		}
+	}
+	if (found) {
+		mc = (struct soc_mixer_control *)kctl->private_value;
+		if (max <= mc->max) {
+			mc->platform_max = max;
+			ret = 0;
+		}
+	}
+	return ret;
+}
+EXPORT_SYMBOL_GPL(snd_soc_limit_volume);
+
+int snd_soc_bytes_info(struct snd_kcontrol *kcontrol,
+		       struct snd_ctl_elem_info *uinfo)
+{
+	struct snd_soc_component *component = snd_kcontrol_chip(kcontrol);
+	struct soc_bytes *params = (void *)kcontrol->private_value;
+
+	uinfo->type = SNDRV_CTL_ELEM_TYPE_BYTES;
+	uinfo->count = params->num_regs * component->val_bytes;
+
+	return 0;
+}
+EXPORT_SYMBOL_GPL(snd_soc_bytes_info);
+
+int snd_soc_bytes_get(struct snd_kcontrol *kcontrol,
+		      struct snd_ctl_elem_value *ucontrol)
+{
+	struct snd_soc_component *component = snd_kcontrol_chip(kcontrol);
+	struct soc_bytes *params = (void *)kcontrol->private_value;
+	int ret;
+
+	if (component->regmap)
+		ret = regmap_raw_read(component->regmap, params->base,
+				      ucontrol->value.bytes.data,
+				      params->num_regs * component->val_bytes);
+	else
+		ret = -EINVAL;
+
+	/* Hide any masked bytes to ensure consistent data reporting */
+	if (ret == 0 && params->mask) {
+		switch (component->val_bytes) {
+		case 1:
+			ucontrol->value.bytes.data[0] &= ~params->mask;
+			break;
+		case 2:
+			((u16 *)(&ucontrol->value.bytes.data))[0]
+				&= cpu_to_be16(~params->mask);
+			break;
+		case 4:
+			((u32 *)(&ucontrol->value.bytes.data))[0]
+				&= cpu_to_be32(~params->mask);
+			break;
+		default:
+			return -EINVAL;
+		}
+	}
+
+	return ret;
+}
+EXPORT_SYMBOL_GPL(snd_soc_bytes_get);
+
+int snd_soc_bytes_put(struct snd_kcontrol *kcontrol,
+		      struct snd_ctl_elem_value *ucontrol)
+{
+	struct snd_soc_component *component = snd_kcontrol_chip(kcontrol);
+	struct soc_bytes *params = (void *)kcontrol->private_value;
+	int ret, len;
+	unsigned int val, mask;
+	void *data;
+
+	if (!component->regmap)
+		return -EINVAL;
+
+	len = params->num_regs * component->val_bytes;
+
+	data = kmemdup(ucontrol->value.bytes.data, len, GFP_KERNEL | GFP_DMA);
+	if (!data)
+		return -ENOMEM;
+
+	/*
+	 * If we've got a mask then we need to preserve the register
+	 * bits.  We shouldn't modify the incoming data so take a
+	 * copy.
+	 */
+	if (params->mask) {
+		ret = regmap_read(component->regmap, params->base, &val);
+		if (ret != 0)
+			goto out;
+
+		val &= params->mask;
+
+		switch (component->val_bytes) {
+		case 1:
+			((u8 *)data)[0] &= ~params->mask;
+			((u8 *)data)[0] |= val;
+			break;
+		case 2:
+			mask = ~params->mask;
+			ret = regmap_parse_val(component->regmap,
+							&mask, &mask);
+			if (ret != 0)
+				goto out;
+
+			((u16 *)data)[0] &= mask;
+
+			ret = regmap_parse_val(component->regmap,
+							&val, &val);
+			if (ret != 0)
+				goto out;
+
+			((u16 *)data)[0] |= val;
+			break;
+		case 4:
+			mask = ~params->mask;
+			ret = regmap_parse_val(component->regmap,
+							&mask, &mask);
+			if (ret != 0)
+				goto out;
+
+			((u32 *)data)[0] &= mask;
+
+			ret = regmap_parse_val(component->regmap,
+							&val, &val);
+			if (ret != 0)
+				goto out;
+
+			((u32 *)data)[0] |= val;
+			break;
+		default:
+			ret = -EINVAL;
+			goto out;
+		}
+	}
+
+	ret = regmap_raw_write(component->regmap, params->base,
+			       data, len);
+
+out:
+	kfree(data);
 
-	return kcontrol;
+	return ret;
 }
-EXPORT_SYMBOL_GPL(snd_soc_cnew);
+EXPORT_SYMBOL_GPL(snd_soc_bytes_put);
 
-static int snd_soc_add_controls(struct snd_card *card, struct device *dev,
-	const struct snd_kcontrol_new *controls, int num_controls,
-	const char *prefix, void *data)
+int snd_soc_bytes_info_ext(struct snd_kcontrol *kcontrol,
+			struct snd_ctl_elem_info *ucontrol)
 {
-	int err, i;
+	struct soc_bytes_ext *params = (void *)kcontrol->private_value;
 
-	for (i = 0; i < num_controls; i++) {
-		const struct snd_kcontrol_new *control = &controls[i];
-		err = snd_ctl_add(card, snd_soc_cnew(control, data,
-						     control->name, prefix));
-		if (err < 0) {
-			dev_err(dev, "ASoC: Failed to add %s: %d\n",
-				control->name, err);
-			return err;
-		}
-	}
+	ucontrol->type = SNDRV_CTL_ELEM_TYPE_BYTES;
+	ucontrol->count = params->max;
 
 	return 0;
 }
+EXPORT_SYMBOL_GPL(snd_soc_bytes_info_ext);
 
-struct snd_kcontrol *snd_soc_card_get_kcontrol(struct snd_soc_card *soc_card,
-					       const char *name)
+int snd_soc_bytes_tlv_callback(struct snd_kcontrol *kcontrol, int op_flag,
+				unsigned int size, unsigned int __user *tlv)
 {
-	struct snd_card *card = soc_card->snd_card;
-	struct snd_kcontrol *kctl;
-
-	if (unlikely(!name))
-		return NULL;
-
-	list_for_each_entry(kctl, &card->controls, list)
-		if (!strncmp(kctl->id.name, name, sizeof(kctl->id.name)))
-			return kctl;
-	return NULL;
+	struct soc_bytes_ext *params = (void *)kcontrol->private_value;
+	unsigned int count = size < params->max ? size : params->max;
+	int ret = -ENXIO;
+
+	switch (op_flag) {
+	case SNDRV_CTL_TLV_OP_READ:
+		if (params->get)
+			ret = params->get(tlv, count);
+		break;
+	case SNDRV_CTL_TLV_OP_WRITE:
+		if (params->put)
+			ret = params->put(tlv, count);
+		break;
+	}
+	return ret;
 }
-EXPORT_SYMBOL_GPL(snd_soc_card_get_kcontrol);
+EXPORT_SYMBOL_GPL(snd_soc_bytes_tlv_callback);
 
 /**
- * snd_soc_add_component_controls - Add an array of controls to a component.
- *
- * @component: Component to add controls to
- * @controls: Array of controls to add
- * @num_controls: Number of elements in the array
+ * snd_soc_info_xr_sx - signed multi register info callback
+ * @kcontrol: mreg control
+ * @uinfo: control element information
+ *
+ * Callback to provide information of a control that can
+ * span multiple codec registers which together
+ * forms a single signed value in a MSB/LSB manner.
  *
- * Return: 0 for success, else error.
+ * Returns 0 for success.
  */
-int snd_soc_add_component_controls(struct snd_soc_component *component,
-	const struct snd_kcontrol_new *controls, unsigned int num_controls)
+int snd_soc_info_xr_sx(struct snd_kcontrol *kcontrol,
+	struct snd_ctl_elem_info *uinfo)
 {
-	struct snd_card *card = component->card->snd_card;
+	struct soc_mreg_control *mc =
+		(struct soc_mreg_control *)kcontrol->private_value;
+	uinfo->type = SNDRV_CTL_ELEM_TYPE_INTEGER;
+	uinfo->count = 1;
+	uinfo->value.integer.min = mc->min;
+	uinfo->value.integer.max = mc->max;
 
-	return snd_soc_add_controls(card, component->dev, controls,
-			num_controls, component->name_prefix, component);
+	return 0;
 }
-EXPORT_SYMBOL_GPL(snd_soc_add_component_controls);
+EXPORT_SYMBOL_GPL(snd_soc_info_xr_sx);
 
 /**
- * snd_soc_add_codec_controls - add an array of controls to a codec.
- * Convenience function to add a list of controls. Many codecs were
- * duplicating this code.
- *
- * @codec: codec to add controls to
- * @controls: array of controls to add
- * @num_controls: number of elements in the array
+ * snd_soc_get_xr_sx - signed multi register get callback
+ * @kcontrol: mreg control
+ * @ucontrol: control element information
+ *
+ * Callback to get the value of a control that can span
+ * multiple codec registers which together forms a single
+ * signed value in a MSB/LSB manner. The control supports
+ * specifying total no of bits used to allow for bitfields
+ * across the multiple codec registers.
  *
- * Return 0 for success, else error.
+ * Returns 0 for success.
  */
-int snd_soc_add_codec_controls(struct snd_soc_codec *codec,
-	const struct snd_kcontrol_new *controls, unsigned int num_controls)
+int snd_soc_get_xr_sx(struct snd_kcontrol *kcontrol,
+	struct snd_ctl_elem_value *ucontrol)
 {
-	return snd_soc_add_component_controls(&codec->component, controls,
-		num_controls);
+	struct snd_soc_component *component = snd_kcontrol_chip(kcontrol);
+	struct soc_mreg_control *mc =
+		(struct soc_mreg_control *)kcontrol->private_value;
+	unsigned int regbase = mc->regbase;
+	unsigned int regcount = mc->regcount;
+	unsigned int regwshift = component->val_bytes * BITS_PER_BYTE;
+	unsigned int regwmask = (1<<regwshift)-1;
+	unsigned int invert = mc->invert;
+	unsigned long mask = (1UL<<mc->nbits)-1;
+	long min = mc->min;
+	long max = mc->max;
+	long val = 0;
+	unsigned int regval;
+	unsigned int i;
+	int ret;
+
+	for (i = 0; i < regcount; i++) {
+		ret = snd_soc_component_read(component, regbase+i, &regval);
+		if (ret)
+			return ret;
+		val |= (regval & regwmask) << (regwshift*(regcount-i-1));
+	}
+	val &= mask;
+	if (min < 0 && val > max)
+		val |= ~mask;
+	if (invert)
+		val = max - val;
+	ucontrol->value.integer.value[0] = val;
+
+	return 0;
 }
-EXPORT_SYMBOL_GPL(snd_soc_add_codec_controls);
+EXPORT_SYMBOL_GPL(snd_soc_get_xr_sx);
 
 /**
- * snd_soc_add_platform_controls - add an array of controls to a platform.
- * Convenience function to add a list of controls.
- *
- * @platform: platform to add controls to
- * @controls: array of controls to add
- * @num_controls: number of elements in the array
+ * snd_soc_put_xr_sx - signed multi register get callback
+ * @kcontrol: mreg control
+ * @ucontrol: control element information
+ *
+ * Callback to set the value of a control that can span
+ * multiple codec registers which together forms a single
+ * signed value in a MSB/LSB manner. The control supports
+ * specifying total no of bits used to allow for bitfields
+ * across the multiple codec registers.
  *
- * Return 0 for success, else error.
+ * Returns 0 for success.
  */
-int snd_soc_add_platform_controls(struct snd_soc_platform *platform,
-	const struct snd_kcontrol_new *controls, unsigned int num_controls)
+int snd_soc_put_xr_sx(struct snd_kcontrol *kcontrol,
+	struct snd_ctl_elem_value *ucontrol)
 {
-	return snd_soc_add_component_controls(&platform->component, controls,
-		num_controls);
+	struct snd_soc_component *component = snd_kcontrol_chip(kcontrol);
+	struct soc_mreg_control *mc =
+		(struct soc_mreg_control *)kcontrol->private_value;
+	unsigned int regbase = mc->regbase;
+	unsigned int regcount = mc->regcount;
+	unsigned int regwshift = component->val_bytes * BITS_PER_BYTE;
+	unsigned int regwmask = (1<<regwshift)-1;
+	unsigned int invert = mc->invert;
+	unsigned long mask = (1UL<<mc->nbits)-1;
+	long max = mc->max;
+	long val = ucontrol->value.integer.value[0];
+	unsigned int i, regval, regmask;
+	int err;
+
+	if (invert)
+		val = max - val;
+	val &= mask;
+	for (i = 0; i < regcount; i++) {
+		regval = (val >> (regwshift*(regcount-i-1))) & regwmask;
+		regmask = (mask >> (regwshift*(regcount-i-1))) & regwmask;
+		err = snd_soc_component_update_bits(component, regbase+i,
+				regmask, regval);
+		if (err < 0)
+			return err;
+	}
+
+	return 0;
 }
-EXPORT_SYMBOL_GPL(snd_soc_add_platform_controls);
+EXPORT_SYMBOL_GPL(snd_soc_put_xr_sx);
 
 /**
- * snd_soc_add_card_controls - add an array of controls to a SoC card.
- * Convenience function to add a list of controls.
+ * snd_soc_get_strobe - strobe get callback
+ * @kcontrol: mixer control
+ * @ucontrol: control element information
  *
- * @soc_card: SoC card to add controls to
- * @controls: array of controls to add
- * @num_controls: number of elements in the array
+ * Callback get the value of a strobe mixer control.
  *
- * Return 0 for success, else error.
+ * Returns 0 for success.
  */
-int snd_soc_add_card_controls(struct snd_soc_card *soc_card,
-	const struct snd_kcontrol_new *controls, int num_controls)
+int snd_soc_get_strobe(struct snd_kcontrol *kcontrol,
+	struct snd_ctl_elem_value *ucontrol)
 {
-	struct snd_card *card = soc_card->snd_card;
+	struct snd_soc_component *component = snd_kcontrol_chip(kcontrol);
+	struct soc_mixer_control *mc =
+		(struct soc_mixer_control *)kcontrol->private_value;
+	unsigned int reg = mc->reg;
+	unsigned int shift = mc->shift;
+	unsigned int mask = 1 << shift;
+	unsigned int invert = mc->invert != 0;
+	unsigned int val;
+	int ret;
 
-	return snd_soc_add_controls(card, soc_card->dev, controls, num_controls,
-			NULL, soc_card);
+	ret = snd_soc_component_read(component, reg, &val);
+	if (ret)
+		return ret;
+
+	val &= mask;
+
+	if (shift != 0 && val != 0)
+		val = val >> shift;
+	ucontrol->value.enumerated.item[0] = val ^ invert;
+
+	return 0;
 }
-EXPORT_SYMBOL_GPL(snd_soc_add_card_controls);
+EXPORT_SYMBOL_GPL(snd_soc_get_strobe);
 
 /**
- * snd_soc_add_dai_controls - add an array of controls to a DAI.
- * Convienience function to add a list of controls.
+ * snd_soc_put_strobe - strobe put callback
+ * @kcontrol: mixer control
+ * @ucontrol: control element information
  *
- * @dai: DAI to add controls to
- * @controls: array of controls to add
- * @num_controls: number of elements in the array
+ * Callback strobe a register bit to high then low (or the inverse)
+ * in one pass of a single mixer enum control.
  *
- * Return 0 for success, else error.
+ * Returns 1 for success.
  */
-int snd_soc_add_dai_controls(struct snd_soc_dai *dai,
-	const struct snd_kcontrol_new *controls, int num_controls)
+int snd_soc_put_strobe(struct snd_kcontrol *kcontrol,
+	struct snd_ctl_elem_value *ucontrol)
 {
-	struct snd_card *card = dai->component->card->snd_card;
+	struct snd_soc_component *component = snd_kcontrol_chip(kcontrol);
+	struct soc_mixer_control *mc =
+		(struct soc_mixer_control *)kcontrol->private_value;
+	unsigned int reg = mc->reg;
+	unsigned int shift = mc->shift;
+	unsigned int mask = 1 << shift;
+	unsigned int invert = mc->invert != 0;
+	unsigned int strobe = ucontrol->value.enumerated.item[0] != 0;
+	unsigned int val1 = (strobe ^ invert) ? mask : 0;
+	unsigned int val2 = (strobe ^ invert) ? 0 : mask;
+	int err;
 
-	return snd_soc_add_controls(card, dai->dev, controls, num_controls,
-			NULL, dai);
+	err = snd_soc_component_update_bits(component, reg, mask, val1);
+	if (err < 0)
+		return err;
+
+	return snd_soc_component_update_bits(component, reg, mask, val2);
 }
-EXPORT_SYMBOL_GPL(snd_soc_add_dai_controls);
+EXPORT_SYMBOL_GPL(snd_soc_put_strobe);
 
 /**
  * snd_soc_dai_set_sysclk - configure DAI system or master clock.
@@ -2198,27 +3665,15 @@
 }
 
 /**
- * snd_soc_dai_set_tdm_slot() - Configures a DAI for TDM operation
- * @dai: The DAI to configure
+ * snd_soc_dai_set_tdm_slot - configure DAI TDM.
+ * @dai: DAI
  * @tx_mask: bitmask representing active TX slots.
  * @rx_mask: bitmask representing active RX slots.
  * @slots: Number of slots in use.
  * @slot_width: Width in bits for each slot.
  *
- * This function configures the specified DAI for TDM operation. @slot contains
- * the total number of slots of the TDM stream and @slot_with the width of each
- * slot in bit clock cycles. @tx_mask and @rx_mask are bitmasks specifying the
- * active slots of the TDM stream for the specified DAI, i.e. which slots the
- * DAI should write to or read from. If a bit is set the corresponding slot is
- * active, if a bit is cleared the corresponding slot is inactive. Bit 0 maps to
- * the first slot, bit 1 to the second slot and so on. The first active slot
- * maps to the first channel of the DAI, the second active slot to the second
- * channel and so on.
- *
- * TDM mode can be disabled by passing 0 for @slots. In this case @tx_mask,
- * @rx_mask and @slot_width will be ignored.
- *
- * Returns 0 on success, a negative error code otherwise.
+ * Configures a DAI for TDM operation. Both mask and slots are codec and DAI
+ * specific.
  */
 int snd_soc_dai_set_tdm_slot(struct snd_soc_dai *dai,
 	unsigned int tx_mask, unsigned int rx_mask, int slots, int slot_width)
@@ -2411,6 +3866,8 @@
 
 	snd_soc_initialize_card_lists(card);
 
+	soc_init_card_debugfs(card);
+
 	card->rtd = devm_kzalloc(card->dev,
 				 sizeof(struct snd_soc_pcm_runtime) *
 				 (card->num_links + card->num_aux_devs),
@@ -2441,7 +3898,7 @@
 
 	ret = snd_soc_instantiate_card(card);
 	if (ret != 0)
-		return ret;
+		soc_cleanup_card_debugfs(card);
 
 	/* deactivate pins to sleep state */
 	for (i = 0; i < card->num_rtd; i++) {
@@ -2471,12 +3928,9 @@
  */
 int snd_soc_unregister_card(struct snd_soc_card *card)
 {
-	if (card->instantiated) {
-		card->instantiated = false;
-		snd_soc_dapm_shutdown(card);
+	if (card->instantiated)
 		soc_cleanup_card_resources(card);
-		dev_dbg(card->dev, "ASoC: Unregistered card '%s'\n", card->name);
-	}
+	dev_dbg(card->dev, "ASoC: Unregistered card '%s'\n", card->name);
 
 	return 0;
 }
@@ -2662,8 +4116,6 @@
 
 	component->dev = dev;
 	component->driver = driver;
-	component->probe = component->driver->probe;
-	component->remove = component->driver->remove;
 
 	if (!component->dapm_ptr)
 		component->dapm_ptr = &component->dapm;
@@ -2678,76 +4130,14 @@
 	if (driver->stream_event)
 		dapm->stream_event = snd_soc_component_stream_event;
 
-	component->controls = driver->controls;
-	component->num_controls = driver->num_controls;
-	component->dapm_widgets = driver->dapm_widgets;
-	component->num_dapm_widgets = driver->num_dapm_widgets;
-	component->dapm_routes = driver->dapm_routes;
-	component->num_dapm_routes = driver->num_dapm_routes;
-
 	INIT_LIST_HEAD(&component->dai_list);
 	mutex_init(&component->io_mutex);
 
 	return 0;
 }
 
-static void snd_soc_component_setup_regmap(struct snd_soc_component *component)
-{
-	int val_bytes = regmap_get_val_bytes(component->regmap);
-
-	/* Errors are legitimate for non-integer byte multiples */
-	if (val_bytes > 0)
-		component->val_bytes = val_bytes;
-}
-
-#ifdef CONFIG_REGMAP
-
-/**
- * snd_soc_component_init_regmap() - Initialize regmap instance for the component
- * @component: The component for which to initialize the regmap instance
- * @regmap: The regmap instance that should be used by the component
- *
- * This function allows deferred assignment of the regmap instance that is
- * associated with the component. Only use this if the regmap instance is not
- * yet ready when the component is registered. The function must also be called
- * before the first IO attempt of the component.
- */
-void snd_soc_component_init_regmap(struct snd_soc_component *component,
-	struct regmap *regmap)
-{
-	component->regmap = regmap;
-	snd_soc_component_setup_regmap(component);
-}
-EXPORT_SYMBOL_GPL(snd_soc_component_init_regmap);
-
-/**
- * snd_soc_component_exit_regmap() - De-initialize regmap instance for the component
- * @component: The component for which to de-initialize the regmap instance
- *
- * Calls regmap_exit() on the regmap instance associated to the component and
- * removes the regmap instance from the component.
- *
- * This function should only be used if snd_soc_component_init_regmap() was used
- * to initialize the regmap instance.
- */
-void snd_soc_component_exit_regmap(struct snd_soc_component *component)
-{
-	regmap_exit(component->regmap);
-	component->regmap = NULL;
-}
-EXPORT_SYMBOL_GPL(snd_soc_component_exit_regmap);
-
-#endif
-
 static void snd_soc_component_add_unlocked(struct snd_soc_component *component)
 {
-	if (!component->write && !component->read) {
-		if (!component->regmap)
-			component->regmap = dev_get_regmap(component->dev, NULL);
-		if (component->regmap)
-			snd_soc_component_setup_regmap(component);
-	}
-
 	list_add(&component->list, &component_list);
 }
 
@@ -2769,6 +4159,13 @@
 	list_del(&component->list);
 }
 
+static void snd_soc_component_del(struct snd_soc_component *component)
+{
+	mutex_lock(&client_mutex);
+	snd_soc_component_del_unlocked(component);
+	mutex_unlock(&client_mutex);
+}
+
 int snd_soc_register_component(struct device *dev,
 			       const struct snd_soc_component_driver *cmpnt_drv,
 			       struct snd_soc_dai_driver *dai_drv,
@@ -2792,7 +4189,7 @@
 
 	ret = snd_soc_register_dais(cmpnt, dai_drv, num_dai, true);
 	if (ret < 0) {
-		dev_err(dev, "ASoC: Failed to register DAIs: %d\n", ret);
+		dev_err(dev, "ASoC: Failed to regster DAIs: %d\n", ret);
 		goto err_cleanup;
 	}
 
@@ -2816,34 +4213,35 @@
 {
 	struct snd_soc_component *cmpnt;
 
-	mutex_lock(&client_mutex);
 	list_for_each_entry(cmpnt, &component_list, list) {
 		if (dev == cmpnt->dev && cmpnt->registered_as_component)
 			goto found;
 	}
-	mutex_unlock(&client_mutex);
 	return;
 
 found:
-	snd_soc_component_del_unlocked(cmpnt);
-	mutex_unlock(&client_mutex);
+	snd_soc_component_del(cmpnt);
 	snd_soc_component_cleanup(cmpnt);
 	kfree(cmpnt);
 }
 EXPORT_SYMBOL_GPL(snd_soc_unregister_component);
 
-static int snd_soc_platform_drv_probe(struct snd_soc_component *component)
+static int snd_soc_platform_drv_write(struct snd_soc_component *component,
+	unsigned int reg, unsigned int val)
 {
 	struct snd_soc_platform *platform = snd_soc_component_to_platform(component);
 
-	return platform->driver->probe(platform);
+	return platform->driver->write(platform, reg, val);
 }
 
-static void snd_soc_platform_drv_remove(struct snd_soc_component *component)
+static int snd_soc_platform_drv_read(struct snd_soc_component *component,
+	unsigned int reg, unsigned int *val)
 {
 	struct snd_soc_platform *platform = snd_soc_component_to_platform(component);
 
-	platform->driver->remove(platform);
+	*val = platform->driver->read(platform, reg);
+
+	return 0;
 }
 
 /**
@@ -2864,15 +4262,10 @@
 
 	platform->dev = dev;
 	platform->driver = platform_drv;
-
-	if (platform_drv->probe)
-		platform->component.probe = snd_soc_platform_drv_probe;
-	if (platform_drv->remove)
-		platform->component.remove = snd_soc_platform_drv_remove;
-
-#ifdef CONFIG_DEBUG_FS
-	platform->component.debugfs_prefix = "platform";
-#endif
+	if (platform_drv->write)
+		platform->component.write = snd_soc_platform_drv_write;
+	if (platform_drv->read)
+		platform->component.read = snd_soc_platform_drv_read;
 
 	mutex_lock(&client_mutex);
 	snd_soc_component_add_unlocked(&platform->component);
@@ -2923,10 +4316,10 @@
 	snd_soc_component_del_unlocked(&platform->component);
 	mutex_unlock(&client_mutex);
 
+	snd_soc_component_cleanup(&platform->component);
+
 	dev_dbg(platform->dev, "ASoC: Unregistered platform '%s'\n",
 		platform->component.name);
-
-	snd_soc_component_cleanup(&platform->component);
 }
 EXPORT_SYMBOL_GPL(snd_soc_remove_platform);
 
@@ -2934,14 +4327,10 @@
 {
 	struct snd_soc_platform *platform;
 
-	mutex_lock(&client_mutex);
 	list_for_each_entry(platform, &platform_list, list) {
-		if (dev == platform->dev) {
-			mutex_unlock(&client_mutex);
+		if (dev == platform->dev)
 			return platform;
-		}
 	}
-	mutex_unlock(&client_mutex);
 
 	return NULL;
 }
@@ -2998,20 +4387,6 @@
 			stream->formats |= codec_format_map[i];
 }
 
-static int snd_soc_codec_drv_probe(struct snd_soc_component *component)
-{
-	struct snd_soc_codec *codec = snd_soc_component_to_codec(component);
-
-	return codec->driver->probe(codec);
-}
-
-static void snd_soc_codec_drv_remove(struct snd_soc_component *component)
-{
-	struct snd_soc_codec *codec = snd_soc_component_to_codec(component);
-
-	codec->driver->remove(codec);
-}
-
 static int snd_soc_codec_drv_write(struct snd_soc_component *component,
 	unsigned int reg, unsigned int val)
 {
@@ -3050,6 +4425,7 @@
 {
 	struct snd_soc_codec *codec;
 	struct snd_soc_dai *dai;
+	struct regmap *regmap;
 	int ret, i;
 
 	dev_dbg(dev, "codec register %s\n", dev_name(dev));
@@ -3059,35 +4435,18 @@
 		return -ENOMEM;
 
 	codec->component.dapm_ptr = &codec->dapm;
-	codec->component.codec = codec;
 
 	ret = snd_soc_component_initialize(&codec->component,
 			&codec_drv->component_driver, dev);
 	if (ret)
 		goto err_free;
 
-	if (codec_drv->controls) {
-		codec->component.controls = codec_drv->controls;
-		codec->component.num_controls = codec_drv->num_controls;
-	}
-	if (codec_drv->dapm_widgets) {
-		codec->component.dapm_widgets = codec_drv->dapm_widgets;
-		codec->component.num_dapm_widgets = codec_drv->num_dapm_widgets;
-	}
-	if (codec_drv->dapm_routes) {
-		codec->component.dapm_routes = codec_drv->dapm_routes;
-		codec->component.num_dapm_routes = codec_drv->num_dapm_routes;
-	}
-
-	if (codec_drv->probe)
-		codec->component.probe = snd_soc_codec_drv_probe;
-	if (codec_drv->remove)
-		codec->component.remove = snd_soc_codec_drv_remove;
 	if (codec_drv->write)
 		codec->component.write = snd_soc_codec_drv_write;
 	if (codec_drv->read)
 		codec->component.read = snd_soc_codec_drv_read;
 	codec->component.ignore_pmdown_time = codec_drv->ignore_pmdown_time;
+	codec->dapm.codec = codec;
 	codec->dapm.idle_bias_off = codec_drv->idle_bias_off;
 	codec->dapm.suspend_bias_off = codec_drv->suspend_bias_off;
 	if (codec_drv->seq_notifier)
@@ -3097,14 +4456,25 @@
 	codec->dev = dev;
 	codec->driver = codec_drv;
 	codec->component.val_bytes = codec_drv->reg_word_size;
+	mutex_init(&codec->mutex);
 
-#ifdef CONFIG_DEBUG_FS
-	codec->component.init_debugfs = soc_init_codec_debugfs;
-	codec->component.debugfs_prefix = "codec";
-#endif
+	if (!codec->component.write) {
+		if (codec_drv->get_regmap)
+			regmap = codec_drv->get_regmap(dev);
+		else
+			regmap = dev_get_regmap(dev, NULL);
 
-	if (codec_drv->get_regmap)
-		codec->component.regmap = codec_drv->get_regmap(dev);
+		if (regmap) {
+			ret = snd_soc_component_init_io(&codec->component,
+				regmap);
+			if (ret) {
+				dev_err(codec->dev,
+						"Failed to set cache I/O:%d\n",
+						ret);
+				goto err_cleanup;
+			}
+		}
+	}
 
 	for (i = 0; i < num_dai; i++) {
 		fixup_codec_formats(&dai_drv[i].playback);
@@ -3113,7 +4483,7 @@
 
 	ret = snd_soc_register_dais(&codec->component, dai_drv, num_dai, false);
 	if (ret < 0) {
-		dev_err(dev, "ASoC: Failed to register DAIs: %d\n", ret);
+		dev_err(dev, "ASoC: Failed to regster DAIs: %d\n", ret);
 		goto err_cleanup;
 	}
 
@@ -3146,15 +4516,15 @@
 {
 	struct snd_soc_codec *codec;
 
-	mutex_lock(&client_mutex);
 	list_for_each_entry(codec, &codec_list, list) {
 		if (dev == codec->dev)
 			goto found;
 	}
-	mutex_unlock(&client_mutex);
 	return;
 
 found:
+
+	mutex_lock(&client_mutex);
 	list_del(&codec->list);
 	snd_soc_component_del_unlocked(&codec->component);
 	mutex_unlock(&client_mutex);
@@ -3279,8 +4649,8 @@
 		widgets[i].name = wname;
 	}
 
-	card->of_dapm_widgets = widgets;
-	card->num_of_dapm_widgets = num_widgets;
+	card->dapm_widgets = widgets;
+	card->num_dapm_widgets = num_widgets;
 
 	return 0;
 }
@@ -3364,8 +4734,8 @@
 		}
 	}
 
-	card->num_of_dapm_routes = num_routes;
-	card->of_dapm_routes = routes;
+	card->num_dapm_routes = num_routes;
+	card->dapm_routes = routes;
 
 	return 0;
 }
@@ -3484,30 +4854,36 @@
 }
 EXPORT_SYMBOL_GPL(snd_soc_of_parse_daifmt);
 
-static int snd_soc_get_dai_name(struct of_phandle_args *args,
-				const char **dai_name)
+int snd_soc_of_get_dai_name(struct device_node *of_node,
+			    const char **dai_name)
 {
 	struct snd_soc_component *pos;
-	int ret = -EPROBE_DEFER;
+	struct of_phandle_args args;
+	int ret;
+
+	ret = of_parse_phandle_with_args(of_node, "sound-dai",
+					 "#sound-dai-cells", 0, &args);
+	if (ret)
+		return ret;
+
+	ret = -EPROBE_DEFER;
 
 	mutex_lock(&client_mutex);
 	list_for_each_entry(pos, &component_list, list) {
-		if (pos->dev->of_node != args->np)
+		if (pos->dev->of_node != args.np)
 			continue;
 
 		if (pos->driver->of_xlate_dai_name) {
-			ret = pos->driver->of_xlate_dai_name(pos,
-							     args,
-							     dai_name);
+			ret = pos->driver->of_xlate_dai_name(pos, &args, dai_name);
 		} else {
 			int id = -1;
 
-			switch (args->args_count) {
+			switch (args.args_count) {
 			case 0:
 				id = 0; /* same as dai_drv[0] */
 				break;
 			case 1:
-				id = args->args[0];
+				id = args.args[0];
 				break;
 			default:
 				/* not supported */
@@ -3529,21 +4905,6 @@
 		break;
 	}
 	mutex_unlock(&client_mutex);
-	return ret;
-}
-
-int snd_soc_of_get_dai_name(struct device_node *of_node,
-			    const char **dai_name)
-{
-	struct of_phandle_args args;
-	int ret;
-
-	ret = of_parse_phandle_with_args(of_node, "sound-dai",
-					 "#sound-dai-cells", 0, &args);
-	if (ret)
-		return ret;
-
-	ret = snd_soc_get_dai_name(&args, dai_name);
 
 	of_node_put(args.np);
 
@@ -3551,80 +4912,28 @@
 }
 EXPORT_SYMBOL_GPL(snd_soc_of_get_dai_name);
 
-/*
- * snd_soc_of_get_dai_link_codecs - Parse a list of CODECs in the devicetree
- * @dev: Card device
- * @of_node: Device node
- * @dai_link: DAI link
- *
- * Builds an array of CODEC DAI components from the DAI link property
- * 'sound-dai'.
- * The array is set in the DAI link and the number of DAIs is set accordingly.
- * The device nodes in the array (of_node) must be dereferenced by the caller.
- *
- * Returns 0 for success
- */
-int snd_soc_of_get_dai_link_codecs(struct device *dev,
-				   struct device_node *of_node,
-				   struct snd_soc_dai_link *dai_link)
+static int __init snd_soc_init(void)
 {
-	struct of_phandle_args args;
-	struct snd_soc_dai_link_component *component;
-	char *name;
-	int index, num_codecs, ret;
-
-	/* Count the number of CODECs */
-	name = "sound-dai";
-	num_codecs = of_count_phandle_with_args(of_node, name,
-						"#sound-dai-cells");
-	if (num_codecs <= 0) {
-		if (num_codecs == -ENOENT)
-			dev_err(dev, "No 'sound-dai' property\n");
-		else
-			dev_err(dev, "Bad phandle in 'sound-dai'\n");
-		return num_codecs;
+#ifdef CONFIG_DEBUG_FS
+	snd_soc_debugfs_root = debugfs_create_dir("asoc", NULL);
+	if (IS_ERR(snd_soc_debugfs_root) || !snd_soc_debugfs_root) {
+		pr_warn("ASoC: Failed to create debugfs directory\n");
+		snd_soc_debugfs_root = NULL;
 	}
-	component = devm_kzalloc(dev,
-				 sizeof *component * num_codecs,
-				 GFP_KERNEL);
-	if (!component)
-		return -ENOMEM;
-	dai_link->codecs = component;
-	dai_link->num_codecs = num_codecs;
 
-	/* Parse the list */
-	for (index = 0, component = dai_link->codecs;
-	     index < dai_link->num_codecs;
-	     index++, component++) {
-		ret = of_parse_phandle_with_args(of_node, name,
-						 "#sound-dai-cells",
-						  index, &args);
-		if (ret)
-			goto err;
-		component->of_node = args.np;
-		ret = snd_soc_get_dai_name(&args, &component->dai_name);
-		if (ret < 0)
-			goto err;
-	}
-	return 0;
-err:
-	for (index = 0, component = dai_link->codecs;
-	     index < dai_link->num_codecs;
-	     index++, component++) {
-		if (!component->of_node)
-			break;
-		of_node_put(component->of_node);
-		component->of_node = NULL;
-	}
-	dai_link->codecs = NULL;
-	dai_link->num_codecs = 0;
-	return ret;
-}
-EXPORT_SYMBOL_GPL(snd_soc_of_get_dai_link_codecs);
+	if (!debugfs_create_file("codecs", 0444, snd_soc_debugfs_root, NULL,
+				 &codec_list_fops))
+		pr_warn("ASoC: Failed to create CODEC list debugfs file\n");
+
+	if (!debugfs_create_file("dais", 0444, snd_soc_debugfs_root, NULL,
+				 &dai_list_fops))
+		pr_warn("ASoC: Failed to create DAI list debugfs file\n");
+
+	if (!debugfs_create_file("platforms", 0444, snd_soc_debugfs_root, NULL,
+				 &platform_list_fops))
+		pr_warn("ASoC: Failed to create platform list debugfs file\n");
+#endif
 
-static int __init snd_soc_init(void)
-{
-	snd_soc_debugfs_init();
 	snd_soc_util_init();
 
 	return platform_driver_register(&soc_driver);
@@ -3634,9 +4943,9 @@
 static void __exit snd_soc_exit(void)
 {
 	snd_soc_util_exit();
-	snd_soc_debugfs_exit();
 
 #ifdef CONFIG_DEBUG_FS
+	debugfs_remove_recursive(snd_soc_debugfs_root);
 #endif
 	platform_driver_unregister(&soc_driver);
 }
diff -Nru a/sound/soc/soc-dapm.c b/sound/soc/soc-dapm.c
--- a/sound/soc/soc-dapm.c	2015-08-16 23:52:51.000000000 -0400
+++ b/sound/soc/soc-dapm.c	2015-08-22 16:54:09.952983000 -0400
@@ -159,135 +159,27 @@
 	}
 }
 
-/*
- * dapm_widget_invalidate_input_paths() - Invalidate the cached number of input
- *  paths
- * @w: The widget for which to invalidate the cached number of input paths
- *
- * The function resets the cached number of inputs for the specified widget and
- * all widgets that can be reached via outgoing paths from the widget.
- *
- * This function must be called if the number of input paths for a widget might
- * have changed. E.g. if the source state of a widget changes or a path is added
- * or activated with the widget as the sink.
- */
-static void dapm_widget_invalidate_input_paths(struct snd_soc_dapm_widget *w)
-{
-	struct snd_soc_dapm_widget *sink;
-	struct snd_soc_dapm_path *p;
-	LIST_HEAD(list);
-
-	dapm_assert_locked(w->dapm);
-
-	if (w->inputs == -1)
-		return;
-
-	w->inputs = -1;
-	list_add_tail(&w->work_list, &list);
-
-	list_for_each_entry(w, &list, work_list) {
-		list_for_each_entry(p, &w->sinks, list_source) {
-			if (p->is_supply || p->weak || !p->connect)
-				continue;
-			sink = p->sink;
-			if (sink->inputs != -1) {
-				sink->inputs = -1;
-				list_add_tail(&sink->work_list, &list);
-			}
-		}
-	}
-}
-
-/*
- * dapm_widget_invalidate_output_paths() - Invalidate the cached number of
- *  output paths
- * @w: The widget for which to invalidate the cached number of output paths
- *
- * Resets the cached number of outputs for the specified widget and all widgets
- * that can be reached via incoming paths from the widget.
- *
- * This function must be called if the number of output paths for a widget might
- * have changed. E.g. if the sink state of a widget changes or a path is added
- * or activated with the widget as the source.
- */
-static void dapm_widget_invalidate_output_paths(struct snd_soc_dapm_widget *w)
-{
-	struct snd_soc_dapm_widget *source;
-	struct snd_soc_dapm_path *p;
-	LIST_HEAD(list);
-
-	dapm_assert_locked(w->dapm);
-
-	if (w->outputs == -1)
-		return;
-
-	w->outputs = -1;
-	list_add_tail(&w->work_list, &list);
-
-	list_for_each_entry(w, &list, work_list) {
-		list_for_each_entry(p, &w->sources, list_sink) {
-			if (p->is_supply || p->weak || !p->connect)
-				continue;
-			source = p->source;
-			if (source->outputs != -1) {
-				source->outputs = -1;
-				list_add_tail(&source->work_list, &list);
-			}
-		}
-	}
-}
-
-/*
- * dapm_path_invalidate() - Invalidates the cached number of inputs and outputs
- *  for the widgets connected to a path
- * @p: The path to invalidate
- *
- * Resets the cached number of inputs for the sink of the path and the cached
- * number of outputs for the source of the path.
- *
- * This function must be called when a path is added, removed or the connected
- * state changes.
- */
-static void dapm_path_invalidate(struct snd_soc_dapm_path *p)
-{
-	/*
-	 * Weak paths or supply paths do not influence the number of input or
-	 * output paths of their neighbors.
-	 */
-	if (p->weak || p->is_supply)
-		return;
-
-	/*
-	 * The number of connected endpoints is the sum of the number of
-	 * connected endpoints of all neighbors. If a node with 0 connected
-	 * endpoints is either connected or disconnected that sum won't change,
-	 * so there is no need to re-check the path.
-	 */
-	if (p->source->inputs != 0)
-		dapm_widget_invalidate_input_paths(p->sink);
-	if (p->sink->outputs != 0)
-		dapm_widget_invalidate_output_paths(p->source);
-}
-
-void dapm_mark_endpoints_dirty(struct snd_soc_card *card)
+void dapm_mark_io_dirty(struct snd_soc_dapm_context *dapm)
 {
+	struct snd_soc_card *card = dapm->card;
 	struct snd_soc_dapm_widget *w;
 
 	mutex_lock(&card->dapm_mutex);
 
 	list_for_each_entry(w, &card->widgets, list) {
-		if (w->is_sink || w->is_source) {
-			dapm_mark_dirty(w, "Rechecking endpoints");
-			if (w->is_sink)
-				dapm_widget_invalidate_output_paths(w);
-			if (w->is_source)
-				dapm_widget_invalidate_input_paths(w);
+		switch (w->id) {
+		case snd_soc_dapm_input:
+		case snd_soc_dapm_output:
+			dapm_mark_dirty(w, "Rechecking inputs and outputs");
+			break;
+		default:
+			break;
 		}
 	}
 
 	mutex_unlock(&card->dapm_mutex);
 }
-EXPORT_SYMBOL_GPL(dapm_mark_endpoints_dirty);
+EXPORT_SYMBOL_GPL(dapm_mark_io_dirty);
 
 /* create a new dapm widget */
 static inline struct snd_soc_dapm_widget *dapm_cnew_widget(
@@ -434,13 +326,12 @@
 	list_for_each_entry(path, dapm_kcontrol_get_path_list(kcontrol), \
 		list_kcontrol)
 
-unsigned int dapm_kcontrol_get_value(const struct snd_kcontrol *kcontrol)
+static unsigned int dapm_kcontrol_get_value(const struct snd_kcontrol *kcontrol)
 {
 	struct dapm_kcontrol_data *data = snd_kcontrol_chip(kcontrol);
 
 	return data->value;
 }
-EXPORT_SYMBOL_GPL(dapm_kcontrol_get_value);
 
 static bool dapm_kcontrol_set_value(const struct snd_kcontrol *kcontrol,
 	unsigned int value)
@@ -473,6 +364,16 @@
 }
 EXPORT_SYMBOL_GPL(snd_soc_dapm_kcontrol_dapm);
 
+/**
+ * snd_soc_dapm_kcontrol_codec() - Returns the codec associated to a kcontrol
+ * @kcontrol: The kcontrol
+ */
+struct snd_soc_codec *snd_soc_dapm_kcontrol_codec(struct snd_kcontrol *kcontrol)
+{
+	return snd_soc_dapm_to_codec(snd_soc_dapm_kcontrol_dapm(kcontrol));
+}
+EXPORT_SYMBOL_GPL(snd_soc_dapm_kcontrol_codec);
+
 static void dapm_reset(struct snd_soc_card *card)
 {
 	struct snd_soc_dapm_widget *w;
@@ -484,6 +385,8 @@
 	list_for_each_entry(w, &card->widgets, list) {
 		w->new_power = w->power;
 		w->power_checked = false;
+		w->inputs = -1;
+		w->outputs = -1;
 	}
 }
 
@@ -507,8 +410,8 @@
 {
 	if (!dapm->component)
 		return -EIO;
-	return snd_soc_component_update_bits(dapm->component, reg,
-					     mask, value);
+	return snd_soc_component_update_bits_async(dapm->component, reg,
+		mask, value);
 }
 
 static int soc_dapm_test_bits(struct snd_soc_dapm_context *dapm,
@@ -565,9 +468,10 @@
 
 /* connect mux widget to its interconnecting audio paths */
 static int dapm_connect_mux(struct snd_soc_dapm_context *dapm,
-	struct snd_soc_dapm_path *path, const char *control_name)
+	struct snd_soc_dapm_widget *src, struct snd_soc_dapm_widget *dest,
+	struct snd_soc_dapm_path *path, const char *control_name,
+	const struct snd_kcontrol_new *kcontrol)
 {
-	const struct snd_kcontrol_new *kcontrol = &path->sink->kcontrol_news[0];
 	struct soc_enum *e = (struct soc_enum *)kcontrol->private_value;
 	unsigned int val, item;
 	int i;
@@ -588,7 +492,10 @@
 
 	for (i = 0; i < e->items; i++) {
 		if (!(strcmp(control_name, e->texts[i]))) {
-			path->name = e->texts[i];
+			list_add(&path->list, &dapm->card->paths);
+			list_add(&path->list_sink, &dest->sources);
+			list_add(&path->list_source, &src->sinks);
+			path->name = (char*)e->texts[i];
 			if (i == item)
 				path->connect = 1;
 			else
@@ -601,10 +508,11 @@
 }
 
 /* set up initial codec paths */
-static void dapm_set_mixer_path_status(struct snd_soc_dapm_path *p, int i)
+static void dapm_set_mixer_path_status(struct snd_soc_dapm_widget *w,
+	struct snd_soc_dapm_path *p, int i)
 {
 	struct soc_mixer_control *mc = (struct soc_mixer_control *)
-		p->sink->kcontrol_news[i].private_value;
+		w->kcontrol_news[i].private_value;
 	unsigned int reg = mc->reg;
 	unsigned int shift = mc->shift;
 	unsigned int max = mc->max;
@@ -613,7 +521,7 @@
 	unsigned int val;
 
 	if (reg != SND_SOC_NOPM) {
-		soc_dapm_read(p->sink->dapm, reg, &val);
+		soc_dapm_read(w->dapm, reg, &val);
 		val = (val >> shift) & mask;
 		if (invert)
 			val = max - val;
@@ -625,15 +533,19 @@
 
 /* connect mixer widget to its interconnecting audio paths */
 static int dapm_connect_mixer(struct snd_soc_dapm_context *dapm,
+	struct snd_soc_dapm_widget *src, struct snd_soc_dapm_widget *dest,
 	struct snd_soc_dapm_path *path, const char *control_name)
 {
 	int i;
 
 	/* search for mixer kcontrol */
-	for (i = 0; i < path->sink->num_kcontrols; i++) {
-		if (!strcmp(control_name, path->sink->kcontrol_news[i].name)) {
-			path->name = path->sink->kcontrol_news[i].name;
-			dapm_set_mixer_path_status(path, i);
+	for (i = 0; i < dest->num_kcontrols; i++) {
+		if (!strcmp(control_name, dest->kcontrol_news[i].name)) {
+			list_add(&path->list, &dapm->card->paths);
+			list_add(&path->list_sink, &dest->sources);
+			list_add(&path->list_source, &src->sinks);
+			path->name = dest->kcontrol_news[i].name;
+			dapm_set_mixer_path_status(dest, path, i);
 			return 0;
 		}
 	}
@@ -679,9 +591,9 @@
 	int shared;
 	struct snd_kcontrol *kcontrol;
 	bool wname_in_long_name, kcname_in_long_name;
-	char *long_name = NULL;
+	char *long_name;
 	const char *name;
-	int ret = 0;
+	int ret;
 
 	prefix = soc_dapm_prefix(dapm);
 	if (prefix)
@@ -740,17 +652,15 @@
 
 		kcontrol = snd_soc_cnew(&w->kcontrol_news[kci], NULL, name,
 					prefix);
-		if (!kcontrol) {
-			ret = -ENOMEM;
-			goto exit_free;
-		}
-
+		kfree(long_name);
+		if (!kcontrol)
+			return -ENOMEM;
 		kcontrol->private_free = dapm_kcontrol_free;
 
 		ret = dapm_kcontrol_data_alloc(w, kcontrol);
 		if (ret) {
 			snd_ctl_free_one(kcontrol);
-			goto exit_free;
+			return ret;
 		}
 
 		ret = snd_ctl_add(card, kcontrol);
@@ -758,18 +668,17 @@
 			dev_err(dapm->dev,
 				"ASoC: failed to add widget %s dapm kcontrol %s: %d\n",
 				w->name, name, ret);
-			goto exit_free;
+			return ret;
 		}
 	}
 
 	ret = dapm_kcontrol_add_widget(kcontrol, w);
-	if (ret == 0)
-		w->kcontrols[kci] = kcontrol;
+	if (ret)
+		return ret;
 
-exit_free:
-	kfree(long_name);
+	w->kcontrols[kci] = kcontrol;
 
-	return ret;
+	return 0;
 }
 
 /* create new dapm mixer control */
@@ -825,10 +734,8 @@
 	if (ret < 0)
 		return ret;
 
-	list_for_each_entry(path, &w->sources, list_sink) {
-		if (path->name)
-			dapm_kcontrol_add_path(w->kcontrols[0], path);
-	}
+	list_for_each_entry(path, &w->sources, list_sink)
+		dapm_kcontrol_add_path(w->kcontrols[0], path);
 
 	return 0;
 }
@@ -843,36 +750,34 @@
 	return 0;
 }
 
-/* create new dapm dai link control */
-static int dapm_new_dai_link(struct snd_soc_dapm_widget *w)
+/* reset 'walked' bit for each dapm path */
+static void dapm_clear_walk_output(struct snd_soc_dapm_context *dapm,
+				   struct list_head *sink)
 {
-	int i, ret;
-	struct snd_kcontrol *kcontrol;
-	struct snd_soc_dapm_context *dapm = w->dapm;
-	struct snd_card *card = dapm->card->snd_card;
-
-	/* create control for links with > 1 config */
-	if (w->num_params <= 1)
-		return 0;
+	struct snd_soc_dapm_path *p;
 
-	/* add kcontrol */
-	for (i = 0; i < w->num_kcontrols; i++) {
-		kcontrol = snd_soc_cnew(&w->kcontrol_news[i], w,
-					w->name, NULL);
-		ret = snd_ctl_add(card, kcontrol);
-		if (ret < 0) {
-			dev_err(dapm->dev,
-				"ASoC: failed to add widget %s dapm kcontrol %s: %d\n",
-				w->name, w->kcontrol_news[i].name, ret);
-			return ret;
+	list_for_each_entry(p, sink, list_source) {
+		if (p->walked) {
+			p->walked = 0;
+			dapm_clear_walk_output(dapm, &p->sink->sinks);
 		}
-		kcontrol->private_data = w;
-		w->kcontrols[i] = kcontrol;
 	}
+}
 
-	return 0;
+static void dapm_clear_walk_input(struct snd_soc_dapm_context *dapm,
+				  struct list_head *source)
+{
+	struct snd_soc_dapm_path *p;
+
+	list_for_each_entry(p, source, list_sink) {
+		if (p->walked) {
+			p->walked = 0;
+			dapm_clear_walk_input(dapm, &p->source->sources);
+		}
+	}
 }
 
+
 /* We implement power down on suspend by checking the power state of
  * the ALSA card - when we are suspending the ALSA state for the card
  * is set to D3.
@@ -947,23 +852,61 @@
 
 	DAPM_UPDATE_STAT(widget, path_checks);
 
-	if (widget->is_sink && widget->connected) {
-		widget->outputs = snd_soc_dapm_suspend_check(widget);
-		return widget->outputs;
+	switch (widget->id) {
+	case snd_soc_dapm_supply:
+	case snd_soc_dapm_regulator_supply:
+	case snd_soc_dapm_clock_supply:
+	case snd_soc_dapm_kcontrol:
+		return 0;
+	default:
+		break;
+	}
+
+	switch (widget->id) {
+	case snd_soc_dapm_adc:
+	case snd_soc_dapm_aif_out:
+	case snd_soc_dapm_dai_out:
+		if (widget->active) {
+			widget->outputs = snd_soc_dapm_suspend_check(widget);
+			return widget->outputs;
+		}
+	default:
+		break;
+	}
+
+	if (widget->connected) {
+		/* connected pin ? */
+		if (widget->id == snd_soc_dapm_output && !widget->ext) {
+			widget->outputs = snd_soc_dapm_suspend_check(widget);
+			return widget->outputs;
+		}
+
+		/* connected jack or spk ? */
+		if (widget->id == snd_soc_dapm_hp ||
+		    widget->id == snd_soc_dapm_spk ||
+		    (widget->id == snd_soc_dapm_line &&
+		     !list_empty(&widget->sources))) {
+			widget->outputs = snd_soc_dapm_suspend_check(widget);
+			return widget->outputs;
+		}
 	}
 
 	list_for_each_entry(path, &widget->sinks, list_source) {
 		DAPM_UPDATE_STAT(widget, neighbour_checks);
 
-		if (path->weak || path->is_supply)
+		if (path->weak)
 			continue;
 
 		if (path->walking)
 			return 1;
 
+		if (path->walked)
+			continue;
+
 		trace_snd_soc_dapm_output_path(widget, path);
 
-		if (path->connect) {
+		if (path->sink && path->connect) {
+			path->walked = 1;
 			path->walking = 1;
 
 			/* do we need to add this widget to the list ? */
@@ -1005,23 +948,73 @@
 
 	DAPM_UPDATE_STAT(widget, path_checks);
 
-	if (widget->is_source && widget->connected) {
-		widget->inputs = snd_soc_dapm_suspend_check(widget);
-		return widget->inputs;
+	switch (widget->id) {
+	case snd_soc_dapm_supply:
+	case snd_soc_dapm_regulator_supply:
+	case snd_soc_dapm_clock_supply:
+	case snd_soc_dapm_kcontrol:
+		return 0;
+	default:
+		break;
+	}
+
+	/* active stream ? */
+	switch (widget->id) {
+	case snd_soc_dapm_dac:
+	case snd_soc_dapm_aif_in:
+	case snd_soc_dapm_dai_in:
+		if (widget->active) {
+			widget->inputs = snd_soc_dapm_suspend_check(widget);
+			return widget->inputs;
+		}
+	default:
+		break;
+	}
+
+	if (widget->connected) {
+		/* connected pin ? */
+		if (widget->id == snd_soc_dapm_input && !widget->ext) {
+			widget->inputs = snd_soc_dapm_suspend_check(widget);
+			return widget->inputs;
+		}
+
+		/* connected VMID/Bias for lower pops */
+		if (widget->id == snd_soc_dapm_vmid) {
+			widget->inputs = snd_soc_dapm_suspend_check(widget);
+			return widget->inputs;
+		}
+
+		/* connected jack ? */
+		if (widget->id == snd_soc_dapm_mic ||
+		    (widget->id == snd_soc_dapm_line &&
+		     !list_empty(&widget->sinks))) {
+			widget->inputs = snd_soc_dapm_suspend_check(widget);
+			return widget->inputs;
+		}
+
+		/* signal generator */
+		if (widget->id == snd_soc_dapm_siggen) {
+			widget->inputs = snd_soc_dapm_suspend_check(widget);
+			return widget->inputs;
+		}
 	}
 
 	list_for_each_entry(path, &widget->sources, list_sink) {
 		DAPM_UPDATE_STAT(widget, neighbour_checks);
 
-		if (path->weak || path->is_supply)
+		if (path->weak)
 			continue;
 
 		if (path->walking)
 			return 1;
 
+		if (path->walked)
+			continue;
+
 		trace_snd_soc_dapm_input_path(widget, path);
 
-		if (path->connect) {
+		if (path->source && path->connect) {
+			path->walked = 1;
 			path->walking = 1;
 
 			/* do we need to add this widget to the list ? */
@@ -1063,25 +1056,21 @@
 int snd_soc_dapm_dai_get_connected_widgets(struct snd_soc_dai *dai, int stream,
 	struct snd_soc_dapm_widget_list **list)
 {
-	struct snd_soc_card *card = dai->component->card;
-	struct snd_soc_dapm_widget *w;
+	struct snd_soc_card *card = dai->card;
 	int paths;
 
 	mutex_lock_nested(&card->dapm_mutex, SND_SOC_DAPM_CLASS_RUNTIME);
+	dapm_reset(card);
 
-	/*
-	 * For is_connected_{output,input}_ep fully discover the graph we need
-	 * to reset the cached number of inputs and outputs.
-	 */
-	list_for_each_entry(w, &card->widgets, list) {
-		w->inputs = -1;
-		w->outputs = -1;
-	}
-
-	if (stream == SNDRV_PCM_STREAM_PLAYBACK)
+	if (stream == SNDRV_PCM_STREAM_PLAYBACK) {
 		paths = is_connected_output_ep(dai->playback_widget, list);
-	else
+		dapm_clear_walk_output(&card->dapm,
+				       &dai->playback_widget->sinks);
+	} else {
 		paths = is_connected_input_ep(dai->capture_widget, list);
+		dapm_clear_walk_input(&card->dapm,
+				      &dai->capture_widget->sources);
+	}
 
 	trace_snd_soc_dapm_connected(paths, stream);
 	mutex_unlock(&card->dapm_mutex);
@@ -1170,10 +1159,44 @@
 	DAPM_UPDATE_STAT(w, power_checks);
 
 	in = is_connected_input_ep(w, NULL);
+	dapm_clear_walk_input(w->dapm, &w->sources);
 	out = is_connected_output_ep(w, NULL);
+	dapm_clear_walk_output(w->dapm, &w->sinks);
 	return out != 0 && in != 0;
 }
 
+/* Check to see if an ADC has power */
+static int dapm_adc_check_power(struct snd_soc_dapm_widget *w)
+{
+	int in;
+
+	DAPM_UPDATE_STAT(w, power_checks);
+
+	if (w->active) {
+		in = is_connected_input_ep(w, NULL);
+		dapm_clear_walk_input(w->dapm, &w->sources);
+		return in != 0;
+	} else {
+		return dapm_generic_check_power(w);
+	}
+}
+
+/* Check to see if a DAC has power */
+static int dapm_dac_check_power(struct snd_soc_dapm_widget *w)
+{
+	int out;
+
+	DAPM_UPDATE_STAT(w, power_checks);
+
+	if (w->active) {
+		out = is_connected_output_ep(w, NULL);
+		dapm_clear_walk_output(w->dapm, &w->sinks);
+		return out != 0;
+	} else {
+		return dapm_generic_check_power(w);
+	}
+}
+
 /* Check to see if a power supply is needed */
 static int dapm_supply_check_power(struct snd_soc_dapm_widget *w)
 {
@@ -1192,6 +1215,9 @@
 		    !path->connected(path->source, path->sink))
 			continue;
 
+		if (!path->sink)
+			continue;
+
 		if (dapm_widget_power_check(path->sink))
 			return 1;
 	}
@@ -1606,14 +1632,27 @@
 	/* If we changed our power state perhaps our neigbours changed
 	 * also.
 	 */
-	list_for_each_entry(path, &w->sources, list_sink)
-		dapm_widget_set_peer_power(path->source, power, path->connect);
-
-	/* Supplies can't affect their outputs, only their inputs */
-	if (!w->is_supply) {
-		list_for_each_entry(path, &w->sinks, list_source)
-			dapm_widget_set_peer_power(path->sink, power,
+	list_for_each_entry(path, &w->sources, list_sink) {
+		if (path->source) {
+			dapm_widget_set_peer_power(path->source, power,
 						   path->connect);
+		}
+	}
+	switch (w->id) {
+	case snd_soc_dapm_supply:
+	case snd_soc_dapm_regulator_supply:
+	case snd_soc_dapm_clock_supply:
+	case snd_soc_dapm_kcontrol:
+		/* Supplies can't affect their outputs, only their inputs */
+		break;
+	default:
+		list_for_each_entry(path, &w->sinks, list_source) {
+			if (path->sink) {
+				dapm_widget_set_peer_power(path->sink, power,
+							   path->connect);
+			}
+		}
+		break;
 	}
 
 	if (power)
@@ -1823,14 +1862,10 @@
 
 	mutex_lock(&card->dapm_mutex);
 
-	/* Supply widgets are not handled by is_connected_{input,output}_ep() */
-	if (w->is_supply) {
-		in = 0;
-		out = 0;
-	} else {
-		in = is_connected_input_ep(w, NULL);
-		out = is_connected_output_ep(w, NULL);
-	}
+	in = is_connected_input_ep(w, NULL);
+	dapm_clear_walk_input(w->dapm, &w->sources);
+	out = is_connected_output_ep(w, NULL);
+	dapm_clear_walk_output(w->dapm, &w->sinks);
 
 	ret = snprintf(buf, PAGE_SIZE, "%s: %s%s  in %d out %d",
 		       w->name, w->power ? "On" : "Off",
@@ -1923,9 +1958,6 @@
 {
 	struct dentry *d;
 
-	if (!parent)
-		return;
-
 	dapm->debugfs_dapm = debugfs_create_dir("dapm", parent);
 
 	if (!dapm->debugfs_dapm) {
@@ -1980,45 +2012,32 @@
 
 #endif
 
-/*
- * soc_dapm_connect_path() - Connects or disconnects a path
- * @path: The path to update
- * @connect: The new connect state of the path. True if the path is connected,
- *  false if it is disconneted.
- * @reason: The reason why the path changed (for debugging only)
- */
-static void soc_dapm_connect_path(struct snd_soc_dapm_path *path,
-	bool connect, const char *reason)
-{
-	if (path->connect == connect)
-		return;
-
-	path->connect = connect;
-	dapm_mark_dirty(path->source, reason);
-	dapm_mark_dirty(path->sink, reason);
-	dapm_path_invalidate(path);
-}
-
 /* test and update the power status of a mux widget */
 static int soc_dapm_mux_update_power(struct snd_soc_card *card,
 				 struct snd_kcontrol *kcontrol, int mux, struct soc_enum *e)
 {
 	struct snd_soc_dapm_path *path;
 	int found = 0;
-	bool connect;
 
 	lockdep_assert_held(&card->dapm_mutex);
 
 	/* find dapm widget path assoc with kcontrol */
 	dapm_kcontrol_for_each_path(path, kcontrol) {
+		if (!path->name || !e->texts[mux])
+			continue;
+
 		found = 1;
 		/* we now need to match the string in the enum to the path */
-		if (!(strcmp(path->name, e->texts[mux])))
-			connect = true;
-		else
-			connect = false;
-
-		soc_dapm_connect_path(path, connect, "mux update");
+		if (!(strcmp(path->name, e->texts[mux]))) {
+			path->connect = 1; /* new connection */
+			dapm_mark_dirty(path->source, "mux connection");
+		} else {
+			if (path->connect)
+				dapm_mark_dirty(path->source,
+						"mux disconnection");
+			path->connect = 0; /* old connection must be powered down */
+		}
+		dapm_mark_dirty(path->sink, "mux change");
 	}
 
 	if (found)
@@ -2057,7 +2076,9 @@
 	/* find dapm widget path assoc with kcontrol */
 	dapm_kcontrol_for_each_path(path, kcontrol) {
 		found = 1;
-		soc_dapm_connect_path(path, connect, "mixer update");
+		path->connect = connect;
+		dapm_mark_dirty(path->source, "mixer connection");
+		dapm_mark_dirty(path->sink, "mixer update");
 	}
 
 	if (found)
@@ -2159,10 +2180,15 @@
 
 static DEVICE_ATTR(dapm_widget, 0444, dapm_widget_show, NULL);
 
-struct attribute *soc_dapm_dev_attrs[] = {
-	&dev_attr_dapm_widget.attr,
-	NULL
-};
+int snd_soc_dapm_sys_add(struct device *dev)
+{
+	return device_create_file(dev, &dev_attr_dapm_widget);
+}
+
+static void snd_soc_dapm_sys_remove(struct device *dev)
+{
+	device_remove_file(dev, &dev_attr_dapm_widget);
+}
 
 static void dapm_free_path(struct snd_soc_dapm_path *path)
 {
@@ -2234,11 +2260,8 @@
 		return -EINVAL;
 	}
 
-	if (w->connected != status) {
+	if (w->connected != status)
 		dapm_mark_dirty(w, "pin configuration");
-		dapm_widget_invalidate_input_paths(w);
-		dapm_widget_invalidate_output_paths(w);
-	}
 
 	w->connected = status;
 	if (status == 0)
@@ -2291,59 +2314,6 @@
 }
 EXPORT_SYMBOL_GPL(snd_soc_dapm_sync);
 
-/*
- * dapm_update_widget_flags() - Re-compute widget sink and source flags
- * @w: The widget for which to update the flags
- *
- * Some widgets have a dynamic category which depends on which neighbors they
- * are connected to. This function update the category for these widgets.
- *
- * This function must be called whenever a path is added or removed to a widget.
- */
-static void dapm_update_widget_flags(struct snd_soc_dapm_widget *w)
-{
-	struct snd_soc_dapm_path *p;
-
-	switch (w->id) {
-	case snd_soc_dapm_input:
-		/* On a fully routed card a input is never a source */
-		if (w->dapm->card->fully_routed)
-			break;
-		w->is_source = 1;
-		list_for_each_entry(p, &w->sources, list_sink) {
-			if (p->source->id == snd_soc_dapm_micbias ||
-				p->source->id == snd_soc_dapm_mic ||
-				p->source->id == snd_soc_dapm_line ||
-				p->source->id == snd_soc_dapm_output) {
-					w->is_source = 0;
-					break;
-			}
-		}
-		break;
-	case snd_soc_dapm_output:
-		/* On a fully routed card a output is never a sink */
-		if (w->dapm->card->fully_routed)
-			break;
-		w->is_sink = 1;
-		list_for_each_entry(p, &w->sinks, list_source) {
-			if (p->sink->id == snd_soc_dapm_spk ||
-				p->sink->id == snd_soc_dapm_hp ||
-				p->sink->id == snd_soc_dapm_line ||
-				p->sink->id == snd_soc_dapm_input) {
-					w->is_sink = 0;
-					break;
-			}
-		}
-		break;
-	case snd_soc_dapm_line:
-		w->is_sink = !list_empty(&w->sources);
-		w->is_source = !list_empty(&w->sinks);
-		break;
-	default:
-		break;
-	}
-}
-
 static int snd_soc_dapm_add_path(struct snd_soc_dapm_context *dapm,
 	struct snd_soc_dapm_widget *wsource, struct snd_soc_dapm_widget *wsink,
 	const char *control,
@@ -2353,27 +2323,6 @@
 	struct snd_soc_dapm_path *path;
 	int ret;
 
-	if (wsink->is_supply && !wsource->is_supply) {
-		dev_err(dapm->dev,
-			"Connecting non-supply widget to supply widget is not supported (%s -> %s)\n",
-			wsource->name, wsink->name);
-		return -EINVAL;
-	}
-
-	if (connected && !wsource->is_supply) {
-		dev_err(dapm->dev,
-			"connected() callback only supported for supply widgets (%s -> %s)\n",
-			wsource->name, wsink->name);
-		return -EINVAL;
-	}
-
-	if (wsource->is_supply && control) {
-		dev_err(dapm->dev,
-			"Conditional paths are not supported for supply widgets (%s -> [%s] -> %s)\n",
-			wsource->name, control, wsink->name);
-		return -EINVAL;
-	}
-
 	path = kzalloc(sizeof(struct snd_soc_dapm_path), GFP_KERNEL);
 	if (!path)
 		return -ENOMEM;
@@ -2386,48 +2335,84 @@
 	INIT_LIST_HEAD(&path->list_source);
 	INIT_LIST_HEAD(&path->list_sink);
 
-	if (wsource->is_supply || wsink->is_supply)
-		path->is_supply = 1;
+	/* check for external widgets */
+	if (wsink->id == snd_soc_dapm_input) {
+		if (wsource->id == snd_soc_dapm_micbias ||
+			wsource->id == snd_soc_dapm_mic ||
+			wsource->id == snd_soc_dapm_line ||
+			wsource->id == snd_soc_dapm_output)
+			wsink->ext = 1;
+	}
+	if (wsource->id == snd_soc_dapm_output) {
+		if (wsink->id == snd_soc_dapm_spk ||
+			wsink->id == snd_soc_dapm_hp ||
+			wsink->id == snd_soc_dapm_line ||
+			wsink->id == snd_soc_dapm_input)
+			wsource->ext = 1;
+	}
+
+	dapm_mark_dirty(wsource, "Route added");
+	dapm_mark_dirty(wsink, "Route added");
 
 	/* connect static paths */
 	if (control == NULL) {
+		list_add(&path->list, &dapm->card->paths);
+		list_add(&path->list_sink, &wsink->sources);
+		list_add(&path->list_source, &wsource->sinks);
 		path->connect = 1;
-	} else {
-		/* connect dynamic paths */
-		switch (wsink->id) {
-		case snd_soc_dapm_mux:
-			ret = dapm_connect_mux(dapm, path, control);
-			if (ret != 0)
-				goto err;
-			break;
-		case snd_soc_dapm_switch:
-		case snd_soc_dapm_mixer:
-		case snd_soc_dapm_mixer_named_ctl:
-			ret = dapm_connect_mixer(dapm, path, control);
-			if (ret != 0)
-				goto err;
-			break;
-		default:
-			dev_err(dapm->dev,
-				"Control not supported for path %s -> [%s] -> %s\n",
-				wsource->name, control, wsink->name);
-			ret = -EINVAL;
-			goto err;
-		}
+		return 0;
 	}
 
-	list_add(&path->list, &dapm->card->paths);
-	list_add(&path->list_sink, &wsink->sources);
-	list_add(&path->list_source, &wsource->sinks);
-
-	dapm_update_widget_flags(wsource);
-	dapm_update_widget_flags(wsink);
-
-	dapm_mark_dirty(wsource, "Route added");
-	dapm_mark_dirty(wsink, "Route added");
-
-	if (dapm->card->instantiated && path->connect)
-		dapm_path_invalidate(path);
+	/* connect dynamic paths */
+	switch (wsink->id) {
+	case snd_soc_dapm_adc:
+	case snd_soc_dapm_dac:
+	case snd_soc_dapm_pga:
+	case snd_soc_dapm_out_drv:
+	case snd_soc_dapm_input:
+	case snd_soc_dapm_output:
+	case snd_soc_dapm_siggen:
+	case snd_soc_dapm_micbias:
+	case snd_soc_dapm_vmid:
+	case snd_soc_dapm_pre:
+	case snd_soc_dapm_post:
+	case snd_soc_dapm_supply:
+	case snd_soc_dapm_regulator_supply:
+	case snd_soc_dapm_clock_supply:
+	case snd_soc_dapm_aif_in:
+	case snd_soc_dapm_aif_out:
+	case snd_soc_dapm_dai_in:
+	case snd_soc_dapm_dai_out:
+	case snd_soc_dapm_dai_link:
+	case snd_soc_dapm_kcontrol:
+		list_add(&path->list, &dapm->card->paths);
+		list_add(&path->list_sink, &wsink->sources);
+		list_add(&path->list_source, &wsource->sinks);
+		path->connect = 1;
+		return 0;
+	case snd_soc_dapm_mux:
+		ret = dapm_connect_mux(dapm, wsource, wsink, path, control,
+			&wsink->kcontrol_news[0]);
+		if (ret != 0)
+			goto err;
+		break;
+	case snd_soc_dapm_switch:
+	case snd_soc_dapm_mixer:
+	case snd_soc_dapm_mixer_named_ctl:
+		ret = dapm_connect_mixer(dapm, wsource, wsink, path, control);
+		if (ret != 0)
+			goto err;
+		break;
+	case snd_soc_dapm_hp:
+	case snd_soc_dapm_mic:
+	case snd_soc_dapm_line:
+	case snd_soc_dapm_spk:
+		list_add(&path->list, &dapm->card->paths);
+		list_add(&path->list_sink, &wsink->sources);
+		list_add(&path->list_source, &wsource->sinks);
+		path->connect = 0;
+		return 0;
+	}
 
 	return 0;
 err:
@@ -2509,7 +2494,6 @@
 static int snd_soc_dapm_del_route(struct snd_soc_dapm_context *dapm,
 				  const struct snd_soc_dapm_route *route)
 {
-	struct snd_soc_dapm_widget *wsource, *wsink;
 	struct snd_soc_dapm_path *path, *p;
 	const char *sink;
 	const char *source;
@@ -2547,19 +2531,10 @@
 	}
 
 	if (path) {
-		wsource = path->source;
-		wsink = path->sink;
-
-		dapm_mark_dirty(wsource, "Route removed");
-		dapm_mark_dirty(wsink, "Route removed");
-		if (path->connect)
-			dapm_path_invalidate(path);
+		dapm_mark_dirty(path->source, "Route removed");
+		dapm_mark_dirty(path->sink, "Route removed");
 
 		dapm_free_path(path);
-
-		/* Update any path related flags */
-		dapm_update_widget_flags(wsource);
-		dapm_update_widget_flags(wsink);
 	} else {
 		dev_warn(dapm->dev, "ASoC: Route %s->%s does not exist\n",
 			 source, sink);
@@ -2751,9 +2726,6 @@
 		case snd_soc_dapm_out_drv:
 			dapm_new_pga(w);
 			break;
-		case snd_soc_dapm_dai_link:
-			dapm_new_dai_link(w);
-			break;
 		default:
 			break;
 		}
@@ -2913,14 +2885,12 @@
 	struct snd_soc_dapm_context *dapm = snd_soc_dapm_kcontrol_dapm(kcontrol);
 	struct soc_enum *e = (struct soc_enum *)kcontrol->private_value;
 	unsigned int reg_val, val;
+	int ret = 0;
 
-	if (e->reg != SND_SOC_NOPM) {
-		int ret = soc_dapm_read(dapm, e->reg, &reg_val);
-		if (ret)
-			return ret;
-	} else {
+	if (e->reg != SND_SOC_NOPM)
+		ret = soc_dapm_read(dapm, e->reg, &reg_val);
+	else
 		reg_val = dapm_kcontrol_get_value(kcontrol);
-	}
 
 	val = (reg_val >> e->shift_l) & e->mask;
 	ucontrol->value.enumerated.item[0] = snd_soc_enum_val_to_item(e, val);
@@ -2930,7 +2900,7 @@
 		ucontrol->value.enumerated.item[1] = val;
 	}
 
-	return 0;
+	return ret;
 }
 EXPORT_SYMBOL_GPL(snd_soc_dapm_get_enum_double);
 
@@ -3113,58 +3083,47 @@
 		w->name = kasprintf(GFP_KERNEL, "%s %s", prefix, widget->name);
 	else
 		w->name = kasprintf(GFP_KERNEL, "%s", widget->name);
+
 	if (w->name == NULL) {
 		kfree(w);
 		return NULL;
 	}
 
 	switch (w->id) {
-	case snd_soc_dapm_mic:
-		w->is_source = 1;
-		w->power_check = dapm_generic_check_power;
-		break;
-	case snd_soc_dapm_input:
-		if (!dapm->card->fully_routed)
-			w->is_source = 1;
+	case snd_soc_dapm_switch:
+	case snd_soc_dapm_mixer:
+	case snd_soc_dapm_mixer_named_ctl:
 		w->power_check = dapm_generic_check_power;
 		break;
-	case snd_soc_dapm_spk:
-	case snd_soc_dapm_hp:
-		w->is_sink = 1;
+	case snd_soc_dapm_mux:
 		w->power_check = dapm_generic_check_power;
 		break;
-	case snd_soc_dapm_output:
-		if (!dapm->card->fully_routed)
-			w->is_sink = 1;
-		w->power_check = dapm_generic_check_power;
+	case snd_soc_dapm_dai_out:
+		w->power_check = dapm_adc_check_power;
 		break;
-	case snd_soc_dapm_vmid:
-	case snd_soc_dapm_siggen:
-		w->is_source = 1;
-		w->power_check = dapm_always_on_check_power;
+	case snd_soc_dapm_dai_in:
+		w->power_check = dapm_dac_check_power;
 		break;
-	case snd_soc_dapm_mux:
-	case snd_soc_dapm_switch:
-	case snd_soc_dapm_mixer:
-	case snd_soc_dapm_mixer_named_ctl:
 	case snd_soc_dapm_adc:
 	case snd_soc_dapm_aif_out:
 	case snd_soc_dapm_dac:
 	case snd_soc_dapm_aif_in:
 	case snd_soc_dapm_pga:
 	case snd_soc_dapm_out_drv:
+	case snd_soc_dapm_input:
+	case snd_soc_dapm_output:
 	case snd_soc_dapm_micbias:
+	case snd_soc_dapm_spk:
+	case snd_soc_dapm_hp:
+	case snd_soc_dapm_mic:
 	case snd_soc_dapm_line:
 	case snd_soc_dapm_dai_link:
-	case snd_soc_dapm_dai_out:
-	case snd_soc_dapm_dai_in:
 		w->power_check = dapm_generic_check_power;
 		break;
 	case snd_soc_dapm_supply:
 	case snd_soc_dapm_regulator_supply:
 	case snd_soc_dapm_clock_supply:
 	case snd_soc_dapm_kcontrol:
-		w->is_supply = 1;
 		w->power_check = dapm_supply_check_power;
 		break;
 	default:
@@ -3173,15 +3132,13 @@
 	}
 
 	w->dapm = dapm;
+	w->codec = dapm->codec;
 	INIT_LIST_HEAD(&w->sources);
 	INIT_LIST_HEAD(&w->sinks);
 	INIT_LIST_HEAD(&w->list);
 	INIT_LIST_HEAD(&w->dirty);
 	list_add(&w->list, &dapm->card->widgets);
 
-	w->inputs = -1;
-	w->outputs = -1;
-
 	/* machine layer set ups unconnected pins and insertions */
 	w->connected = 1;
 	return w;
@@ -3227,7 +3184,7 @@
 {
 	struct snd_soc_dapm_path *source_p, *sink_p;
 	struct snd_soc_dai *source, *sink;
-	const struct snd_soc_pcm_stream *config = w->params + w->params_select;
+	const struct snd_soc_pcm_stream *config = w->params;
 	struct snd_pcm_substream substream;
 	struct snd_pcm_hw_params *params = NULL;
 	u64 fmt;
@@ -3319,97 +3276,22 @@
 	return ret;
 }
 
-static int snd_soc_dapm_dai_link_get(struct snd_kcontrol *kcontrol,
-			  struct snd_ctl_elem_value *ucontrol)
-{
-	struct snd_soc_dapm_widget *w = snd_kcontrol_chip(kcontrol);
-
-	ucontrol->value.integer.value[0] = w->params_select;
-
-	return 0;
-}
-
-static int snd_soc_dapm_dai_link_put(struct snd_kcontrol *kcontrol,
-			  struct snd_ctl_elem_value *ucontrol)
-{
-	struct snd_soc_dapm_widget *w = snd_kcontrol_chip(kcontrol);
-
-	/* Can't change the config when widget is already powered */
-	if (w->power)
-		return -EBUSY;
-
-	if (ucontrol->value.integer.value[0] == w->params_select)
-		return 0;
-
-	if (ucontrol->value.integer.value[0] >= w->num_params)
-		return -EINVAL;
-
-	w->params_select = ucontrol->value.integer.value[0];
-
-	return 0;
-}
-
 int snd_soc_dapm_new_pcm(struct snd_soc_card *card,
 			 const struct snd_soc_pcm_stream *params,
-			 unsigned int num_params,
 			 struct snd_soc_dapm_widget *source,
 			 struct snd_soc_dapm_widget *sink)
 {
 	struct snd_soc_dapm_widget template;
 	struct snd_soc_dapm_widget *w;
+	size_t len;
 	char *link_name;
-	int ret, count;
-	unsigned long private_value;
-	const char **w_param_text;
-	struct soc_enum w_param_enum[] = {
-		SOC_ENUM_SINGLE(0, 0, 0, NULL),
-	};
-	struct snd_kcontrol_new kcontrol_dai_link[] = {
-		SOC_ENUM_EXT(NULL, w_param_enum[0],
-			     snd_soc_dapm_dai_link_get,
-			     snd_soc_dapm_dai_link_put),
-	};
-	const struct snd_soc_pcm_stream *config = params;
-
-	w_param_text = devm_kcalloc(card->dev, num_params,
-					sizeof(char *), GFP_KERNEL);
-	if (!w_param_text)
-		return -ENOMEM;
-
-	link_name = devm_kasprintf(card->dev, GFP_KERNEL, "%s-%s",
-				   source->name, sink->name);
-	if (!link_name) {
-		ret = -ENOMEM;
-		goto outfree_w_param;
-	}
+	int ret;
 
-	for (count = 0 ; count < num_params; count++) {
-		if (!config->stream_name) {
-			dev_warn(card->dapm.dev,
-				"ASoC: anonymous config %d for dai link %s\n",
-				count, link_name);
-			w_param_text[count] =
-				devm_kasprintf(card->dev, GFP_KERNEL,
-					       "Anonymous Configuration %d",
-					       count);
-			if (!w_param_text[count]) {
-				ret = -ENOMEM;
-				goto outfree_link_name;
-			}
-		} else {
-			w_param_text[count] = devm_kmemdup(card->dev,
-						config->stream_name,
-						strlen(config->stream_name) + 1,
-						GFP_KERNEL);
-			if (!w_param_text[count]) {
-				ret = -ENOMEM;
-				goto outfree_link_name;
-			}
-		}
-		config++;
-	}
-	w_param_enum[0].items = num_params;
-	w_param_enum[0].texts = w_param_text;
+	len = strlen(source->name) + strlen(sink->name) + 2;
+	link_name = devm_kzalloc(card->dev, len, GFP_KERNEL);
+	if (!link_name)
+		return -ENOMEM;
+	snprintf(link_name, len, "%s-%s", source->name, sink->name);
 
 	memset(&template, 0, sizeof(template));
 	template.reg = SND_SOC_NOPM;
@@ -3418,30 +3300,6 @@
 	template.event = snd_soc_dai_link_event;
 	template.event_flags = SND_SOC_DAPM_PRE_PMU | SND_SOC_DAPM_POST_PMU |
 		SND_SOC_DAPM_PRE_PMD;
-	template.num_kcontrols = 1;
-	/* duplicate w_param_enum on heap so that memory persists */
-	private_value =
-		(unsigned long) devm_kmemdup(card->dev,
-			(void *)(kcontrol_dai_link[0].private_value),
-			sizeof(struct soc_enum), GFP_KERNEL);
-	if (!private_value) {
-		dev_err(card->dev, "ASoC: Failed to create control for %s widget\n",
-			link_name);
-		ret = -ENOMEM;
-		goto outfree_link_name;
-	}
-	kcontrol_dai_link[0].private_value = private_value;
-	/* duplicate kcontrol_dai_link on heap so that memory persists */
-	template.kcontrol_news =
-				devm_kmemdup(card->dev, &kcontrol_dai_link[0],
-					sizeof(struct snd_kcontrol_new),
-					GFP_KERNEL);
-	if (!template.kcontrol_news) {
-		dev_err(card->dev, "ASoC: Failed to create control for %s widget\n",
-			link_name);
-		ret = -ENOMEM;
-		goto outfree_private_value;
-	}
 
 	dev_dbg(card->dev, "ASoC: adding %s widget\n", link_name);
 
@@ -3449,32 +3307,15 @@
 	if (!w) {
 		dev_err(card->dev, "ASoC: Failed to create %s widget\n",
 			link_name);
-		ret = -ENOMEM;
-		goto outfree_kcontrol_news;
+		return -ENOMEM;
 	}
 
 	w->params = params;
-	w->num_params = num_params;
 
 	ret = snd_soc_dapm_add_path(&card->dapm, source, w, NULL, NULL);
 	if (ret)
-		goto outfree_w;
+		return ret;
 	return snd_soc_dapm_add_path(&card->dapm, w, sink, NULL, NULL);
-
-outfree_w:
-	devm_kfree(card->dev, w);
-outfree_kcontrol_news:
-	devm_kfree(card->dev, (void *)template.kcontrol_news);
-outfree_private_value:
-	devm_kfree(card->dev, (void *)private_value);
-outfree_link_name:
-	devm_kfree(card->dev, link_name);
-outfree_w_param:
-	for (count = 0 ; count < num_params; count++)
-		devm_kfree(card->dev, (void *)w_param_text[count]);
-	devm_kfree(card->dev, w_param_text);
-
-	return ret;
 }
 
 int snd_soc_dapm_new_dai_widgets(struct snd_soc_dapm_context *dapm,
@@ -3560,7 +3401,7 @@
 				break;
 			}
 
-			if (!w->sname || !strstr(w->sname, dai_w->sname))
+			if (!w->sname || !strstr(dai_w->name, w->sname))
 				continue;
 
 			if (dai_w->id == snd_soc_dapm_dai_in) {
@@ -3645,14 +3486,6 @@
 		case SND_SOC_DAPM_STREAM_PAUSE_RELEASE:
 			break;
 		}
-
-		if (w->id == snd_soc_dapm_dai_in) {
-			w->is_source = w->active;
-			dapm_widget_invalidate_input_paths(w);
-		} else {
-			w->is_sink = w->active;
-			dapm_widget_invalidate_output_paths(w);
-		}
 	}
 }
 
@@ -3779,15 +3612,7 @@
 	}
 
 	dev_dbg(w->dapm->dev, "ASoC: force enable pin %s\n", pin);
-	if (!w->connected) {
-		/*
-		 * w->force does not affect the number of input or output paths,
-		 * so we only have to recheck if w->connected is changed
-		 */
-		dapm_widget_invalidate_input_paths(w);
-		dapm_widget_invalidate_output_paths(w);
-		w->connected = 1;
-	}
+	w->connected = 1;
 	w->force = 1;
 	dapm_mark_dirty(w, "force enable");
 
@@ -3965,6 +3790,74 @@
 }
 EXPORT_SYMBOL_GPL(snd_soc_dapm_ignore_suspend);
 
+static bool snd_soc_dapm_widget_in_card_paths(struct snd_soc_card *card,
+					      struct snd_soc_dapm_widget *w)
+{
+	struct snd_soc_dapm_path *p;
+
+	list_for_each_entry(p, &card->paths, list) {
+		if ((p->source == w) || (p->sink == w)) {
+			dev_dbg(card->dev,
+			    "... Path %s(id:%d dapm:%p) - %s(id:%d dapm:%p)\n",
+			    p->source->name, p->source->id, p->source->dapm,
+			    p->sink->name, p->sink->id, p->sink->dapm);
+
+			/* Connected to something other than the codec */
+			if (p->source->dapm != p->sink->dapm)
+				return true;
+			/*
+			 * Loopback connection from codec external pin to
+			 * codec external pin
+			 */
+			if (p->sink->id == snd_soc_dapm_input) {
+				switch (p->source->id) {
+				case snd_soc_dapm_output:
+				case snd_soc_dapm_micbias:
+					return true;
+				default:
+					break;
+				}
+			}
+		}
+	}
+
+	return false;
+}
+
+/**
+ * snd_soc_dapm_auto_nc_pins - call snd_soc_dapm_nc_pin for unused pins
+ * @card: The card whose pins should be processed
+ *
+ * Automatically call snd_soc_dapm_nc_pin() for any external pins in the card
+ * which are unused. Pins are used if they are connected externally to a
+ * component, whether that be to some other device, or a loop-back connection to
+ * the component itself.
+ */
+void snd_soc_dapm_auto_nc_pins(struct snd_soc_card *card)
+{
+	struct snd_soc_dapm_widget *w;
+
+	dev_dbg(card->dev, "ASoC: Auto NC: DAPMs: card:%p\n", &card->dapm);
+
+	list_for_each_entry(w, &card->widgets, list) {
+		switch (w->id) {
+		case snd_soc_dapm_input:
+		case snd_soc_dapm_output:
+		case snd_soc_dapm_micbias:
+			dev_dbg(card->dev, "ASoC: Auto NC: Checking widget %s\n",
+				w->name);
+			if (!snd_soc_dapm_widget_in_card_paths(card, w)) {
+				dev_dbg(card->dev,
+					"... Not in map; disabling\n");
+				snd_soc_dapm_nc_pin(w->dapm, w->name);
+			}
+			break;
+		default:
+			break;
+		}
+	}
+}
+
 /**
  * snd_soc_dapm_free - free dapm resources
  * @dapm: DAPM context
@@ -3973,6 +3866,7 @@
  */
 void snd_soc_dapm_free(struct snd_soc_dapm_context *dapm)
 {
+	snd_soc_dapm_sys_remove(dapm->dev);
 	dapm_debugfs_cleanup(dapm);
 	dapm_free_widgets(dapm);
 	list_del(&dapm->list);
diff -Nru a/sound/soc/soc-dapm.c.orig b/sound/soc/soc-dapm.c.orig
--- a/sound/soc/soc-dapm.c.orig	1969-12-31 19:00:00.000000000 -0500
+++ b/sound/soc/soc-dapm.c.orig	2015-08-22 16:53:43.377985000 -0400
@@ -0,0 +1,4031 @@
+/*
+ * soc-dapm.c  --  ALSA SoC Dynamic Audio Power Management
+ *
+ * Copyright 2005 Wolfson Microelectronics PLC.
+ * Author: Liam Girdwood <lrg@slimlogic.co.uk>
+ *
+ *  This program is free software; you can redistribute  it and/or modify it
+ *  under  the terms of  the GNU General  Public License as published by the
+ *  Free Software Foundation;  either version 2 of the  License, or (at your
+ *  option) any later version.
+ *
+ *  Features:
+ *    o Changes power status of internal codec blocks depending on the
+ *      dynamic configuration of codec internal audio paths and active
+ *      DACs/ADCs.
+ *    o Platform power domain - can support external components i.e. amps and
+ *      mic/headphone insertion events.
+ *    o Automatic Mic Bias support
+ *    o Jack insertion power event initiation - e.g. hp insertion will enable
+ *      sinks, dacs, etc
+ *    o Delayed power down of audio subsystem to reduce pops between a quick
+ *      device reopen.
+ *
+ */
+
+#include <linux/module.h>
+#include <linux/moduleparam.h>
+#include <linux/init.h>
+#include <linux/async.h>
+#include <linux/delay.h>
+#include <linux/pm.h>
+#include <linux/bitops.h>
+#include <linux/platform_device.h>
+#include <linux/jiffies.h>
+#include <linux/debugfs.h>
+#include <linux/pm_runtime.h>
+#include <linux/regulator/consumer.h>
+#include <linux/clk.h>
+#include <linux/slab.h>
+#include <sound/core.h>
+#include <sound/pcm.h>
+#include <sound/pcm_params.h>
+#include <sound/soc.h>
+#include <sound/initval.h>
+
+#include <trace/events/asoc.h>
+
+#define DAPM_UPDATE_STAT(widget, val) widget->dapm->card->dapm_stats.val++;
+
+static int snd_soc_dapm_add_path(struct snd_soc_dapm_context *dapm,
+	struct snd_soc_dapm_widget *wsource, struct snd_soc_dapm_widget *wsink,
+	const char *control,
+	int (*connected)(struct snd_soc_dapm_widget *source,
+			 struct snd_soc_dapm_widget *sink));
+static struct snd_soc_dapm_widget *
+snd_soc_dapm_new_control(struct snd_soc_dapm_context *dapm,
+			 const struct snd_soc_dapm_widget *widget);
+
+/* dapm power sequences - make this per codec in the future */
+static int dapm_up_seq[] = {
+	[snd_soc_dapm_pre] = 0,
+	[snd_soc_dapm_regulator_supply] = 1,
+	[snd_soc_dapm_clock_supply] = 1,
+	[snd_soc_dapm_supply] = 2,
+	[snd_soc_dapm_micbias] = 3,
+	[snd_soc_dapm_dai_link] = 2,
+	[snd_soc_dapm_dai_in] = 4,
+	[snd_soc_dapm_dai_out] = 4,
+	[snd_soc_dapm_aif_in] = 4,
+	[snd_soc_dapm_aif_out] = 4,
+	[snd_soc_dapm_mic] = 5,
+	[snd_soc_dapm_mux] = 6,
+	[snd_soc_dapm_dac] = 7,
+	[snd_soc_dapm_switch] = 8,
+	[snd_soc_dapm_mixer] = 8,
+	[snd_soc_dapm_mixer_named_ctl] = 8,
+	[snd_soc_dapm_pga] = 9,
+	[snd_soc_dapm_adc] = 10,
+	[snd_soc_dapm_out_drv] = 11,
+	[snd_soc_dapm_hp] = 11,
+	[snd_soc_dapm_spk] = 11,
+	[snd_soc_dapm_line] = 11,
+	[snd_soc_dapm_kcontrol] = 12,
+	[snd_soc_dapm_post] = 13,
+};
+
+static int dapm_down_seq[] = {
+	[snd_soc_dapm_pre] = 0,
+	[snd_soc_dapm_kcontrol] = 1,
+	[snd_soc_dapm_adc] = 2,
+	[snd_soc_dapm_hp] = 3,
+	[snd_soc_dapm_spk] = 3,
+	[snd_soc_dapm_line] = 3,
+	[snd_soc_dapm_out_drv] = 3,
+	[snd_soc_dapm_pga] = 4,
+	[snd_soc_dapm_switch] = 5,
+	[snd_soc_dapm_mixer_named_ctl] = 5,
+	[snd_soc_dapm_mixer] = 5,
+	[snd_soc_dapm_dac] = 6,
+	[snd_soc_dapm_mic] = 7,
+	[snd_soc_dapm_micbias] = 8,
+	[snd_soc_dapm_mux] = 9,
+	[snd_soc_dapm_aif_in] = 10,
+	[snd_soc_dapm_aif_out] = 10,
+	[snd_soc_dapm_dai_in] = 10,
+	[snd_soc_dapm_dai_out] = 10,
+	[snd_soc_dapm_dai_link] = 11,
+	[snd_soc_dapm_supply] = 12,
+	[snd_soc_dapm_clock_supply] = 13,
+	[snd_soc_dapm_regulator_supply] = 13,
+	[snd_soc_dapm_post] = 14,
+};
+
+static void dapm_assert_locked(struct snd_soc_dapm_context *dapm)
+{
+	if (dapm->card && dapm->card->instantiated)
+		lockdep_assert_held(&dapm->card->dapm_mutex);
+}
+
+static void pop_wait(u32 pop_time)
+{
+	if (pop_time)
+		schedule_timeout_uninterruptible(msecs_to_jiffies(pop_time));
+}
+
+static void pop_dbg(struct device *dev, u32 pop_time, const char *fmt, ...)
+{
+	va_list args;
+	char *buf;
+
+	if (!pop_time)
+		return;
+
+	buf = kmalloc(PAGE_SIZE, GFP_KERNEL);
+	if (buf == NULL)
+		return;
+
+	va_start(args, fmt);
+	vsnprintf(buf, PAGE_SIZE, fmt, args);
+	dev_info(dev, "%s", buf);
+	va_end(args);
+
+	kfree(buf);
+}
+
+static bool dapm_dirty_widget(struct snd_soc_dapm_widget *w)
+{
+	return !list_empty(&w->dirty);
+}
+
+static void dapm_mark_dirty(struct snd_soc_dapm_widget *w, const char *reason)
+{
+	dapm_assert_locked(w->dapm);
+
+	if (!dapm_dirty_widget(w)) {
+		dev_vdbg(w->dapm->dev, "Marking %s dirty due to %s\n",
+			 w->name, reason);
+		list_add_tail(&w->dirty, &w->dapm->card->dapm_dirty);
+	}
+}
+
+/*
+ * dapm_widget_invalidate_input_paths() - Invalidate the cached number of input
+ *  paths
+ * @w: The widget for which to invalidate the cached number of input paths
+ *
+ * The function resets the cached number of inputs for the specified widget and
+ * all widgets that can be reached via outgoing paths from the widget.
+ *
+ * This function must be called if the number of input paths for a widget might
+ * have changed. E.g. if the source state of a widget changes or a path is added
+ * or activated with the widget as the sink.
+ */
+static void dapm_widget_invalidate_input_paths(struct snd_soc_dapm_widget *w)
+{
+	struct snd_soc_dapm_widget *sink;
+	struct snd_soc_dapm_path *p;
+	LIST_HEAD(list);
+
+	dapm_assert_locked(w->dapm);
+
+	if (w->inputs == -1)
+		return;
+
+	w->inputs = -1;
+	list_add_tail(&w->work_list, &list);
+
+	list_for_each_entry(w, &list, work_list) {
+		list_for_each_entry(p, &w->sinks, list_source) {
+			if (p->is_supply || p->weak || !p->connect)
+				continue;
+			sink = p->sink;
+			if (sink->inputs != -1) {
+				sink->inputs = -1;
+				list_add_tail(&sink->work_list, &list);
+			}
+		}
+	}
+}
+
+/*
+ * dapm_widget_invalidate_output_paths() - Invalidate the cached number of
+ *  output paths
+ * @w: The widget for which to invalidate the cached number of output paths
+ *
+ * Resets the cached number of outputs for the specified widget and all widgets
+ * that can be reached via incoming paths from the widget.
+ *
+ * This function must be called if the number of output paths for a widget might
+ * have changed. E.g. if the sink state of a widget changes or a path is added
+ * or activated with the widget as the source.
+ */
+static void dapm_widget_invalidate_output_paths(struct snd_soc_dapm_widget *w)
+{
+	struct snd_soc_dapm_widget *source;
+	struct snd_soc_dapm_path *p;
+	LIST_HEAD(list);
+
+	dapm_assert_locked(w->dapm);
+
+	if (w->outputs == -1)
+		return;
+
+	w->outputs = -1;
+	list_add_tail(&w->work_list, &list);
+
+	list_for_each_entry(w, &list, work_list) {
+		list_for_each_entry(p, &w->sources, list_sink) {
+			if (p->is_supply || p->weak || !p->connect)
+				continue;
+			source = p->source;
+			if (source->outputs != -1) {
+				source->outputs = -1;
+				list_add_tail(&source->work_list, &list);
+			}
+		}
+	}
+}
+
+/*
+ * dapm_path_invalidate() - Invalidates the cached number of inputs and outputs
+ *  for the widgets connected to a path
+ * @p: The path to invalidate
+ *
+ * Resets the cached number of inputs for the sink of the path and the cached
+ * number of outputs for the source of the path.
+ *
+ * This function must be called when a path is added, removed or the connected
+ * state changes.
+ */
+static void dapm_path_invalidate(struct snd_soc_dapm_path *p)
+{
+	/*
+	 * Weak paths or supply paths do not influence the number of input or
+	 * output paths of their neighbors.
+	 */
+	if (p->weak || p->is_supply)
+		return;
+
+	/*
+	 * The number of connected endpoints is the sum of the number of
+	 * connected endpoints of all neighbors. If a node with 0 connected
+	 * endpoints is either connected or disconnected that sum won't change,
+	 * so there is no need to re-check the path.
+	 */
+	if (p->source->inputs != 0)
+		dapm_widget_invalidate_input_paths(p->sink);
+	if (p->sink->outputs != 0)
+		dapm_widget_invalidate_output_paths(p->source);
+}
+
+void dapm_mark_endpoints_dirty(struct snd_soc_card *card)
+{
+	struct snd_soc_dapm_widget *w;
+
+	mutex_lock(&card->dapm_mutex);
+
+	list_for_each_entry(w, &card->widgets, list) {
+		if (w->is_sink || w->is_source) {
+			dapm_mark_dirty(w, "Rechecking endpoints");
+			if (w->is_sink)
+				dapm_widget_invalidate_output_paths(w);
+			if (w->is_source)
+				dapm_widget_invalidate_input_paths(w);
+		}
+	}
+
+	mutex_unlock(&card->dapm_mutex);
+}
+EXPORT_SYMBOL_GPL(dapm_mark_endpoints_dirty);
+
+/* create a new dapm widget */
+static inline struct snd_soc_dapm_widget *dapm_cnew_widget(
+	const struct snd_soc_dapm_widget *_widget)
+{
+	return kmemdup(_widget, sizeof(*_widget), GFP_KERNEL);
+}
+
+struct dapm_kcontrol_data {
+	unsigned int value;
+	struct snd_soc_dapm_widget *widget;
+	struct list_head paths;
+	struct snd_soc_dapm_widget_list *wlist;
+};
+
+static int dapm_kcontrol_data_alloc(struct snd_soc_dapm_widget *widget,
+	struct snd_kcontrol *kcontrol)
+{
+	struct dapm_kcontrol_data *data;
+	struct soc_mixer_control *mc;
+
+	data = kzalloc(sizeof(*data), GFP_KERNEL);
+	if (!data) {
+		dev_err(widget->dapm->dev,
+				"ASoC: can't allocate kcontrol data for %s\n",
+				widget->name);
+		return -ENOMEM;
+	}
+
+	INIT_LIST_HEAD(&data->paths);
+
+	switch (widget->id) {
+	case snd_soc_dapm_switch:
+	case snd_soc_dapm_mixer:
+	case snd_soc_dapm_mixer_named_ctl:
+		mc = (struct soc_mixer_control *)kcontrol->private_value;
+
+		if (mc->autodisable) {
+			struct snd_soc_dapm_widget template;
+
+			memset(&template, 0, sizeof(template));
+			template.reg = mc->reg;
+			template.mask = (1 << fls(mc->max)) - 1;
+			template.shift = mc->shift;
+			if (mc->invert)
+				template.off_val = mc->max;
+			else
+				template.off_val = 0;
+			template.on_val = template.off_val;
+			template.id = snd_soc_dapm_kcontrol;
+			template.name = kcontrol->id.name;
+
+			data->value = template.on_val;
+
+			data->widget = snd_soc_dapm_new_control(widget->dapm,
+				&template);
+			if (!data->widget) {
+				kfree(data);
+				return -ENOMEM;
+			}
+		}
+		break;
+	default:
+		break;
+	}
+
+	kcontrol->private_data = data;
+
+	return 0;
+}
+
+static void dapm_kcontrol_free(struct snd_kcontrol *kctl)
+{
+	struct dapm_kcontrol_data *data = snd_kcontrol_chip(kctl);
+	kfree(data->wlist);
+	kfree(data);
+}
+
+static struct snd_soc_dapm_widget_list *dapm_kcontrol_get_wlist(
+	const struct snd_kcontrol *kcontrol)
+{
+	struct dapm_kcontrol_data *data = snd_kcontrol_chip(kcontrol);
+
+	return data->wlist;
+}
+
+static int dapm_kcontrol_add_widget(struct snd_kcontrol *kcontrol,
+	struct snd_soc_dapm_widget *widget)
+{
+	struct dapm_kcontrol_data *data = snd_kcontrol_chip(kcontrol);
+	struct snd_soc_dapm_widget_list *new_wlist;
+	unsigned int n;
+
+	if (data->wlist)
+		n = data->wlist->num_widgets + 1;
+	else
+		n = 1;
+
+	new_wlist = krealloc(data->wlist,
+			sizeof(*new_wlist) + sizeof(widget) * n, GFP_KERNEL);
+	if (!new_wlist)
+		return -ENOMEM;
+
+	new_wlist->widgets[n - 1] = widget;
+	new_wlist->num_widgets = n;
+
+	data->wlist = new_wlist;
+
+	return 0;
+}
+
+static void dapm_kcontrol_add_path(const struct snd_kcontrol *kcontrol,
+	struct snd_soc_dapm_path *path)
+{
+	struct dapm_kcontrol_data *data = snd_kcontrol_chip(kcontrol);
+
+	list_add_tail(&path->list_kcontrol, &data->paths);
+
+	if (data->widget) {
+		snd_soc_dapm_add_path(data->widget->dapm, data->widget,
+		    path->source, NULL, NULL);
+	}
+}
+
+static bool dapm_kcontrol_is_powered(const struct snd_kcontrol *kcontrol)
+{
+	struct dapm_kcontrol_data *data = snd_kcontrol_chip(kcontrol);
+
+	if (!data->widget)
+		return true;
+
+	return data->widget->power;
+}
+
+static struct list_head *dapm_kcontrol_get_path_list(
+	const struct snd_kcontrol *kcontrol)
+{
+	struct dapm_kcontrol_data *data = snd_kcontrol_chip(kcontrol);
+
+	return &data->paths;
+}
+
+#define dapm_kcontrol_for_each_path(path, kcontrol) \
+	list_for_each_entry(path, dapm_kcontrol_get_path_list(kcontrol), \
+		list_kcontrol)
+
+unsigned int dapm_kcontrol_get_value(const struct snd_kcontrol *kcontrol)
+{
+	struct dapm_kcontrol_data *data = snd_kcontrol_chip(kcontrol);
+
+	return data->value;
+}
+EXPORT_SYMBOL_GPL(dapm_kcontrol_get_value);
+
+static bool dapm_kcontrol_set_value(const struct snd_kcontrol *kcontrol,
+	unsigned int value)
+{
+	struct dapm_kcontrol_data *data = snd_kcontrol_chip(kcontrol);
+
+	if (data->value == value)
+		return false;
+
+	if (data->widget)
+		data->widget->on_val = value;
+
+	data->value = value;
+
+	return true;
+}
+
+/**
+ * snd_soc_dapm_kcontrol_dapm() - Returns the dapm context associated to a
+ *  kcontrol
+ * @kcontrol: The kcontrol
+ *
+ * Note: This function must only be used on kcontrols that are known to have
+ * been registered for a CODEC. Otherwise the behaviour is undefined.
+ */
+struct snd_soc_dapm_context *snd_soc_dapm_kcontrol_dapm(
+	struct snd_kcontrol *kcontrol)
+{
+	return dapm_kcontrol_get_wlist(kcontrol)->widgets[0]->dapm;
+}
+EXPORT_SYMBOL_GPL(snd_soc_dapm_kcontrol_dapm);
+
+static void dapm_reset(struct snd_soc_card *card)
+{
+	struct snd_soc_dapm_widget *w;
+
+	lockdep_assert_held(&card->dapm_mutex);
+
+	memset(&card->dapm_stats, 0, sizeof(card->dapm_stats));
+
+	list_for_each_entry(w, &card->widgets, list) {
+		w->new_power = w->power;
+		w->power_checked = false;
+	}
+}
+
+static const char *soc_dapm_prefix(struct snd_soc_dapm_context *dapm)
+{
+	if (!dapm->component)
+		return NULL;
+	return dapm->component->name_prefix;
+}
+
+static int soc_dapm_read(struct snd_soc_dapm_context *dapm, int reg,
+	unsigned int *value)
+{
+	if (!dapm->component)
+		return -EIO;
+	return snd_soc_component_read(dapm->component, reg, value);
+}
+
+static int soc_dapm_update_bits(struct snd_soc_dapm_context *dapm,
+	int reg, unsigned int mask, unsigned int value)
+{
+	if (!dapm->component)
+		return -EIO;
+	return snd_soc_component_update_bits(dapm->component, reg,
+					     mask, value);
+}
+
+static int soc_dapm_test_bits(struct snd_soc_dapm_context *dapm,
+	int reg, unsigned int mask, unsigned int value)
+{
+	if (!dapm->component)
+		return -EIO;
+	return snd_soc_component_test_bits(dapm->component, reg, mask, value);
+}
+
+static void soc_dapm_async_complete(struct snd_soc_dapm_context *dapm)
+{
+	if (dapm->component)
+		snd_soc_component_async_complete(dapm->component);
+}
+
+/**
+ * snd_soc_dapm_set_bias_level - set the bias level for the system
+ * @dapm: DAPM context
+ * @level: level to configure
+ *
+ * Configure the bias (power) levels for the SoC audio device.
+ *
+ * Returns 0 for success else error.
+ */
+static int snd_soc_dapm_set_bias_level(struct snd_soc_dapm_context *dapm,
+				       enum snd_soc_bias_level level)
+{
+	struct snd_soc_card *card = dapm->card;
+	int ret = 0;
+
+	trace_snd_soc_bias_level_start(card, level);
+
+	if (card && card->set_bias_level)
+		ret = card->set_bias_level(card, dapm, level);
+	if (ret != 0)
+		goto out;
+
+	if (dapm->set_bias_level)
+		ret = dapm->set_bias_level(dapm, level);
+	else if (!card || dapm != &card->dapm)
+		dapm->bias_level = level;
+
+	if (ret != 0)
+		goto out;
+
+	if (card && card->set_bias_level_post)
+		ret = card->set_bias_level_post(card, dapm, level);
+out:
+	trace_snd_soc_bias_level_done(card, level);
+
+	return ret;
+}
+
+/* connect mux widget to its interconnecting audio paths */
+static int dapm_connect_mux(struct snd_soc_dapm_context *dapm,
+	struct snd_soc_dapm_path *path, const char *control_name)
+{
+	const struct snd_kcontrol_new *kcontrol = &path->sink->kcontrol_news[0];
+	struct soc_enum *e = (struct soc_enum *)kcontrol->private_value;
+	unsigned int val, item;
+	int i;
+
+	if (e->reg != SND_SOC_NOPM) {
+		soc_dapm_read(dapm, e->reg, &val);
+		val = (val >> e->shift_l) & e->mask;
+		item = snd_soc_enum_val_to_item(e, val);
+	} else {
+		/* since a virtual mux has no backing registers to
+		 * decide which path to connect, it will try to match
+		 * with the first enumeration.  This is to ensure
+		 * that the default mux choice (the first) will be
+		 * correctly powered up during initialization.
+		 */
+		item = 0;
+	}
+
+	for (i = 0; i < e->items; i++) {
+		if (!(strcmp(control_name, e->texts[i]))) {
+			path->name = e->texts[i];
+			if (i == item)
+				path->connect = 1;
+			else
+				path->connect = 0;
+			return 0;
+		}
+	}
+
+	return -ENODEV;
+}
+
+/* set up initial codec paths */
+static void dapm_set_mixer_path_status(struct snd_soc_dapm_path *p, int i)
+{
+	struct soc_mixer_control *mc = (struct soc_mixer_control *)
+		p->sink->kcontrol_news[i].private_value;
+	unsigned int reg = mc->reg;
+	unsigned int shift = mc->shift;
+	unsigned int max = mc->max;
+	unsigned int mask = (1 << fls(max)) - 1;
+	unsigned int invert = mc->invert;
+	unsigned int val;
+
+	if (reg != SND_SOC_NOPM) {
+		soc_dapm_read(p->sink->dapm, reg, &val);
+		val = (val >> shift) & mask;
+		if (invert)
+			val = max - val;
+		p->connect = !!val;
+	} else {
+		p->connect = 0;
+	}
+}
+
+/* connect mixer widget to its interconnecting audio paths */
+static int dapm_connect_mixer(struct snd_soc_dapm_context *dapm,
+	struct snd_soc_dapm_path *path, const char *control_name)
+{
+	int i;
+
+	/* search for mixer kcontrol */
+	for (i = 0; i < path->sink->num_kcontrols; i++) {
+		if (!strcmp(control_name, path->sink->kcontrol_news[i].name)) {
+			path->name = path->sink->kcontrol_news[i].name;
+			dapm_set_mixer_path_status(path, i);
+			return 0;
+		}
+	}
+	return -ENODEV;
+}
+
+static int dapm_is_shared_kcontrol(struct snd_soc_dapm_context *dapm,
+	struct snd_soc_dapm_widget *kcontrolw,
+	const struct snd_kcontrol_new *kcontrol_new,
+	struct snd_kcontrol **kcontrol)
+{
+	struct snd_soc_dapm_widget *w;
+	int i;
+
+	*kcontrol = NULL;
+
+	list_for_each_entry(w, &dapm->card->widgets, list) {
+		if (w == kcontrolw || w->dapm != kcontrolw->dapm)
+			continue;
+		for (i = 0; i < w->num_kcontrols; i++) {
+			if (&w->kcontrol_news[i] == kcontrol_new) {
+				if (w->kcontrols)
+					*kcontrol = w->kcontrols[i];
+				return 1;
+			}
+		}
+	}
+
+	return 0;
+}
+
+/*
+ * Determine if a kcontrol is shared. If it is, look it up. If it isn't,
+ * create it. Either way, add the widget into the control's widget list
+ */
+static int dapm_create_or_share_mixmux_kcontrol(struct snd_soc_dapm_widget *w,
+	int kci)
+{
+	struct snd_soc_dapm_context *dapm = w->dapm;
+	struct snd_card *card = dapm->card->snd_card;
+	const char *prefix;
+	size_t prefix_len;
+	int shared;
+	struct snd_kcontrol *kcontrol;
+	bool wname_in_long_name, kcname_in_long_name;
+	char *long_name = NULL;
+	const char *name;
+	int ret = 0;
+
+	prefix = soc_dapm_prefix(dapm);
+	if (prefix)
+		prefix_len = strlen(prefix) + 1;
+	else
+		prefix_len = 0;
+
+	shared = dapm_is_shared_kcontrol(dapm, w, &w->kcontrol_news[kci],
+					 &kcontrol);
+
+	if (!kcontrol) {
+		if (shared) {
+			wname_in_long_name = false;
+			kcname_in_long_name = true;
+		} else {
+			switch (w->id) {
+			case snd_soc_dapm_switch:
+			case snd_soc_dapm_mixer:
+				wname_in_long_name = true;
+				kcname_in_long_name = true;
+				break;
+			case snd_soc_dapm_mixer_named_ctl:
+				wname_in_long_name = false;
+				kcname_in_long_name = true;
+				break;
+			case snd_soc_dapm_mux:
+				wname_in_long_name = true;
+				kcname_in_long_name = false;
+				break;
+			default:
+				return -EINVAL;
+			}
+		}
+
+		if (wname_in_long_name && kcname_in_long_name) {
+			/*
+			 * The control will get a prefix from the control
+			 * creation process but we're also using the same
+			 * prefix for widgets so cut the prefix off the
+			 * front of the widget name.
+			 */
+			long_name = kasprintf(GFP_KERNEL, "%s %s",
+				 w->name + prefix_len,
+				 w->kcontrol_news[kci].name);
+			if (long_name == NULL)
+				return -ENOMEM;
+
+			name = long_name;
+		} else if (wname_in_long_name) {
+			long_name = NULL;
+			name = w->name + prefix_len;
+		} else {
+			long_name = NULL;
+			name = w->kcontrol_news[kci].name;
+		}
+
+		kcontrol = snd_soc_cnew(&w->kcontrol_news[kci], NULL, name,
+					prefix);
+		if (!kcontrol) {
+			ret = -ENOMEM;
+			goto exit_free;
+		}
+
+		kcontrol->private_free = dapm_kcontrol_free;
+
+		ret = dapm_kcontrol_data_alloc(w, kcontrol);
+		if (ret) {
+			snd_ctl_free_one(kcontrol);
+			goto exit_free;
+		}
+
+		ret = snd_ctl_add(card, kcontrol);
+		if (ret < 0) {
+			dev_err(dapm->dev,
+				"ASoC: failed to add widget %s dapm kcontrol %s: %d\n",
+				w->name, name, ret);
+			goto exit_free;
+		}
+	}
+
+	ret = dapm_kcontrol_add_widget(kcontrol, w);
+	if (ret == 0)
+		w->kcontrols[kci] = kcontrol;
+
+exit_free:
+	kfree(long_name);
+
+	return ret;
+}
+
+/* create new dapm mixer control */
+static int dapm_new_mixer(struct snd_soc_dapm_widget *w)
+{
+	int i, ret;
+	struct snd_soc_dapm_path *path;
+
+	/* add kcontrol */
+	for (i = 0; i < w->num_kcontrols; i++) {
+		/* match name */
+		list_for_each_entry(path, &w->sources, list_sink) {
+			/* mixer/mux paths name must match control name */
+			if (path->name != (char *)w->kcontrol_news[i].name)
+				continue;
+
+			if (w->kcontrols[i]) {
+				dapm_kcontrol_add_path(w->kcontrols[i], path);
+				continue;
+			}
+
+			ret = dapm_create_or_share_mixmux_kcontrol(w, i);
+			if (ret < 0)
+				return ret;
+
+			dapm_kcontrol_add_path(w->kcontrols[i], path);
+		}
+	}
+
+	return 0;
+}
+
+/* create new dapm mux control */
+static int dapm_new_mux(struct snd_soc_dapm_widget *w)
+{
+	struct snd_soc_dapm_context *dapm = w->dapm;
+	struct snd_soc_dapm_path *path;
+	int ret;
+
+	if (w->num_kcontrols != 1) {
+		dev_err(dapm->dev,
+			"ASoC: mux %s has incorrect number of controls\n",
+			w->name);
+		return -EINVAL;
+	}
+
+	if (list_empty(&w->sources)) {
+		dev_err(dapm->dev, "ASoC: mux %s has no paths\n", w->name);
+		return -EINVAL;
+	}
+
+	ret = dapm_create_or_share_mixmux_kcontrol(w, 0);
+	if (ret < 0)
+		return ret;
+
+	list_for_each_entry(path, &w->sources, list_sink) {
+		if (path->name)
+			dapm_kcontrol_add_path(w->kcontrols[0], path);
+	}
+
+	return 0;
+}
+
+/* create new dapm volume control */
+static int dapm_new_pga(struct snd_soc_dapm_widget *w)
+{
+	if (w->num_kcontrols)
+		dev_err(w->dapm->dev,
+			"ASoC: PGA controls not supported: '%s'\n", w->name);
+
+	return 0;
+}
+
+/* create new dapm dai link control */
+static int dapm_new_dai_link(struct snd_soc_dapm_widget *w)
+{
+	int i, ret;
+	struct snd_kcontrol *kcontrol;
+	struct snd_soc_dapm_context *dapm = w->dapm;
+	struct snd_card *card = dapm->card->snd_card;
+
+	/* create control for links with > 1 config */
+	if (w->num_params <= 1)
+		return 0;
+
+	/* add kcontrol */
+	for (i = 0; i < w->num_kcontrols; i++) {
+		kcontrol = snd_soc_cnew(&w->kcontrol_news[i], w,
+					w->name, NULL);
+		ret = snd_ctl_add(card, kcontrol);
+		if (ret < 0) {
+			dev_err(dapm->dev,
+				"ASoC: failed to add widget %s dapm kcontrol %s: %d\n",
+				w->name, w->kcontrol_news[i].name, ret);
+			return ret;
+		}
+		kcontrol->private_data = w;
+		w->kcontrols[i] = kcontrol;
+	}
+
+	return 0;
+}
+
+/* We implement power down on suspend by checking the power state of
+ * the ALSA card - when we are suspending the ALSA state for the card
+ * is set to D3.
+ */
+static int snd_soc_dapm_suspend_check(struct snd_soc_dapm_widget *widget)
+{
+	int level = snd_power_get_state(widget->dapm->card->snd_card);
+
+	switch (level) {
+	case SNDRV_CTL_POWER_D3hot:
+	case SNDRV_CTL_POWER_D3cold:
+		if (widget->ignore_suspend)
+			dev_dbg(widget->dapm->dev, "ASoC: %s ignoring suspend\n",
+				widget->name);
+		return widget->ignore_suspend;
+	default:
+		return 1;
+	}
+}
+
+/* add widget to list if it's not already in the list */
+static int dapm_list_add_widget(struct snd_soc_dapm_widget_list **list,
+	struct snd_soc_dapm_widget *w)
+{
+	struct snd_soc_dapm_widget_list *wlist;
+	int wlistsize, wlistentries, i;
+
+	if (*list == NULL)
+		return -EINVAL;
+
+	wlist = *list;
+
+	/* is this widget already in the list */
+	for (i = 0; i < wlist->num_widgets; i++) {
+		if (wlist->widgets[i] == w)
+			return 0;
+	}
+
+	/* allocate some new space */
+	wlistentries = wlist->num_widgets + 1;
+	wlistsize = sizeof(struct snd_soc_dapm_widget_list) +
+			wlistentries * sizeof(struct snd_soc_dapm_widget *);
+	*list = krealloc(wlist, wlistsize, GFP_KERNEL);
+	if (*list == NULL) {
+		dev_err(w->dapm->dev, "ASoC: can't allocate widget list for %s\n",
+			w->name);
+		return -ENOMEM;
+	}
+	wlist = *list;
+
+	/* insert the widget */
+	dev_dbg(w->dapm->dev, "ASoC: added %s in widget list pos %d\n",
+			w->name, wlist->num_widgets);
+
+	wlist->widgets[wlist->num_widgets] = w;
+	wlist->num_widgets++;
+	return 1;
+}
+
+/*
+ * Recursively check for a completed path to an active or physically connected
+ * output widget. Returns number of complete paths.
+ */
+static int is_connected_output_ep(struct snd_soc_dapm_widget *widget,
+	struct snd_soc_dapm_widget_list **list)
+{
+	struct snd_soc_dapm_path *path;
+	int con = 0;
+
+	if (widget->outputs >= 0)
+		return widget->outputs;
+
+	DAPM_UPDATE_STAT(widget, path_checks);
+
+	if (widget->is_sink && widget->connected) {
+		widget->outputs = snd_soc_dapm_suspend_check(widget);
+		return widget->outputs;
+	}
+
+	list_for_each_entry(path, &widget->sinks, list_source) {
+		DAPM_UPDATE_STAT(widget, neighbour_checks);
+
+		if (path->weak || path->is_supply)
+			continue;
+
+		if (path->walking)
+			return 1;
+
+		trace_snd_soc_dapm_output_path(widget, path);
+
+		if (path->connect) {
+			path->walking = 1;
+
+			/* do we need to add this widget to the list ? */
+			if (list) {
+				int err;
+				err = dapm_list_add_widget(list, path->sink);
+				if (err < 0) {
+					dev_err(widget->dapm->dev,
+						"ASoC: could not add widget %s\n",
+						widget->name);
+					path->walking = 0;
+					return con;
+				}
+			}
+
+			con += is_connected_output_ep(path->sink, list);
+
+			path->walking = 0;
+		}
+	}
+
+	widget->outputs = con;
+
+	return con;
+}
+
+/*
+ * Recursively check for a completed path to an active or physically connected
+ * input widget. Returns number of complete paths.
+ */
+static int is_connected_input_ep(struct snd_soc_dapm_widget *widget,
+	struct snd_soc_dapm_widget_list **list)
+{
+	struct snd_soc_dapm_path *path;
+	int con = 0;
+
+	if (widget->inputs >= 0)
+		return widget->inputs;
+
+	DAPM_UPDATE_STAT(widget, path_checks);
+
+	if (widget->is_source && widget->connected) {
+		widget->inputs = snd_soc_dapm_suspend_check(widget);
+		return widget->inputs;
+	}
+
+	list_for_each_entry(path, &widget->sources, list_sink) {
+		DAPM_UPDATE_STAT(widget, neighbour_checks);
+
+		if (path->weak || path->is_supply)
+			continue;
+
+		if (path->walking)
+			return 1;
+
+		trace_snd_soc_dapm_input_path(widget, path);
+
+		if (path->connect) {
+			path->walking = 1;
+
+			/* do we need to add this widget to the list ? */
+			if (list) {
+				int err;
+				err = dapm_list_add_widget(list, path->source);
+				if (err < 0) {
+					dev_err(widget->dapm->dev,
+						"ASoC: could not add widget %s\n",
+						widget->name);
+					path->walking = 0;
+					return con;
+				}
+			}
+
+			con += is_connected_input_ep(path->source, list);
+
+			path->walking = 0;
+		}
+	}
+
+	widget->inputs = con;
+
+	return con;
+}
+
+/**
+ * snd_soc_dapm_get_connected_widgets - query audio path and it's widgets.
+ * @dai: the soc DAI.
+ * @stream: stream direction.
+ * @list: list of active widgets for this stream.
+ *
+ * Queries DAPM graph as to whether an valid audio stream path exists for
+ * the initial stream specified by name. This takes into account
+ * current mixer and mux kcontrol settings. Creates list of valid widgets.
+ *
+ * Returns the number of valid paths or negative error.
+ */
+int snd_soc_dapm_dai_get_connected_widgets(struct snd_soc_dai *dai, int stream,
+	struct snd_soc_dapm_widget_list **list)
+{
+	struct snd_soc_card *card = dai->component->card;
+	struct snd_soc_dapm_widget *w;
+	int paths;
+
+	mutex_lock_nested(&card->dapm_mutex, SND_SOC_DAPM_CLASS_RUNTIME);
+
+	/*
+	 * For is_connected_{output,input}_ep fully discover the graph we need
+	 * to reset the cached number of inputs and outputs.
+	 */
+	list_for_each_entry(w, &card->widgets, list) {
+		w->inputs = -1;
+		w->outputs = -1;
+	}
+
+	if (stream == SNDRV_PCM_STREAM_PLAYBACK)
+		paths = is_connected_output_ep(dai->playback_widget, list);
+	else
+		paths = is_connected_input_ep(dai->capture_widget, list);
+
+	trace_snd_soc_dapm_connected(paths, stream);
+	mutex_unlock(&card->dapm_mutex);
+
+	return paths;
+}
+
+/*
+ * Handler for regulator supply widget.
+ */
+int dapm_regulator_event(struct snd_soc_dapm_widget *w,
+		   struct snd_kcontrol *kcontrol, int event)
+{
+	int ret;
+
+	soc_dapm_async_complete(w->dapm);
+
+	if (SND_SOC_DAPM_EVENT_ON(event)) {
+		if (w->on_val & SND_SOC_DAPM_REGULATOR_BYPASS) {
+			ret = regulator_allow_bypass(w->regulator, false);
+			if (ret != 0)
+				dev_warn(w->dapm->dev,
+					 "ASoC: Failed to unbypass %s: %d\n",
+					 w->name, ret);
+		}
+
+		return regulator_enable(w->regulator);
+	} else {
+		if (w->on_val & SND_SOC_DAPM_REGULATOR_BYPASS) {
+			ret = regulator_allow_bypass(w->regulator, true);
+			if (ret != 0)
+				dev_warn(w->dapm->dev,
+					 "ASoC: Failed to bypass %s: %d\n",
+					 w->name, ret);
+		}
+
+		return regulator_disable_deferred(w->regulator, w->shift);
+	}
+}
+EXPORT_SYMBOL_GPL(dapm_regulator_event);
+
+/*
+ * Handler for clock supply widget.
+ */
+int dapm_clock_event(struct snd_soc_dapm_widget *w,
+		   struct snd_kcontrol *kcontrol, int event)
+{
+	if (!w->clk)
+		return -EIO;
+
+	soc_dapm_async_complete(w->dapm);
+
+#ifdef CONFIG_HAVE_CLK
+	if (SND_SOC_DAPM_EVENT_ON(event)) {
+		return clk_prepare_enable(w->clk);
+	} else {
+		clk_disable_unprepare(w->clk);
+		return 0;
+	}
+#endif
+	return 0;
+}
+EXPORT_SYMBOL_GPL(dapm_clock_event);
+
+static int dapm_widget_power_check(struct snd_soc_dapm_widget *w)
+{
+	if (w->power_checked)
+		return w->new_power;
+
+	if (w->force)
+		w->new_power = 1;
+	else
+		w->new_power = w->power_check(w);
+
+	w->power_checked = true;
+
+	return w->new_power;
+}
+
+/* Generic check to see if a widget should be powered.
+ */
+static int dapm_generic_check_power(struct snd_soc_dapm_widget *w)
+{
+	int in, out;
+
+	DAPM_UPDATE_STAT(w, power_checks);
+
+	in = is_connected_input_ep(w, NULL);
+	out = is_connected_output_ep(w, NULL);
+	return out != 0 && in != 0;
+}
+
+/* Check to see if a power supply is needed */
+static int dapm_supply_check_power(struct snd_soc_dapm_widget *w)
+{
+	struct snd_soc_dapm_path *path;
+
+	DAPM_UPDATE_STAT(w, power_checks);
+
+	/* Check if one of our outputs is connected */
+	list_for_each_entry(path, &w->sinks, list_source) {
+		DAPM_UPDATE_STAT(w, neighbour_checks);
+
+		if (path->weak)
+			continue;
+
+		if (path->connected &&
+		    !path->connected(path->source, path->sink))
+			continue;
+
+		if (dapm_widget_power_check(path->sink))
+			return 1;
+	}
+
+	return 0;
+}
+
+static int dapm_always_on_check_power(struct snd_soc_dapm_widget *w)
+{
+	return 1;
+}
+
+static int dapm_seq_compare(struct snd_soc_dapm_widget *a,
+			    struct snd_soc_dapm_widget *b,
+			    bool power_up)
+{
+	int *sort;
+
+	if (power_up)
+		sort = dapm_up_seq;
+	else
+		sort = dapm_down_seq;
+
+	if (sort[a->id] != sort[b->id])
+		return sort[a->id] - sort[b->id];
+	if (a->subseq != b->subseq) {
+		if (power_up)
+			return a->subseq - b->subseq;
+		else
+			return b->subseq - a->subseq;
+	}
+	if (a->reg != b->reg)
+		return a->reg - b->reg;
+	if (a->dapm != b->dapm)
+		return (unsigned long)a->dapm - (unsigned long)b->dapm;
+
+	return 0;
+}
+
+/* Insert a widget in order into a DAPM power sequence. */
+static void dapm_seq_insert(struct snd_soc_dapm_widget *new_widget,
+			    struct list_head *list,
+			    bool power_up)
+{
+	struct snd_soc_dapm_widget *w;
+
+	list_for_each_entry(w, list, power_list)
+		if (dapm_seq_compare(new_widget, w, power_up) < 0) {
+			list_add_tail(&new_widget->power_list, &w->power_list);
+			return;
+		}
+
+	list_add_tail(&new_widget->power_list, list);
+}
+
+static void dapm_seq_check_event(struct snd_soc_card *card,
+				 struct snd_soc_dapm_widget *w, int event)
+{
+	const char *ev_name;
+	int power, ret;
+
+	switch (event) {
+	case SND_SOC_DAPM_PRE_PMU:
+		ev_name = "PRE_PMU";
+		power = 1;
+		break;
+	case SND_SOC_DAPM_POST_PMU:
+		ev_name = "POST_PMU";
+		power = 1;
+		break;
+	case SND_SOC_DAPM_PRE_PMD:
+		ev_name = "PRE_PMD";
+		power = 0;
+		break;
+	case SND_SOC_DAPM_POST_PMD:
+		ev_name = "POST_PMD";
+		power = 0;
+		break;
+	case SND_SOC_DAPM_WILL_PMU:
+		ev_name = "WILL_PMU";
+		power = 1;
+		break;
+	case SND_SOC_DAPM_WILL_PMD:
+		ev_name = "WILL_PMD";
+		power = 0;
+		break;
+	default:
+		WARN(1, "Unknown event %d\n", event);
+		return;
+	}
+
+	if (w->new_power != power)
+		return;
+
+	if (w->event && (w->event_flags & event)) {
+		pop_dbg(w->dapm->dev, card->pop_time, "pop test : %s %s\n",
+			w->name, ev_name);
+		soc_dapm_async_complete(w->dapm);
+		trace_snd_soc_dapm_widget_event_start(w, event);
+		ret = w->event(w, NULL, event);
+		trace_snd_soc_dapm_widget_event_done(w, event);
+		if (ret < 0)
+			dev_err(w->dapm->dev, "ASoC: %s: %s event failed: %d\n",
+			       ev_name, w->name, ret);
+	}
+}
+
+/* Apply the coalesced changes from a DAPM sequence */
+static void dapm_seq_run_coalesced(struct snd_soc_card *card,
+				   struct list_head *pending)
+{
+	struct snd_soc_dapm_context *dapm;
+	struct snd_soc_dapm_widget *w;
+	int reg;
+	unsigned int value = 0;
+	unsigned int mask = 0;
+
+	w = list_first_entry(pending, struct snd_soc_dapm_widget, power_list);
+	reg = w->reg;
+	dapm = w->dapm;
+
+	list_for_each_entry(w, pending, power_list) {
+		WARN_ON(reg != w->reg || dapm != w->dapm);
+		w->power = w->new_power;
+
+		mask |= w->mask << w->shift;
+		if (w->power)
+			value |= w->on_val << w->shift;
+		else
+			value |= w->off_val << w->shift;
+
+		pop_dbg(dapm->dev, card->pop_time,
+			"pop test : Queue %s: reg=0x%x, 0x%x/0x%x\n",
+			w->name, reg, value, mask);
+
+		/* Check for events */
+		dapm_seq_check_event(card, w, SND_SOC_DAPM_PRE_PMU);
+		dapm_seq_check_event(card, w, SND_SOC_DAPM_PRE_PMD);
+	}
+
+	if (reg >= 0) {
+		/* Any widget will do, they should all be updating the
+		 * same register.
+		 */
+
+		pop_dbg(dapm->dev, card->pop_time,
+			"pop test : Applying 0x%x/0x%x to %x in %dms\n",
+			value, mask, reg, card->pop_time);
+		pop_wait(card->pop_time);
+		soc_dapm_update_bits(dapm, reg, mask, value);
+	}
+
+	list_for_each_entry(w, pending, power_list) {
+		dapm_seq_check_event(card, w, SND_SOC_DAPM_POST_PMU);
+		dapm_seq_check_event(card, w, SND_SOC_DAPM_POST_PMD);
+	}
+}
+
+/* Apply a DAPM power sequence.
+ *
+ * We walk over a pre-sorted list of widgets to apply power to.  In
+ * order to minimise the number of writes to the device required
+ * multiple widgets will be updated in a single write where possible.
+ * Currently anything that requires more than a single write is not
+ * handled.
+ */
+static void dapm_seq_run(struct snd_soc_card *card,
+	struct list_head *list, int event, bool power_up)
+{
+	struct snd_soc_dapm_widget *w, *n;
+	struct snd_soc_dapm_context *d;
+	LIST_HEAD(pending);
+	int cur_sort = -1;
+	int cur_subseq = -1;
+	int cur_reg = SND_SOC_NOPM;
+	struct snd_soc_dapm_context *cur_dapm = NULL;
+	int ret, i;
+	int *sort;
+
+	if (power_up)
+		sort = dapm_up_seq;
+	else
+		sort = dapm_down_seq;
+
+	list_for_each_entry_safe(w, n, list, power_list) {
+		ret = 0;
+
+		/* Do we need to apply any queued changes? */
+		if (sort[w->id] != cur_sort || w->reg != cur_reg ||
+		    w->dapm != cur_dapm || w->subseq != cur_subseq) {
+			if (!list_empty(&pending))
+				dapm_seq_run_coalesced(card, &pending);
+
+			if (cur_dapm && cur_dapm->seq_notifier) {
+				for (i = 0; i < ARRAY_SIZE(dapm_up_seq); i++)
+					if (sort[i] == cur_sort)
+						cur_dapm->seq_notifier(cur_dapm,
+								       i,
+								       cur_subseq);
+			}
+
+			if (cur_dapm && w->dapm != cur_dapm)
+				soc_dapm_async_complete(cur_dapm);
+
+			INIT_LIST_HEAD(&pending);
+			cur_sort = -1;
+			cur_subseq = INT_MIN;
+			cur_reg = SND_SOC_NOPM;
+			cur_dapm = NULL;
+		}
+
+		switch (w->id) {
+		case snd_soc_dapm_pre:
+			if (!w->event)
+				list_for_each_entry_safe_continue(w, n, list,
+								  power_list);
+
+			if (event == SND_SOC_DAPM_STREAM_START)
+				ret = w->event(w,
+					       NULL, SND_SOC_DAPM_PRE_PMU);
+			else if (event == SND_SOC_DAPM_STREAM_STOP)
+				ret = w->event(w,
+					       NULL, SND_SOC_DAPM_PRE_PMD);
+			break;
+
+		case snd_soc_dapm_post:
+			if (!w->event)
+				list_for_each_entry_safe_continue(w, n, list,
+								  power_list);
+
+			if (event == SND_SOC_DAPM_STREAM_START)
+				ret = w->event(w,
+					       NULL, SND_SOC_DAPM_POST_PMU);
+			else if (event == SND_SOC_DAPM_STREAM_STOP)
+				ret = w->event(w,
+					       NULL, SND_SOC_DAPM_POST_PMD);
+			break;
+
+		default:
+			/* Queue it up for application */
+			cur_sort = sort[w->id];
+			cur_subseq = w->subseq;
+			cur_reg = w->reg;
+			cur_dapm = w->dapm;
+			list_move(&w->power_list, &pending);
+			break;
+		}
+
+		if (ret < 0)
+			dev_err(w->dapm->dev,
+				"ASoC: Failed to apply widget power: %d\n", ret);
+	}
+
+	if (!list_empty(&pending))
+		dapm_seq_run_coalesced(card, &pending);
+
+	if (cur_dapm && cur_dapm->seq_notifier) {
+		for (i = 0; i < ARRAY_SIZE(dapm_up_seq); i++)
+			if (sort[i] == cur_sort)
+				cur_dapm->seq_notifier(cur_dapm,
+						       i, cur_subseq);
+	}
+
+	list_for_each_entry(d, &card->dapm_list, list) {
+		soc_dapm_async_complete(d);
+	}
+}
+
+static void dapm_widget_update(struct snd_soc_card *card)
+{
+	struct snd_soc_dapm_update *update = card->update;
+	struct snd_soc_dapm_widget_list *wlist;
+	struct snd_soc_dapm_widget *w = NULL;
+	unsigned int wi;
+	int ret;
+
+	if (!update || !dapm_kcontrol_is_powered(update->kcontrol))
+		return;
+
+	wlist = dapm_kcontrol_get_wlist(update->kcontrol);
+
+	for (wi = 0; wi < wlist->num_widgets; wi++) {
+		w = wlist->widgets[wi];
+
+		if (w->event && (w->event_flags & SND_SOC_DAPM_PRE_REG)) {
+			ret = w->event(w, update->kcontrol, SND_SOC_DAPM_PRE_REG);
+			if (ret != 0)
+				dev_err(w->dapm->dev, "ASoC: %s DAPM pre-event failed: %d\n",
+					   w->name, ret);
+		}
+	}
+
+	if (!w)
+		return;
+
+	ret = soc_dapm_update_bits(w->dapm, update->reg, update->mask,
+		update->val);
+	if (ret < 0)
+		dev_err(w->dapm->dev, "ASoC: %s DAPM update failed: %d\n",
+			w->name, ret);
+
+	for (wi = 0; wi < wlist->num_widgets; wi++) {
+		w = wlist->widgets[wi];
+
+		if (w->event && (w->event_flags & SND_SOC_DAPM_POST_REG)) {
+			ret = w->event(w, update->kcontrol, SND_SOC_DAPM_POST_REG);
+			if (ret != 0)
+				dev_err(w->dapm->dev, "ASoC: %s DAPM post-event failed: %d\n",
+					   w->name, ret);
+		}
+	}
+}
+
+/* Async callback run prior to DAPM sequences - brings to _PREPARE if
+ * they're changing state.
+ */
+static void dapm_pre_sequence_async(void *data, async_cookie_t cookie)
+{
+	struct snd_soc_dapm_context *d = data;
+	int ret;
+
+	/* If we're off and we're not supposed to be go into STANDBY */
+	if (d->bias_level == SND_SOC_BIAS_OFF &&
+	    d->target_bias_level != SND_SOC_BIAS_OFF) {
+		if (d->dev)
+			pm_runtime_get_sync(d->dev);
+
+		ret = snd_soc_dapm_set_bias_level(d, SND_SOC_BIAS_STANDBY);
+		if (ret != 0)
+			dev_err(d->dev,
+				"ASoC: Failed to turn on bias: %d\n", ret);
+	}
+
+	/* Prepare for a transition to ON or away from ON */
+	if ((d->target_bias_level == SND_SOC_BIAS_ON &&
+	     d->bias_level != SND_SOC_BIAS_ON) ||
+	    (d->target_bias_level != SND_SOC_BIAS_ON &&
+	     d->bias_level == SND_SOC_BIAS_ON)) {
+		ret = snd_soc_dapm_set_bias_level(d, SND_SOC_BIAS_PREPARE);
+		if (ret != 0)
+			dev_err(d->dev,
+				"ASoC: Failed to prepare bias: %d\n", ret);
+	}
+}
+
+/* Async callback run prior to DAPM sequences - brings to their final
+ * state.
+ */
+static void dapm_post_sequence_async(void *data, async_cookie_t cookie)
+{
+	struct snd_soc_dapm_context *d = data;
+	int ret;
+
+	/* If we just powered the last thing off drop to standby bias */
+	if (d->bias_level == SND_SOC_BIAS_PREPARE &&
+	    (d->target_bias_level == SND_SOC_BIAS_STANDBY ||
+	     d->target_bias_level == SND_SOC_BIAS_OFF)) {
+		ret = snd_soc_dapm_set_bias_level(d, SND_SOC_BIAS_STANDBY);
+		if (ret != 0)
+			dev_err(d->dev, "ASoC: Failed to apply standby bias: %d\n",
+				ret);
+	}
+
+	/* If we're in standby and can support bias off then do that */
+	if (d->bias_level == SND_SOC_BIAS_STANDBY &&
+	    d->target_bias_level == SND_SOC_BIAS_OFF) {
+		ret = snd_soc_dapm_set_bias_level(d, SND_SOC_BIAS_OFF);
+		if (ret != 0)
+			dev_err(d->dev, "ASoC: Failed to turn off bias: %d\n",
+				ret);
+
+		if (d->dev)
+			pm_runtime_put(d->dev);
+	}
+
+	/* If we just powered up then move to active bias */
+	if (d->bias_level == SND_SOC_BIAS_PREPARE &&
+	    d->target_bias_level == SND_SOC_BIAS_ON) {
+		ret = snd_soc_dapm_set_bias_level(d, SND_SOC_BIAS_ON);
+		if (ret != 0)
+			dev_err(d->dev, "ASoC: Failed to apply active bias: %d\n",
+				ret);
+	}
+}
+
+static void dapm_widget_set_peer_power(struct snd_soc_dapm_widget *peer,
+				       bool power, bool connect)
+{
+	/* If a connection is being made or broken then that update
+	 * will have marked the peer dirty, otherwise the widgets are
+	 * not connected and this update has no impact. */
+	if (!connect)
+		return;
+
+	/* If the peer is already in the state we're moving to then we
+	 * won't have an impact on it. */
+	if (power != peer->power)
+		dapm_mark_dirty(peer, "peer state change");
+}
+
+static void dapm_widget_set_power(struct snd_soc_dapm_widget *w, bool power,
+				  struct list_head *up_list,
+				  struct list_head *down_list)
+{
+	struct snd_soc_dapm_path *path;
+
+	if (w->power == power)
+		return;
+
+	trace_snd_soc_dapm_widget_power(w, power);
+
+	/* If we changed our power state perhaps our neigbours changed
+	 * also.
+	 */
+	list_for_each_entry(path, &w->sources, list_sink)
+		dapm_widget_set_peer_power(path->source, power, path->connect);
+
+	/* Supplies can't affect their outputs, only their inputs */
+	if (!w->is_supply) {
+		list_for_each_entry(path, &w->sinks, list_source)
+			dapm_widget_set_peer_power(path->sink, power,
+						   path->connect);
+	}
+
+	if (power)
+		dapm_seq_insert(w, up_list, true);
+	else
+		dapm_seq_insert(w, down_list, false);
+}
+
+static void dapm_power_one_widget(struct snd_soc_dapm_widget *w,
+				  struct list_head *up_list,
+				  struct list_head *down_list)
+{
+	int power;
+
+	switch (w->id) {
+	case snd_soc_dapm_pre:
+		dapm_seq_insert(w, down_list, false);
+		break;
+	case snd_soc_dapm_post:
+		dapm_seq_insert(w, up_list, true);
+		break;
+
+	default:
+		power = dapm_widget_power_check(w);
+
+		dapm_widget_set_power(w, power, up_list, down_list);
+		break;
+	}
+}
+
+static bool dapm_idle_bias_off(struct snd_soc_dapm_context *dapm)
+{
+	if (dapm->idle_bias_off)
+		return true;
+
+	switch (snd_power_get_state(dapm->card->snd_card)) {
+	case SNDRV_CTL_POWER_D3hot:
+	case SNDRV_CTL_POWER_D3cold:
+		return dapm->suspend_bias_off;
+	default:
+		break;
+	}
+
+	return false;
+}
+
+/*
+ * Scan each dapm widget for complete audio path.
+ * A complete path is a route that has valid endpoints i.e.:-
+ *
+ *  o DAC to output pin.
+ *  o Input Pin to ADC.
+ *  o Input pin to Output pin (bypass, sidetone)
+ *  o DAC to ADC (loopback).
+ */
+static int dapm_power_widgets(struct snd_soc_card *card, int event)
+{
+	struct snd_soc_dapm_widget *w;
+	struct snd_soc_dapm_context *d;
+	LIST_HEAD(up_list);
+	LIST_HEAD(down_list);
+	ASYNC_DOMAIN_EXCLUSIVE(async_domain);
+	enum snd_soc_bias_level bias;
+
+	lockdep_assert_held(&card->dapm_mutex);
+
+	trace_snd_soc_dapm_start(card);
+
+	list_for_each_entry(d, &card->dapm_list, list) {
+		if (dapm_idle_bias_off(d))
+			d->target_bias_level = SND_SOC_BIAS_OFF;
+		else
+			d->target_bias_level = SND_SOC_BIAS_STANDBY;
+	}
+
+	dapm_reset(card);
+
+	/* Check which widgets we need to power and store them in
+	 * lists indicating if they should be powered up or down.  We
+	 * only check widgets that have been flagged as dirty but note
+	 * that new widgets may be added to the dirty list while we
+	 * iterate.
+	 */
+	list_for_each_entry(w, &card->dapm_dirty, dirty) {
+		dapm_power_one_widget(w, &up_list, &down_list);
+	}
+
+	list_for_each_entry(w, &card->widgets, list) {
+		switch (w->id) {
+		case snd_soc_dapm_pre:
+		case snd_soc_dapm_post:
+			/* These widgets always need to be powered */
+			break;
+		default:
+			list_del_init(&w->dirty);
+			break;
+		}
+
+		if (w->new_power) {
+			d = w->dapm;
+
+			/* Supplies and micbiases only bring the
+			 * context up to STANDBY as unless something
+			 * else is active and passing audio they
+			 * generally don't require full power.  Signal
+			 * generators are virtual pins and have no
+			 * power impact themselves.
+			 */
+			switch (w->id) {
+			case snd_soc_dapm_siggen:
+			case snd_soc_dapm_vmid:
+				break;
+			case snd_soc_dapm_supply:
+			case snd_soc_dapm_regulator_supply:
+			case snd_soc_dapm_clock_supply:
+			case snd_soc_dapm_micbias:
+				if (d->target_bias_level < SND_SOC_BIAS_STANDBY)
+					d->target_bias_level = SND_SOC_BIAS_STANDBY;
+				break;
+			default:
+				d->target_bias_level = SND_SOC_BIAS_ON;
+				break;
+			}
+		}
+
+	}
+
+	/* Force all contexts in the card to the same bias state if
+	 * they're not ground referenced.
+	 */
+	bias = SND_SOC_BIAS_OFF;
+	list_for_each_entry(d, &card->dapm_list, list)
+		if (d->target_bias_level > bias)
+			bias = d->target_bias_level;
+	list_for_each_entry(d, &card->dapm_list, list)
+		if (!dapm_idle_bias_off(d))
+			d->target_bias_level = bias;
+
+	trace_snd_soc_dapm_walk_done(card);
+
+	/* Run card bias changes at first */
+	dapm_pre_sequence_async(&card->dapm, 0);
+	/* Run other bias changes in parallel */
+	list_for_each_entry(d, &card->dapm_list, list) {
+		if (d != &card->dapm)
+			async_schedule_domain(dapm_pre_sequence_async, d,
+						&async_domain);
+	}
+	async_synchronize_full_domain(&async_domain);
+
+	list_for_each_entry(w, &down_list, power_list) {
+		dapm_seq_check_event(card, w, SND_SOC_DAPM_WILL_PMD);
+	}
+
+	list_for_each_entry(w, &up_list, power_list) {
+		dapm_seq_check_event(card, w, SND_SOC_DAPM_WILL_PMU);
+	}
+
+	/* Power down widgets first; try to avoid amplifying pops. */
+	dapm_seq_run(card, &down_list, event, false);
+
+	dapm_widget_update(card);
+
+	/* Now power up. */
+	dapm_seq_run(card, &up_list, event, true);
+
+	/* Run all the bias changes in parallel */
+	list_for_each_entry(d, &card->dapm_list, list) {
+		if (d != &card->dapm)
+			async_schedule_domain(dapm_post_sequence_async, d,
+						&async_domain);
+	}
+	async_synchronize_full_domain(&async_domain);
+	/* Run card bias changes at last */
+	dapm_post_sequence_async(&card->dapm, 0);
+
+	/* do we need to notify any clients that DAPM event is complete */
+	list_for_each_entry(d, &card->dapm_list, list) {
+		if (d->stream_event)
+			d->stream_event(d, event);
+	}
+
+	pop_dbg(card->dev, card->pop_time,
+		"DAPM sequencing finished, waiting %dms\n", card->pop_time);
+	pop_wait(card->pop_time);
+
+	trace_snd_soc_dapm_done(card);
+
+	return 0;
+}
+
+#ifdef CONFIG_DEBUG_FS
+static ssize_t dapm_widget_power_read_file(struct file *file,
+					   char __user *user_buf,
+					   size_t count, loff_t *ppos)
+{
+	struct snd_soc_dapm_widget *w = file->private_data;
+	struct snd_soc_card *card = w->dapm->card;
+	char *buf;
+	int in, out;
+	ssize_t ret;
+	struct snd_soc_dapm_path *p = NULL;
+
+	buf = kmalloc(PAGE_SIZE, GFP_KERNEL);
+	if (!buf)
+		return -ENOMEM;
+
+	mutex_lock(&card->dapm_mutex);
+
+	/* Supply widgets are not handled by is_connected_{input,output}_ep() */
+	if (w->is_supply) {
+		in = 0;
+		out = 0;
+	} else {
+		in = is_connected_input_ep(w, NULL);
+		out = is_connected_output_ep(w, NULL);
+	}
+
+	ret = snprintf(buf, PAGE_SIZE, "%s: %s%s  in %d out %d",
+		       w->name, w->power ? "On" : "Off",
+		       w->force ? " (forced)" : "", in, out);
+
+	if (w->reg >= 0)
+		ret += snprintf(buf + ret, PAGE_SIZE - ret,
+				" - R%d(0x%x) mask 0x%x",
+				w->reg, w->reg, w->mask << w->shift);
+
+	ret += snprintf(buf + ret, PAGE_SIZE - ret, "\n");
+
+	if (w->sname)
+		ret += snprintf(buf + ret, PAGE_SIZE - ret, " stream %s %s\n",
+				w->sname,
+				w->active ? "active" : "inactive");
+
+	list_for_each_entry(p, &w->sources, list_sink) {
+		if (p->connected && !p->connected(w, p->source))
+			continue;
+
+		if (p->connect)
+			ret += snprintf(buf + ret, PAGE_SIZE - ret,
+					" in  \"%s\" \"%s\"\n",
+					p->name ? p->name : "static",
+					p->source->name);
+	}
+	list_for_each_entry(p, &w->sinks, list_source) {
+		if (p->connected && !p->connected(w, p->sink))
+			continue;
+
+		if (p->connect)
+			ret += snprintf(buf + ret, PAGE_SIZE - ret,
+					" out \"%s\" \"%s\"\n",
+					p->name ? p->name : "static",
+					p->sink->name);
+	}
+
+	mutex_unlock(&card->dapm_mutex);
+
+	ret = simple_read_from_buffer(user_buf, count, ppos, buf, ret);
+
+	kfree(buf);
+	return ret;
+}
+
+static const struct file_operations dapm_widget_power_fops = {
+	.open = simple_open,
+	.read = dapm_widget_power_read_file,
+	.llseek = default_llseek,
+};
+
+static ssize_t dapm_bias_read_file(struct file *file, char __user *user_buf,
+				   size_t count, loff_t *ppos)
+{
+	struct snd_soc_dapm_context *dapm = file->private_data;
+	char *level;
+
+	switch (dapm->bias_level) {
+	case SND_SOC_BIAS_ON:
+		level = "On\n";
+		break;
+	case SND_SOC_BIAS_PREPARE:
+		level = "Prepare\n";
+		break;
+	case SND_SOC_BIAS_STANDBY:
+		level = "Standby\n";
+		break;
+	case SND_SOC_BIAS_OFF:
+		level = "Off\n";
+		break;
+	default:
+		WARN(1, "Unknown bias_level %d\n", dapm->bias_level);
+		level = "Unknown\n";
+		break;
+	}
+
+	return simple_read_from_buffer(user_buf, count, ppos, level,
+				       strlen(level));
+}
+
+static const struct file_operations dapm_bias_fops = {
+	.open = simple_open,
+	.read = dapm_bias_read_file,
+	.llseek = default_llseek,
+};
+
+void snd_soc_dapm_debugfs_init(struct snd_soc_dapm_context *dapm,
+	struct dentry *parent)
+{
+	struct dentry *d;
+
+	if (!parent)
+		return;
+
+	dapm->debugfs_dapm = debugfs_create_dir("dapm", parent);
+
+	if (!dapm->debugfs_dapm) {
+		dev_warn(dapm->dev,
+		       "ASoC: Failed to create DAPM debugfs directory\n");
+		return;
+	}
+
+	d = debugfs_create_file("bias_level", 0444,
+				dapm->debugfs_dapm, dapm,
+				&dapm_bias_fops);
+	if (!d)
+		dev_warn(dapm->dev,
+			 "ASoC: Failed to create bias level debugfs file\n");
+}
+
+static void dapm_debugfs_add_widget(struct snd_soc_dapm_widget *w)
+{
+	struct snd_soc_dapm_context *dapm = w->dapm;
+	struct dentry *d;
+
+	if (!dapm->debugfs_dapm || !w->name)
+		return;
+
+	d = debugfs_create_file(w->name, 0444,
+				dapm->debugfs_dapm, w,
+				&dapm_widget_power_fops);
+	if (!d)
+		dev_warn(w->dapm->dev,
+			"ASoC: Failed to create %s debugfs file\n",
+			w->name);
+}
+
+static void dapm_debugfs_cleanup(struct snd_soc_dapm_context *dapm)
+{
+	debugfs_remove_recursive(dapm->debugfs_dapm);
+}
+
+#else
+void snd_soc_dapm_debugfs_init(struct snd_soc_dapm_context *dapm,
+	struct dentry *parent)
+{
+}
+
+static inline void dapm_debugfs_add_widget(struct snd_soc_dapm_widget *w)
+{
+}
+
+static inline void dapm_debugfs_cleanup(struct snd_soc_dapm_context *dapm)
+{
+}
+
+#endif
+
+/*
+ * soc_dapm_connect_path() - Connects or disconnects a path
+ * @path: The path to update
+ * @connect: The new connect state of the path. True if the path is connected,
+ *  false if it is disconneted.
+ * @reason: The reason why the path changed (for debugging only)
+ */
+static void soc_dapm_connect_path(struct snd_soc_dapm_path *path,
+	bool connect, const char *reason)
+{
+	if (path->connect == connect)
+		return;
+
+	path->connect = connect;
+	dapm_mark_dirty(path->source, reason);
+	dapm_mark_dirty(path->sink, reason);
+	dapm_path_invalidate(path);
+}
+
+/* test and update the power status of a mux widget */
+static int soc_dapm_mux_update_power(struct snd_soc_card *card,
+				 struct snd_kcontrol *kcontrol, int mux, struct soc_enum *e)
+{
+	struct snd_soc_dapm_path *path;
+	int found = 0;
+	bool connect;
+
+	lockdep_assert_held(&card->dapm_mutex);
+
+	/* find dapm widget path assoc with kcontrol */
+	dapm_kcontrol_for_each_path(path, kcontrol) {
+		found = 1;
+		/* we now need to match the string in the enum to the path */
+		if (!(strcmp(path->name, e->texts[mux])))
+			connect = true;
+		else
+			connect = false;
+
+		soc_dapm_connect_path(path, connect, "mux update");
+	}
+
+	if (found)
+		dapm_power_widgets(card, SND_SOC_DAPM_STREAM_NOP);
+
+	return found;
+}
+
+int snd_soc_dapm_mux_update_power(struct snd_soc_dapm_context *dapm,
+	struct snd_kcontrol *kcontrol, int mux, struct soc_enum *e,
+	struct snd_soc_dapm_update *update)
+{
+	struct snd_soc_card *card = dapm->card;
+	int ret;
+
+	mutex_lock_nested(&card->dapm_mutex, SND_SOC_DAPM_CLASS_RUNTIME);
+	card->update = update;
+	ret = soc_dapm_mux_update_power(card, kcontrol, mux, e);
+	card->update = NULL;
+	mutex_unlock(&card->dapm_mutex);
+	if (ret > 0)
+		soc_dpcm_runtime_update(card);
+	return ret;
+}
+EXPORT_SYMBOL_GPL(snd_soc_dapm_mux_update_power);
+
+/* test and update the power status of a mixer or switch widget */
+static int soc_dapm_mixer_update_power(struct snd_soc_card *card,
+				   struct snd_kcontrol *kcontrol, int connect)
+{
+	struct snd_soc_dapm_path *path;
+	int found = 0;
+
+	lockdep_assert_held(&card->dapm_mutex);
+
+	/* find dapm widget path assoc with kcontrol */
+	dapm_kcontrol_for_each_path(path, kcontrol) {
+		found = 1;
+		soc_dapm_connect_path(path, connect, "mixer update");
+	}
+
+	if (found)
+		dapm_power_widgets(card, SND_SOC_DAPM_STREAM_NOP);
+
+	return found;
+}
+
+int snd_soc_dapm_mixer_update_power(struct snd_soc_dapm_context *dapm,
+	struct snd_kcontrol *kcontrol, int connect,
+	struct snd_soc_dapm_update *update)
+{
+	struct snd_soc_card *card = dapm->card;
+	int ret;
+
+	mutex_lock_nested(&card->dapm_mutex, SND_SOC_DAPM_CLASS_RUNTIME);
+	card->update = update;
+	ret = soc_dapm_mixer_update_power(card, kcontrol, connect);
+	card->update = NULL;
+	mutex_unlock(&card->dapm_mutex);
+	if (ret > 0)
+		soc_dpcm_runtime_update(card);
+	return ret;
+}
+EXPORT_SYMBOL_GPL(snd_soc_dapm_mixer_update_power);
+
+static ssize_t dapm_widget_show_codec(struct snd_soc_codec *codec, char *buf)
+{
+	struct snd_soc_dapm_widget *w;
+	int count = 0;
+	char *state = "not set";
+
+	list_for_each_entry(w, &codec->component.card->widgets, list) {
+		if (w->dapm != &codec->dapm)
+			continue;
+
+		/* only display widgets that burnm power */
+		switch (w->id) {
+		case snd_soc_dapm_hp:
+		case snd_soc_dapm_mic:
+		case snd_soc_dapm_spk:
+		case snd_soc_dapm_line:
+		case snd_soc_dapm_micbias:
+		case snd_soc_dapm_dac:
+		case snd_soc_dapm_adc:
+		case snd_soc_dapm_pga:
+		case snd_soc_dapm_out_drv:
+		case snd_soc_dapm_mixer:
+		case snd_soc_dapm_mixer_named_ctl:
+		case snd_soc_dapm_supply:
+		case snd_soc_dapm_regulator_supply:
+		case snd_soc_dapm_clock_supply:
+			if (w->name)
+				count += sprintf(buf + count, "%s: %s\n",
+					w->name, w->power ? "On":"Off");
+		break;
+		default:
+		break;
+		}
+	}
+
+	switch (codec->dapm.bias_level) {
+	case SND_SOC_BIAS_ON:
+		state = "On";
+		break;
+	case SND_SOC_BIAS_PREPARE:
+		state = "Prepare";
+		break;
+	case SND_SOC_BIAS_STANDBY:
+		state = "Standby";
+		break;
+	case SND_SOC_BIAS_OFF:
+		state = "Off";
+		break;
+	}
+	count += sprintf(buf + count, "PM State: %s\n", state);
+
+	return count;
+}
+
+/* show dapm widget status in sys fs */
+static ssize_t dapm_widget_show(struct device *dev,
+	struct device_attribute *attr, char *buf)
+{
+	struct snd_soc_pcm_runtime *rtd = dev_get_drvdata(dev);
+	int i, count = 0;
+
+	mutex_lock(&rtd->card->dapm_mutex);
+
+	for (i = 0; i < rtd->num_codecs; i++) {
+		struct snd_soc_codec *codec = rtd->codec_dais[i]->codec;
+		count += dapm_widget_show_codec(codec, buf + count);
+	}
+
+	mutex_unlock(&rtd->card->dapm_mutex);
+
+	return count;
+}
+
+static DEVICE_ATTR(dapm_widget, 0444, dapm_widget_show, NULL);
+
+struct attribute *soc_dapm_dev_attrs[] = {
+	&dev_attr_dapm_widget.attr,
+	NULL
+};
+
+static void dapm_free_path(struct snd_soc_dapm_path *path)
+{
+	list_del(&path->list_sink);
+	list_del(&path->list_source);
+	list_del(&path->list_kcontrol);
+	list_del(&path->list);
+	kfree(path);
+}
+
+/* free all dapm widgets and resources */
+static void dapm_free_widgets(struct snd_soc_dapm_context *dapm)
+{
+	struct snd_soc_dapm_widget *w, *next_w;
+	struct snd_soc_dapm_path *p, *next_p;
+
+	list_for_each_entry_safe(w, next_w, &dapm->card->widgets, list) {
+		if (w->dapm != dapm)
+			continue;
+		list_del(&w->list);
+		/*
+		 * remove source and sink paths associated to this widget.
+		 * While removing the path, remove reference to it from both
+		 * source and sink widgets so that path is removed only once.
+		 */
+		list_for_each_entry_safe(p, next_p, &w->sources, list_sink)
+			dapm_free_path(p);
+
+		list_for_each_entry_safe(p, next_p, &w->sinks, list_source)
+			dapm_free_path(p);
+
+		kfree(w->kcontrols);
+		kfree(w->name);
+		kfree(w);
+	}
+}
+
+static struct snd_soc_dapm_widget *dapm_find_widget(
+			struct snd_soc_dapm_context *dapm, const char *pin,
+			bool search_other_contexts)
+{
+	struct snd_soc_dapm_widget *w;
+	struct snd_soc_dapm_widget *fallback = NULL;
+
+	list_for_each_entry(w, &dapm->card->widgets, list) {
+		if (!strcmp(w->name, pin)) {
+			if (w->dapm == dapm)
+				return w;
+			else
+				fallback = w;
+		}
+	}
+
+	if (search_other_contexts)
+		return fallback;
+
+	return NULL;
+}
+
+static int snd_soc_dapm_set_pin(struct snd_soc_dapm_context *dapm,
+				const char *pin, int status)
+{
+	struct snd_soc_dapm_widget *w = dapm_find_widget(dapm, pin, true);
+
+	dapm_assert_locked(dapm);
+
+	if (!w) {
+		dev_err(dapm->dev, "ASoC: DAPM unknown pin %s\n", pin);
+		return -EINVAL;
+	}
+
+	if (w->connected != status) {
+		dapm_mark_dirty(w, "pin configuration");
+		dapm_widget_invalidate_input_paths(w);
+		dapm_widget_invalidate_output_paths(w);
+	}
+
+	w->connected = status;
+	if (status == 0)
+		w->force = 0;
+
+	return 0;
+}
+
+/**
+ * snd_soc_dapm_sync_unlocked - scan and power dapm paths
+ * @dapm: DAPM context
+ *
+ * Walks all dapm audio paths and powers widgets according to their
+ * stream or path usage.
+ *
+ * Requires external locking.
+ *
+ * Returns 0 for success.
+ */
+int snd_soc_dapm_sync_unlocked(struct snd_soc_dapm_context *dapm)
+{
+	/*
+	 * Suppress early reports (eg, jacks syncing their state) to avoid
+	 * silly DAPM runs during card startup.
+	 */
+	if (!dapm->card || !dapm->card->instantiated)
+		return 0;
+
+	return dapm_power_widgets(dapm->card, SND_SOC_DAPM_STREAM_NOP);
+}
+EXPORT_SYMBOL_GPL(snd_soc_dapm_sync_unlocked);
+
+/**
+ * snd_soc_dapm_sync - scan and power dapm paths
+ * @dapm: DAPM context
+ *
+ * Walks all dapm audio paths and powers widgets according to their
+ * stream or path usage.
+ *
+ * Returns 0 for success.
+ */
+int snd_soc_dapm_sync(struct snd_soc_dapm_context *dapm)
+{
+	int ret;
+
+	mutex_lock_nested(&dapm->card->dapm_mutex, SND_SOC_DAPM_CLASS_RUNTIME);
+	ret = snd_soc_dapm_sync_unlocked(dapm);
+	mutex_unlock(&dapm->card->dapm_mutex);
+	return ret;
+}
+EXPORT_SYMBOL_GPL(snd_soc_dapm_sync);
+
+/*
+ * dapm_update_widget_flags() - Re-compute widget sink and source flags
+ * @w: The widget for which to update the flags
+ *
+ * Some widgets have a dynamic category which depends on which neighbors they
+ * are connected to. This function update the category for these widgets.
+ *
+ * This function must be called whenever a path is added or removed to a widget.
+ */
+static void dapm_update_widget_flags(struct snd_soc_dapm_widget *w)
+{
+	struct snd_soc_dapm_path *p;
+
+	switch (w->id) {
+	case snd_soc_dapm_input:
+		/* On a fully routed card a input is never a source */
+		if (w->dapm->card->fully_routed)
+			break;
+		w->is_source = 1;
+		list_for_each_entry(p, &w->sources, list_sink) {
+			if (p->source->id == snd_soc_dapm_micbias ||
+				p->source->id == snd_soc_dapm_mic ||
+				p->source->id == snd_soc_dapm_line ||
+				p->source->id == snd_soc_dapm_output) {
+					w->is_source = 0;
+					break;
+			}
+		}
+		break;
+	case snd_soc_dapm_output:
+		/* On a fully routed card a output is never a sink */
+		if (w->dapm->card->fully_routed)
+			break;
+		w->is_sink = 1;
+		list_for_each_entry(p, &w->sinks, list_source) {
+			if (p->sink->id == snd_soc_dapm_spk ||
+				p->sink->id == snd_soc_dapm_hp ||
+				p->sink->id == snd_soc_dapm_line ||
+				p->sink->id == snd_soc_dapm_input) {
+					w->is_sink = 0;
+					break;
+			}
+		}
+		break;
+	case snd_soc_dapm_line:
+		w->is_sink = !list_empty(&w->sources);
+		w->is_source = !list_empty(&w->sinks);
+		break;
+	default:
+		break;
+	}
+}
+
+static int snd_soc_dapm_add_path(struct snd_soc_dapm_context *dapm,
+	struct snd_soc_dapm_widget *wsource, struct snd_soc_dapm_widget *wsink,
+	const char *control,
+	int (*connected)(struct snd_soc_dapm_widget *source,
+			 struct snd_soc_dapm_widget *sink))
+{
+	struct snd_soc_dapm_path *path;
+	int ret;
+
+	if (wsink->is_supply && !wsource->is_supply) {
+		dev_err(dapm->dev,
+			"Connecting non-supply widget to supply widget is not supported (%s -> %s)\n",
+			wsource->name, wsink->name);
+		return -EINVAL;
+	}
+
+	if (connected && !wsource->is_supply) {
+		dev_err(dapm->dev,
+			"connected() callback only supported for supply widgets (%s -> %s)\n",
+			wsource->name, wsink->name);
+		return -EINVAL;
+	}
+
+	if (wsource->is_supply && control) {
+		dev_err(dapm->dev,
+			"Conditional paths are not supported for supply widgets (%s -> [%s] -> %s)\n",
+			wsource->name, control, wsink->name);
+		return -EINVAL;
+	}
+
+	path = kzalloc(sizeof(struct snd_soc_dapm_path), GFP_KERNEL);
+	if (!path)
+		return -ENOMEM;
+
+	path->source = wsource;
+	path->sink = wsink;
+	path->connected = connected;
+	INIT_LIST_HEAD(&path->list);
+	INIT_LIST_HEAD(&path->list_kcontrol);
+	INIT_LIST_HEAD(&path->list_source);
+	INIT_LIST_HEAD(&path->list_sink);
+
+	if (wsource->is_supply || wsink->is_supply)
+		path->is_supply = 1;
+
+	/* connect static paths */
+	if (control == NULL) {
+		path->connect = 1;
+	} else {
+		/* connect dynamic paths */
+		switch (wsink->id) {
+		case snd_soc_dapm_mux:
+			ret = dapm_connect_mux(dapm, path, control);
+			if (ret != 0)
+				goto err;
+			break;
+		case snd_soc_dapm_switch:
+		case snd_soc_dapm_mixer:
+		case snd_soc_dapm_mixer_named_ctl:
+			ret = dapm_connect_mixer(dapm, path, control);
+			if (ret != 0)
+				goto err;
+			break;
+		default:
+			dev_err(dapm->dev,
+				"Control not supported for path %s -> [%s] -> %s\n",
+				wsource->name, control, wsink->name);
+			ret = -EINVAL;
+			goto err;
+		}
+	}
+
+	list_add(&path->list, &dapm->card->paths);
+	list_add(&path->list_sink, &wsink->sources);
+	list_add(&path->list_source, &wsource->sinks);
+
+	dapm_update_widget_flags(wsource);
+	dapm_update_widget_flags(wsink);
+
+	dapm_mark_dirty(wsource, "Route added");
+	dapm_mark_dirty(wsink, "Route added");
+
+	if (dapm->card->instantiated && path->connect)
+		dapm_path_invalidate(path);
+
+	return 0;
+err:
+	kfree(path);
+	return ret;
+}
+
+static int snd_soc_dapm_add_route(struct snd_soc_dapm_context *dapm,
+				  const struct snd_soc_dapm_route *route)
+{
+	struct snd_soc_dapm_widget *wsource = NULL, *wsink = NULL, *w;
+	struct snd_soc_dapm_widget *wtsource = NULL, *wtsink = NULL;
+	const char *sink;
+	const char *source;
+	char prefixed_sink[80];
+	char prefixed_source[80];
+	const char *prefix;
+	int ret;
+
+	prefix = soc_dapm_prefix(dapm);
+	if (prefix) {
+		snprintf(prefixed_sink, sizeof(prefixed_sink), "%s %s",
+			 prefix, route->sink);
+		sink = prefixed_sink;
+		snprintf(prefixed_source, sizeof(prefixed_source), "%s %s",
+			 prefix, route->source);
+		source = prefixed_source;
+	} else {
+		sink = route->sink;
+		source = route->source;
+	}
+
+	/*
+	 * find src and dest widgets over all widgets but favor a widget from
+	 * current DAPM context
+	 */
+	list_for_each_entry(w, &dapm->card->widgets, list) {
+		if (!wsink && !(strcmp(w->name, sink))) {
+			wtsink = w;
+			if (w->dapm == dapm)
+				wsink = w;
+			continue;
+		}
+		if (!wsource && !(strcmp(w->name, source))) {
+			wtsource = w;
+			if (w->dapm == dapm)
+				wsource = w;
+		}
+	}
+	/* use widget from another DAPM context if not found from this */
+	if (!wsink)
+		wsink = wtsink;
+	if (!wsource)
+		wsource = wtsource;
+
+	if (wsource == NULL) {
+		dev_err(dapm->dev, "ASoC: no source widget found for %s\n",
+			route->source);
+		return -ENODEV;
+	}
+	if (wsink == NULL) {
+		dev_err(dapm->dev, "ASoC: no sink widget found for %s\n",
+			route->sink);
+		return -ENODEV;
+	}
+
+	ret = snd_soc_dapm_add_path(dapm, wsource, wsink, route->control,
+		route->connected);
+	if (ret)
+		goto err;
+
+	return 0;
+err:
+	dev_warn(dapm->dev, "ASoC: no dapm match for %s --> %s --> %s\n",
+		 source, route->control, sink);
+	return ret;
+}
+
+static int snd_soc_dapm_del_route(struct snd_soc_dapm_context *dapm,
+				  const struct snd_soc_dapm_route *route)
+{
+	struct snd_soc_dapm_widget *wsource, *wsink;
+	struct snd_soc_dapm_path *path, *p;
+	const char *sink;
+	const char *source;
+	char prefixed_sink[80];
+	char prefixed_source[80];
+	const char *prefix;
+
+	if (route->control) {
+		dev_err(dapm->dev,
+			"ASoC: Removal of routes with controls not supported\n");
+		return -EINVAL;
+	}
+
+	prefix = soc_dapm_prefix(dapm);
+	if (prefix) {
+		snprintf(prefixed_sink, sizeof(prefixed_sink), "%s %s",
+			 prefix, route->sink);
+		sink = prefixed_sink;
+		snprintf(prefixed_source, sizeof(prefixed_source), "%s %s",
+			 prefix, route->source);
+		source = prefixed_source;
+	} else {
+		sink = route->sink;
+		source = route->source;
+	}
+
+	path = NULL;
+	list_for_each_entry(p, &dapm->card->paths, list) {
+		if (strcmp(p->source->name, source) != 0)
+			continue;
+		if (strcmp(p->sink->name, sink) != 0)
+			continue;
+		path = p;
+		break;
+	}
+
+	if (path) {
+		wsource = path->source;
+		wsink = path->sink;
+
+		dapm_mark_dirty(wsource, "Route removed");
+		dapm_mark_dirty(wsink, "Route removed");
+		if (path->connect)
+			dapm_path_invalidate(path);
+
+		dapm_free_path(path);
+
+		/* Update any path related flags */
+		dapm_update_widget_flags(wsource);
+		dapm_update_widget_flags(wsink);
+	} else {
+		dev_warn(dapm->dev, "ASoC: Route %s->%s does not exist\n",
+			 source, sink);
+	}
+
+	return 0;
+}
+
+/**
+ * snd_soc_dapm_add_routes - Add routes between DAPM widgets
+ * @dapm: DAPM context
+ * @route: audio routes
+ * @num: number of routes
+ *
+ * Connects 2 dapm widgets together via a named audio path. The sink is
+ * the widget receiving the audio signal, whilst the source is the sender
+ * of the audio signal.
+ *
+ * Returns 0 for success else error. On error all resources can be freed
+ * with a call to snd_soc_card_free().
+ */
+int snd_soc_dapm_add_routes(struct snd_soc_dapm_context *dapm,
+			    const struct snd_soc_dapm_route *route, int num)
+{
+	int i, r, ret = 0;
+
+	mutex_lock_nested(&dapm->card->dapm_mutex, SND_SOC_DAPM_CLASS_INIT);
+	for (i = 0; i < num; i++) {
+		r = snd_soc_dapm_add_route(dapm, route);
+		if (r < 0) {
+			dev_err(dapm->dev, "ASoC: Failed to add route %s -> %s -> %s\n",
+				route->source,
+				route->control ? route->control : "direct",
+				route->sink);
+			ret = r;
+		}
+		route++;
+	}
+	mutex_unlock(&dapm->card->dapm_mutex);
+
+	return ret;
+}
+EXPORT_SYMBOL_GPL(snd_soc_dapm_add_routes);
+
+/**
+ * snd_soc_dapm_del_routes - Remove routes between DAPM widgets
+ * @dapm: DAPM context
+ * @route: audio routes
+ * @num: number of routes
+ *
+ * Removes routes from the DAPM context.
+ */
+int snd_soc_dapm_del_routes(struct snd_soc_dapm_context *dapm,
+			    const struct snd_soc_dapm_route *route, int num)
+{
+	int i, ret = 0;
+
+	mutex_lock_nested(&dapm->card->dapm_mutex, SND_SOC_DAPM_CLASS_INIT);
+	for (i = 0; i < num; i++) {
+		snd_soc_dapm_del_route(dapm, route);
+		route++;
+	}
+	mutex_unlock(&dapm->card->dapm_mutex);
+
+	return ret;
+}
+EXPORT_SYMBOL_GPL(snd_soc_dapm_del_routes);
+
+static int snd_soc_dapm_weak_route(struct snd_soc_dapm_context *dapm,
+				   const struct snd_soc_dapm_route *route)
+{
+	struct snd_soc_dapm_widget *source = dapm_find_widget(dapm,
+							      route->source,
+							      true);
+	struct snd_soc_dapm_widget *sink = dapm_find_widget(dapm,
+							    route->sink,
+							    true);
+	struct snd_soc_dapm_path *path;
+	int count = 0;
+
+	if (!source) {
+		dev_err(dapm->dev, "ASoC: Unable to find source %s for weak route\n",
+			route->source);
+		return -ENODEV;
+	}
+
+	if (!sink) {
+		dev_err(dapm->dev, "ASoC: Unable to find sink %s for weak route\n",
+			route->sink);
+		return -ENODEV;
+	}
+
+	if (route->control || route->connected)
+		dev_warn(dapm->dev, "ASoC: Ignoring control for weak route %s->%s\n",
+			 route->source, route->sink);
+
+	list_for_each_entry(path, &source->sinks, list_source) {
+		if (path->sink == sink) {
+			path->weak = 1;
+			count++;
+		}
+	}
+
+	if (count == 0)
+		dev_err(dapm->dev, "ASoC: No path found for weak route %s->%s\n",
+			route->source, route->sink);
+	if (count > 1)
+		dev_warn(dapm->dev, "ASoC: %d paths found for weak route %s->%s\n",
+			 count, route->source, route->sink);
+
+	return 0;
+}
+
+/**
+ * snd_soc_dapm_weak_routes - Mark routes between DAPM widgets as weak
+ * @dapm: DAPM context
+ * @route: audio routes
+ * @num: number of routes
+ *
+ * Mark existing routes matching those specified in the passed array
+ * as being weak, meaning that they are ignored for the purpose of
+ * power decisions.  The main intended use case is for sidetone paths
+ * which couple audio between other independent paths if they are both
+ * active in order to make the combination work better at the user
+ * level but which aren't intended to be "used".
+ *
+ * Note that CODEC drivers should not use this as sidetone type paths
+ * can frequently also be used as bypass paths.
+ */
+int snd_soc_dapm_weak_routes(struct snd_soc_dapm_context *dapm,
+			     const struct snd_soc_dapm_route *route, int num)
+{
+	int i, err;
+	int ret = 0;
+
+	mutex_lock_nested(&dapm->card->dapm_mutex, SND_SOC_DAPM_CLASS_INIT);
+	for (i = 0; i < num; i++) {
+		err = snd_soc_dapm_weak_route(dapm, route);
+		if (err)
+			ret = err;
+		route++;
+	}
+	mutex_unlock(&dapm->card->dapm_mutex);
+
+	return ret;
+}
+EXPORT_SYMBOL_GPL(snd_soc_dapm_weak_routes);
+
+/**
+ * snd_soc_dapm_new_widgets - add new dapm widgets
+ * @dapm: DAPM context
+ *
+ * Checks the codec for any new dapm widgets and creates them if found.
+ *
+ * Returns 0 for success.
+ */
+int snd_soc_dapm_new_widgets(struct snd_soc_card *card)
+{
+	struct snd_soc_dapm_widget *w;
+	unsigned int val;
+
+	mutex_lock_nested(&card->dapm_mutex, SND_SOC_DAPM_CLASS_INIT);
+
+	list_for_each_entry(w, &card->widgets, list)
+	{
+		if (w->new)
+			continue;
+
+		if (w->num_kcontrols) {
+			w->kcontrols = kzalloc(w->num_kcontrols *
+						sizeof(struct snd_kcontrol *),
+						GFP_KERNEL);
+			if (!w->kcontrols) {
+				mutex_unlock(&card->dapm_mutex);
+				return -ENOMEM;
+			}
+		}
+
+		switch(w->id) {
+		case snd_soc_dapm_switch:
+		case snd_soc_dapm_mixer:
+		case snd_soc_dapm_mixer_named_ctl:
+			dapm_new_mixer(w);
+			break;
+		case snd_soc_dapm_mux:
+			dapm_new_mux(w);
+			break;
+		case snd_soc_dapm_pga:
+		case snd_soc_dapm_out_drv:
+			dapm_new_pga(w);
+			break;
+		case snd_soc_dapm_dai_link:
+			dapm_new_dai_link(w);
+			break;
+		default:
+			break;
+		}
+
+		/* Read the initial power state from the device */
+		if (w->reg >= 0) {
+			soc_dapm_read(w->dapm, w->reg, &val);
+			val = val >> w->shift;
+			val &= w->mask;
+			if (val == w->on_val)
+				w->power = 1;
+		}
+
+		w->new = 1;
+
+		dapm_mark_dirty(w, "new widget");
+		dapm_debugfs_add_widget(w);
+	}
+
+	dapm_power_widgets(card, SND_SOC_DAPM_STREAM_NOP);
+	mutex_unlock(&card->dapm_mutex);
+	return 0;
+}
+EXPORT_SYMBOL_GPL(snd_soc_dapm_new_widgets);
+
+/**
+ * snd_soc_dapm_get_volsw - dapm mixer get callback
+ * @kcontrol: mixer control
+ * @ucontrol: control element information
+ *
+ * Callback to get the value of a dapm mixer control.
+ *
+ * Returns 0 for success.
+ */
+int snd_soc_dapm_get_volsw(struct snd_kcontrol *kcontrol,
+	struct snd_ctl_elem_value *ucontrol)
+{
+	struct snd_soc_dapm_context *dapm = snd_soc_dapm_kcontrol_dapm(kcontrol);
+	struct snd_soc_card *card = dapm->card;
+	struct soc_mixer_control *mc =
+		(struct soc_mixer_control *)kcontrol->private_value;
+	int reg = mc->reg;
+	unsigned int shift = mc->shift;
+	int max = mc->max;
+	unsigned int mask = (1 << fls(max)) - 1;
+	unsigned int invert = mc->invert;
+	unsigned int val;
+	int ret = 0;
+
+	if (snd_soc_volsw_is_stereo(mc))
+		dev_warn(dapm->dev,
+			 "ASoC: Control '%s' is stereo, which is not supported\n",
+			 kcontrol->id.name);
+
+	mutex_lock_nested(&card->dapm_mutex, SND_SOC_DAPM_CLASS_RUNTIME);
+	if (dapm_kcontrol_is_powered(kcontrol) && reg != SND_SOC_NOPM) {
+		ret = soc_dapm_read(dapm, reg, &val);
+		val = (val >> shift) & mask;
+	} else {
+		val = dapm_kcontrol_get_value(kcontrol);
+	}
+	mutex_unlock(&card->dapm_mutex);
+
+	if (invert)
+		ucontrol->value.integer.value[0] = max - val;
+	else
+		ucontrol->value.integer.value[0] = val;
+
+	return ret;
+}
+EXPORT_SYMBOL_GPL(snd_soc_dapm_get_volsw);
+
+/**
+ * snd_soc_dapm_put_volsw - dapm mixer set callback
+ * @kcontrol: mixer control
+ * @ucontrol: control element information
+ *
+ * Callback to set the value of a dapm mixer control.
+ *
+ * Returns 0 for success.
+ */
+int snd_soc_dapm_put_volsw(struct snd_kcontrol *kcontrol,
+	struct snd_ctl_elem_value *ucontrol)
+{
+	struct snd_soc_dapm_context *dapm = snd_soc_dapm_kcontrol_dapm(kcontrol);
+	struct snd_soc_card *card = dapm->card;
+	struct soc_mixer_control *mc =
+		(struct soc_mixer_control *)kcontrol->private_value;
+	int reg = mc->reg;
+	unsigned int shift = mc->shift;
+	int max = mc->max;
+	unsigned int mask = (1 << fls(max)) - 1;
+	unsigned int invert = mc->invert;
+	unsigned int val;
+	int connect, change, reg_change = 0;
+	struct snd_soc_dapm_update update;
+	int ret = 0;
+
+	if (snd_soc_volsw_is_stereo(mc))
+		dev_warn(dapm->dev,
+			 "ASoC: Control '%s' is stereo, which is not supported\n",
+			 kcontrol->id.name);
+
+	val = (ucontrol->value.integer.value[0] & mask);
+	connect = !!val;
+
+	if (invert)
+		val = max - val;
+
+	mutex_lock_nested(&card->dapm_mutex, SND_SOC_DAPM_CLASS_RUNTIME);
+
+	change = dapm_kcontrol_set_value(kcontrol, val);
+
+	if (reg != SND_SOC_NOPM) {
+		mask = mask << shift;
+		val = val << shift;
+
+		reg_change = soc_dapm_test_bits(dapm, reg, mask, val);
+	}
+
+	if (change || reg_change) {
+		if (reg_change) {
+			update.kcontrol = kcontrol;
+			update.reg = reg;
+			update.mask = mask;
+			update.val = val;
+			card->update = &update;
+		}
+		change |= reg_change;
+
+		ret = soc_dapm_mixer_update_power(card, kcontrol, connect);
+
+		card->update = NULL;
+	}
+
+	mutex_unlock(&card->dapm_mutex);
+
+	if (ret > 0)
+		soc_dpcm_runtime_update(card);
+
+	return change;
+}
+EXPORT_SYMBOL_GPL(snd_soc_dapm_put_volsw);
+
+/**
+ * snd_soc_dapm_get_enum_double - dapm enumerated double mixer get callback
+ * @kcontrol: mixer control
+ * @ucontrol: control element information
+ *
+ * Callback to get the value of a dapm enumerated double mixer control.
+ *
+ * Returns 0 for success.
+ */
+int snd_soc_dapm_get_enum_double(struct snd_kcontrol *kcontrol,
+	struct snd_ctl_elem_value *ucontrol)
+{
+	struct snd_soc_dapm_context *dapm = snd_soc_dapm_kcontrol_dapm(kcontrol);
+	struct soc_enum *e = (struct soc_enum *)kcontrol->private_value;
+	unsigned int reg_val, val;
+
+	if (e->reg != SND_SOC_NOPM) {
+		int ret = soc_dapm_read(dapm, e->reg, &reg_val);
+		if (ret)
+			return ret;
+	} else {
+		reg_val = dapm_kcontrol_get_value(kcontrol);
+	}
+
+	val = (reg_val >> e->shift_l) & e->mask;
+	ucontrol->value.enumerated.item[0] = snd_soc_enum_val_to_item(e, val);
+	if (e->shift_l != e->shift_r) {
+		val = (reg_val >> e->shift_r) & e->mask;
+		val = snd_soc_enum_val_to_item(e, val);
+		ucontrol->value.enumerated.item[1] = val;
+	}
+
+	return 0;
+}
+EXPORT_SYMBOL_GPL(snd_soc_dapm_get_enum_double);
+
+/**
+ * snd_soc_dapm_put_enum_double - dapm enumerated double mixer set callback
+ * @kcontrol: mixer control
+ * @ucontrol: control element information
+ *
+ * Callback to set the value of a dapm enumerated double mixer control.
+ *
+ * Returns 0 for success.
+ */
+int snd_soc_dapm_put_enum_double(struct snd_kcontrol *kcontrol,
+	struct snd_ctl_elem_value *ucontrol)
+{
+	struct snd_soc_dapm_context *dapm = snd_soc_dapm_kcontrol_dapm(kcontrol);
+	struct snd_soc_card *card = dapm->card;
+	struct soc_enum *e = (struct soc_enum *)kcontrol->private_value;
+	unsigned int *item = ucontrol->value.enumerated.item;
+	unsigned int val, change;
+	unsigned int mask;
+	struct snd_soc_dapm_update update;
+	int ret = 0;
+
+	if (item[0] >= e->items)
+		return -EINVAL;
+
+	val = snd_soc_enum_item_to_val(e, item[0]) << e->shift_l;
+	mask = e->mask << e->shift_l;
+	if (e->shift_l != e->shift_r) {
+		if (item[1] > e->items)
+			return -EINVAL;
+		val |= snd_soc_enum_item_to_val(e, item[1]) << e->shift_l;
+		mask |= e->mask << e->shift_r;
+	}
+
+	mutex_lock_nested(&card->dapm_mutex, SND_SOC_DAPM_CLASS_RUNTIME);
+
+	if (e->reg != SND_SOC_NOPM)
+		change = soc_dapm_test_bits(dapm, e->reg, mask, val);
+	else
+		change = dapm_kcontrol_set_value(kcontrol, val);
+
+	if (change) {
+		if (e->reg != SND_SOC_NOPM) {
+			update.kcontrol = kcontrol;
+			update.reg = e->reg;
+			update.mask = mask;
+			update.val = val;
+			card->update = &update;
+		}
+
+		ret = soc_dapm_mux_update_power(card, kcontrol, item[0], e);
+
+		card->update = NULL;
+	}
+
+	mutex_unlock(&card->dapm_mutex);
+
+	if (ret > 0)
+		soc_dpcm_runtime_update(card);
+
+	return change;
+}
+EXPORT_SYMBOL_GPL(snd_soc_dapm_put_enum_double);
+
+/**
+ * snd_soc_dapm_info_pin_switch - Info for a pin switch
+ *
+ * @kcontrol: mixer control
+ * @uinfo: control element information
+ *
+ * Callback to provide information about a pin switch control.
+ */
+int snd_soc_dapm_info_pin_switch(struct snd_kcontrol *kcontrol,
+				 struct snd_ctl_elem_info *uinfo)
+{
+	uinfo->type = SNDRV_CTL_ELEM_TYPE_BOOLEAN;
+	uinfo->count = 1;
+	uinfo->value.integer.min = 0;
+	uinfo->value.integer.max = 1;
+
+	return 0;
+}
+EXPORT_SYMBOL_GPL(snd_soc_dapm_info_pin_switch);
+
+/**
+ * snd_soc_dapm_get_pin_switch - Get information for a pin switch
+ *
+ * @kcontrol: mixer control
+ * @ucontrol: Value
+ */
+int snd_soc_dapm_get_pin_switch(struct snd_kcontrol *kcontrol,
+				struct snd_ctl_elem_value *ucontrol)
+{
+	struct snd_soc_card *card = snd_kcontrol_chip(kcontrol);
+	const char *pin = (const char *)kcontrol->private_value;
+
+	mutex_lock_nested(&card->dapm_mutex, SND_SOC_DAPM_CLASS_RUNTIME);
+
+	ucontrol->value.integer.value[0] =
+		snd_soc_dapm_get_pin_status(&card->dapm, pin);
+
+	mutex_unlock(&card->dapm_mutex);
+
+	return 0;
+}
+EXPORT_SYMBOL_GPL(snd_soc_dapm_get_pin_switch);
+
+/**
+ * snd_soc_dapm_put_pin_switch - Set information for a pin switch
+ *
+ * @kcontrol: mixer control
+ * @ucontrol: Value
+ */
+int snd_soc_dapm_put_pin_switch(struct snd_kcontrol *kcontrol,
+				struct snd_ctl_elem_value *ucontrol)
+{
+	struct snd_soc_card *card = snd_kcontrol_chip(kcontrol);
+	const char *pin = (const char *)kcontrol->private_value;
+
+	if (ucontrol->value.integer.value[0])
+		snd_soc_dapm_enable_pin(&card->dapm, pin);
+	else
+		snd_soc_dapm_disable_pin(&card->dapm, pin);
+
+	snd_soc_dapm_sync(&card->dapm);
+	return 0;
+}
+EXPORT_SYMBOL_GPL(snd_soc_dapm_put_pin_switch);
+
+static struct snd_soc_dapm_widget *
+snd_soc_dapm_new_control(struct snd_soc_dapm_context *dapm,
+			 const struct snd_soc_dapm_widget *widget)
+{
+	struct snd_soc_dapm_widget *w;
+	const char *prefix;
+	int ret;
+
+	if ((w = dapm_cnew_widget(widget)) == NULL)
+		return NULL;
+
+	switch (w->id) {
+	case snd_soc_dapm_regulator_supply:
+		w->regulator = devm_regulator_get(dapm->dev, w->name);
+		if (IS_ERR(w->regulator)) {
+			ret = PTR_ERR(w->regulator);
+			dev_err(dapm->dev, "ASoC: Failed to request %s: %d\n",
+				w->name, ret);
+			return NULL;
+		}
+
+		if (w->on_val & SND_SOC_DAPM_REGULATOR_BYPASS) {
+			ret = regulator_allow_bypass(w->regulator, true);
+			if (ret != 0)
+				dev_warn(w->dapm->dev,
+					 "ASoC: Failed to bypass %s: %d\n",
+					 w->name, ret);
+		}
+		break;
+	case snd_soc_dapm_clock_supply:
+#ifdef CONFIG_CLKDEV_LOOKUP
+		w->clk = devm_clk_get(dapm->dev, w->name);
+		if (IS_ERR(w->clk)) {
+			ret = PTR_ERR(w->clk);
+			dev_err(dapm->dev, "ASoC: Failed to request %s: %d\n",
+				w->name, ret);
+			return NULL;
+		}
+#else
+		return NULL;
+#endif
+		break;
+	default:
+		break;
+	}
+
+	prefix = soc_dapm_prefix(dapm);
+	if (prefix)
+		w->name = kasprintf(GFP_KERNEL, "%s %s", prefix, widget->name);
+	else
+		w->name = kasprintf(GFP_KERNEL, "%s", widget->name);
+
+	if (w->name == NULL) {
+		kfree(w);
+		return NULL;
+	}
+
+	switch (w->id) {
+	case snd_soc_dapm_switch:
+	case snd_soc_dapm_mixer:
+	case snd_soc_dapm_mixer_named_ctl:
+		w->power_check = dapm_generic_check_power;
+		break;
+	case snd_soc_dapm_mux:
+		w->power_check = dapm_generic_check_power;
+		break;
+	case snd_soc_dapm_dai_out:
+		w->power_check = dapm_adc_check_power;
+		break;
+	case snd_soc_dapm_dai_in:
+		w->power_check = dapm_dac_check_power;
+		break;
+	case snd_soc_dapm_adc:
+	case snd_soc_dapm_aif_out:
+	case snd_soc_dapm_dac:
+	case snd_soc_dapm_aif_in:
+	case snd_soc_dapm_pga:
+	case snd_soc_dapm_out_drv:
+	case snd_soc_dapm_input:
+	case snd_soc_dapm_output:
+	case snd_soc_dapm_micbias:
+	case snd_soc_dapm_spk:
+	case snd_soc_dapm_hp:
+	case snd_soc_dapm_mic:
+	case snd_soc_dapm_line:
+	case snd_soc_dapm_dai_link:
+		w->power_check = dapm_generic_check_power;
+		break;
+	case snd_soc_dapm_supply:
+	case snd_soc_dapm_regulator_supply:
+	case snd_soc_dapm_clock_supply:
+	case snd_soc_dapm_kcontrol:
+		w->power_check = dapm_supply_check_power;
+		break;
+	default:
+		w->power_check = dapm_always_on_check_power;
+		break;
+	}
+
+	w->dapm = dapm;
+	INIT_LIST_HEAD(&w->sources);
+	INIT_LIST_HEAD(&w->sinks);
+	INIT_LIST_HEAD(&w->list);
+	INIT_LIST_HEAD(&w->dirty);
+	list_add(&w->list, &dapm->card->widgets);
+
+	w->inputs = -1;
+	w->outputs = -1;
+
+	/* machine layer set ups unconnected pins and insertions */
+	w->connected = 1;
+	return w;
+}
+
+/**
+ * snd_soc_dapm_new_controls - create new dapm controls
+ * @dapm: DAPM context
+ * @widget: widget array
+ * @num: number of widgets
+ *
+ * Creates new DAPM controls based upon the templates.
+ *
+ * Returns 0 for success else error.
+ */
+int snd_soc_dapm_new_controls(struct snd_soc_dapm_context *dapm,
+	const struct snd_soc_dapm_widget *widget,
+	int num)
+{
+	struct snd_soc_dapm_widget *w;
+	int i;
+	int ret = 0;
+
+	mutex_lock_nested(&dapm->card->dapm_mutex, SND_SOC_DAPM_CLASS_INIT);
+	for (i = 0; i < num; i++) {
+		w = snd_soc_dapm_new_control(dapm, widget);
+		if (!w) {
+			dev_err(dapm->dev,
+				"ASoC: Failed to create DAPM control %s\n",
+				widget->name);
+			ret = -ENOMEM;
+			break;
+		}
+		widget++;
+	}
+	mutex_unlock(&dapm->card->dapm_mutex);
+	return ret;
+}
+EXPORT_SYMBOL_GPL(snd_soc_dapm_new_controls);
+
+static int snd_soc_dai_link_event(struct snd_soc_dapm_widget *w,
+				  struct snd_kcontrol *kcontrol, int event)
+{
+	struct snd_soc_dapm_path *source_p, *sink_p;
+	struct snd_soc_dai *source, *sink;
+	const struct snd_soc_pcm_stream *config = w->params + w->params_select;
+	struct snd_pcm_substream substream;
+	struct snd_pcm_hw_params *params = NULL;
+	u64 fmt;
+	int ret;
+
+	if (WARN_ON(!config) ||
+	    WARN_ON(list_empty(&w->sources) || list_empty(&w->sinks)))
+		return -EINVAL;
+
+	/* We only support a single source and sink, pick the first */
+	source_p = list_first_entry(&w->sources, struct snd_soc_dapm_path,
+				    list_sink);
+	sink_p = list_first_entry(&w->sinks, struct snd_soc_dapm_path,
+				  list_source);
+
+	if (WARN_ON(!source_p || !sink_p) ||
+	    WARN_ON(!sink_p->source || !source_p->sink) ||
+	    WARN_ON(!source_p->source || !sink_p->sink))
+		return -EINVAL;
+
+	source = source_p->source->priv;
+	sink = sink_p->sink->priv;
+
+	/* Be a little careful as we don't want to overflow the mask array */
+	if (config->formats) {
+		fmt = ffs(config->formats) - 1;
+	} else {
+		dev_warn(w->dapm->dev, "ASoC: Invalid format %llx specified\n",
+			 config->formats);
+		fmt = 0;
+	}
+
+	/* Currently very limited parameter selection */
+	params = kzalloc(sizeof(*params), GFP_KERNEL);
+	if (!params) {
+		ret = -ENOMEM;
+		goto out;
+	}
+	snd_mask_set(hw_param_mask(params, SNDRV_PCM_HW_PARAM_FORMAT), fmt);
+
+	hw_param_interval(params, SNDRV_PCM_HW_PARAM_RATE)->min =
+		config->rate_min;
+	hw_param_interval(params, SNDRV_PCM_HW_PARAM_RATE)->max =
+		config->rate_max;
+
+	hw_param_interval(params, SNDRV_PCM_HW_PARAM_CHANNELS)->min
+		= config->channels_min;
+	hw_param_interval(params, SNDRV_PCM_HW_PARAM_CHANNELS)->max
+		= config->channels_max;
+
+	memset(&substream, 0, sizeof(substream));
+
+	switch (event) {
+	case SND_SOC_DAPM_PRE_PMU:
+		substream.stream = SNDRV_PCM_STREAM_CAPTURE;
+		ret = soc_dai_hw_params(&substream, params, source);
+		if (ret < 0)
+			goto out;
+
+		substream.stream = SNDRV_PCM_STREAM_PLAYBACK;
+		ret = soc_dai_hw_params(&substream, params, sink);
+		if (ret < 0)
+			goto out;
+		break;
+
+	case SND_SOC_DAPM_POST_PMU:
+		ret = snd_soc_dai_digital_mute(sink, 0,
+					       SNDRV_PCM_STREAM_PLAYBACK);
+		if (ret != 0 && ret != -ENOTSUPP)
+			dev_warn(sink->dev, "ASoC: Failed to unmute: %d\n", ret);
+		ret = 0;
+		break;
+
+	case SND_SOC_DAPM_PRE_PMD:
+		ret = snd_soc_dai_digital_mute(sink, 1,
+					       SNDRV_PCM_STREAM_PLAYBACK);
+		if (ret != 0 && ret != -ENOTSUPP)
+			dev_warn(sink->dev, "ASoC: Failed to mute: %d\n", ret);
+		ret = 0;
+		break;
+
+	default:
+		WARN(1, "Unknown event %d\n", event);
+		return -EINVAL;
+	}
+
+out:
+	kfree(params);
+	return ret;
+}
+
+static int snd_soc_dapm_dai_link_get(struct snd_kcontrol *kcontrol,
+			  struct snd_ctl_elem_value *ucontrol)
+{
+	struct snd_soc_dapm_widget *w = snd_kcontrol_chip(kcontrol);
+
+	ucontrol->value.integer.value[0] = w->params_select;
+
+	return 0;
+}
+
+static int snd_soc_dapm_dai_link_put(struct snd_kcontrol *kcontrol,
+			  struct snd_ctl_elem_value *ucontrol)
+{
+	struct snd_soc_dapm_widget *w = snd_kcontrol_chip(kcontrol);
+
+	/* Can't change the config when widget is already powered */
+	if (w->power)
+		return -EBUSY;
+
+	if (ucontrol->value.integer.value[0] == w->params_select)
+		return 0;
+
+	if (ucontrol->value.integer.value[0] >= w->num_params)
+		return -EINVAL;
+
+	w->params_select = ucontrol->value.integer.value[0];
+
+	return 0;
+}
+
+int snd_soc_dapm_new_pcm(struct snd_soc_card *card,
+			 const struct snd_soc_pcm_stream *params,
+			 unsigned int num_params,
+			 struct snd_soc_dapm_widget *source,
+			 struct snd_soc_dapm_widget *sink)
+{
+	struct snd_soc_dapm_widget template;
+	struct snd_soc_dapm_widget *w;
+	char *link_name;
+	int ret, count;
+	unsigned long private_value;
+	const char **w_param_text;
+	struct soc_enum w_param_enum[] = {
+		SOC_ENUM_SINGLE(0, 0, 0, NULL),
+	};
+	struct snd_kcontrol_new kcontrol_dai_link[] = {
+		SOC_ENUM_EXT(NULL, w_param_enum[0],
+			     snd_soc_dapm_dai_link_get,
+			     snd_soc_dapm_dai_link_put),
+	};
+	const struct snd_soc_pcm_stream *config = params;
+
+	w_param_text = devm_kcalloc(card->dev, num_params,
+					sizeof(char *), GFP_KERNEL);
+	if (!w_param_text)
+		return -ENOMEM;
+
+	link_name = devm_kasprintf(card->dev, GFP_KERNEL, "%s-%s",
+				   source->name, sink->name);
+	if (!link_name) {
+		ret = -ENOMEM;
+		goto outfree_w_param;
+	}
+
+	for (count = 0 ; count < num_params; count++) {
+		if (!config->stream_name) {
+			dev_warn(card->dapm.dev,
+				"ASoC: anonymous config %d for dai link %s\n",
+				count, link_name);
+			w_param_text[count] =
+				devm_kasprintf(card->dev, GFP_KERNEL,
+					       "Anonymous Configuration %d",
+					       count);
+			if (!w_param_text[count]) {
+				ret = -ENOMEM;
+				goto outfree_link_name;
+			}
+		} else {
+			w_param_text[count] = devm_kmemdup(card->dev,
+						config->stream_name,
+						strlen(config->stream_name) + 1,
+						GFP_KERNEL);
+			if (!w_param_text[count]) {
+				ret = -ENOMEM;
+				goto outfree_link_name;
+			}
+		}
+		config++;
+	}
+	w_param_enum[0].items = num_params;
+	w_param_enum[0].texts = w_param_text;
+
+	memset(&template, 0, sizeof(template));
+	template.reg = SND_SOC_NOPM;
+	template.id = snd_soc_dapm_dai_link;
+	template.name = link_name;
+	template.event = snd_soc_dai_link_event;
+	template.event_flags = SND_SOC_DAPM_PRE_PMU | SND_SOC_DAPM_POST_PMU |
+		SND_SOC_DAPM_PRE_PMD;
+	template.num_kcontrols = 1;
+	/* duplicate w_param_enum on heap so that memory persists */
+	private_value =
+		(unsigned long) devm_kmemdup(card->dev,
+			(void *)(kcontrol_dai_link[0].private_value),
+			sizeof(struct soc_enum), GFP_KERNEL);
+	if (!private_value) {
+		dev_err(card->dev, "ASoC: Failed to create control for %s widget\n",
+			link_name);
+		ret = -ENOMEM;
+		goto outfree_link_name;
+	}
+	kcontrol_dai_link[0].private_value = private_value;
+	/* duplicate kcontrol_dai_link on heap so that memory persists */
+	template.kcontrol_news =
+				devm_kmemdup(card->dev, &kcontrol_dai_link[0],
+					sizeof(struct snd_kcontrol_new),
+					GFP_KERNEL);
+	if (!template.kcontrol_news) {
+		dev_err(card->dev, "ASoC: Failed to create control for %s widget\n",
+			link_name);
+		ret = -ENOMEM;
+		goto outfree_private_value;
+	}
+
+	dev_dbg(card->dev, "ASoC: adding %s widget\n", link_name);
+
+	w = snd_soc_dapm_new_control(&card->dapm, &template);
+	if (!w) {
+		dev_err(card->dev, "ASoC: Failed to create %s widget\n",
+			link_name);
+		ret = -ENOMEM;
+		goto outfree_kcontrol_news;
+	}
+
+	w->params = params;
+	w->num_params = num_params;
+
+	ret = snd_soc_dapm_add_path(&card->dapm, source, w, NULL, NULL);
+	if (ret)
+		goto outfree_w;
+	return snd_soc_dapm_add_path(&card->dapm, w, sink, NULL, NULL);
+
+outfree_w:
+	devm_kfree(card->dev, w);
+outfree_kcontrol_news:
+	devm_kfree(card->dev, (void *)template.kcontrol_news);
+outfree_private_value:
+	devm_kfree(card->dev, (void *)private_value);
+outfree_link_name:
+	devm_kfree(card->dev, link_name);
+outfree_w_param:
+	for (count = 0 ; count < num_params; count++)
+		devm_kfree(card->dev, (void *)w_param_text[count]);
+	devm_kfree(card->dev, w_param_text);
+
+	return ret;
+}
+
+int snd_soc_dapm_new_dai_widgets(struct snd_soc_dapm_context *dapm,
+				 struct snd_soc_dai *dai)
+{
+	struct snd_soc_dapm_widget template;
+	struct snd_soc_dapm_widget *w;
+
+	WARN_ON(dapm->dev != dai->dev);
+
+	memset(&template, 0, sizeof(template));
+	template.reg = SND_SOC_NOPM;
+
+	if (dai->driver->playback.stream_name) {
+		template.id = snd_soc_dapm_dai_in;
+		template.name = dai->driver->playback.stream_name;
+		template.sname = dai->driver->playback.stream_name;
+
+		dev_dbg(dai->dev, "ASoC: adding %s widget\n",
+			template.name);
+
+		w = snd_soc_dapm_new_control(dapm, &template);
+		if (!w) {
+			dev_err(dapm->dev, "ASoC: Failed to create %s widget\n",
+				dai->driver->playback.stream_name);
+			return -ENOMEM;
+		}
+
+		w->priv = dai;
+		dai->playback_widget = w;
+	}
+
+	if (dai->driver->capture.stream_name) {
+		template.id = snd_soc_dapm_dai_out;
+		template.name = dai->driver->capture.stream_name;
+		template.sname = dai->driver->capture.stream_name;
+
+		dev_dbg(dai->dev, "ASoC: adding %s widget\n",
+			template.name);
+
+		w = snd_soc_dapm_new_control(dapm, &template);
+		if (!w) {
+			dev_err(dapm->dev, "ASoC: Failed to create %s widget\n",
+				dai->driver->capture.stream_name);
+			return -ENOMEM;
+		}
+
+		w->priv = dai;
+		dai->capture_widget = w;
+	}
+
+	return 0;
+}
+
+int snd_soc_dapm_link_dai_widgets(struct snd_soc_card *card)
+{
+	struct snd_soc_dapm_widget *dai_w, *w;
+	struct snd_soc_dapm_widget *src, *sink;
+	struct snd_soc_dai *dai;
+
+	/* For each DAI widget... */
+	list_for_each_entry(dai_w, &card->widgets, list) {
+		switch (dai_w->id) {
+		case snd_soc_dapm_dai_in:
+		case snd_soc_dapm_dai_out:
+			break;
+		default:
+			continue;
+		}
+
+		dai = dai_w->priv;
+
+		/* ...find all widgets with the same stream and link them */
+		list_for_each_entry(w, &card->widgets, list) {
+			if (w->dapm != dai_w->dapm)
+				continue;
+
+			switch (w->id) {
+			case snd_soc_dapm_dai_in:
+			case snd_soc_dapm_dai_out:
+				continue;
+			default:
+				break;
+			}
+
+			if (!w->sname || !strstr(dai_w->name, w->sname))
+				continue;
+
+			if (dai_w->id == snd_soc_dapm_dai_in) {
+				src = dai_w;
+				sink = w;
+			} else {
+				src = w;
+				sink = dai_w;
+			}
+			dev_dbg(dai->dev, "%s -> %s\n", src->name, sink->name);
+			snd_soc_dapm_add_path(w->dapm, src, sink, NULL, NULL);
+		}
+	}
+
+	return 0;
+}
+
+static void dapm_connect_dai_link_widgets(struct snd_soc_card *card,
+					  struct snd_soc_pcm_runtime *rtd)
+{
+	struct snd_soc_dai *cpu_dai = rtd->cpu_dai;
+	struct snd_soc_dapm_widget *sink, *source;
+	int i;
+
+	for (i = 0; i < rtd->num_codecs; i++) {
+		struct snd_soc_dai *codec_dai = rtd->codec_dais[i];
+
+		/* there is no point in connecting BE DAI links with dummies */
+		if (snd_soc_dai_is_dummy(codec_dai) ||
+			snd_soc_dai_is_dummy(cpu_dai))
+			continue;
+
+		/* connect BE DAI playback if widgets are valid */
+		if (codec_dai->playback_widget && cpu_dai->playback_widget) {
+			source = cpu_dai->playback_widget;
+			sink = codec_dai->playback_widget;
+			dev_dbg(rtd->dev, "connected DAI link %s:%s -> %s:%s\n",
+				cpu_dai->component->name, source->name,
+				codec_dai->component->name, sink->name);
+
+			snd_soc_dapm_add_path(&card->dapm, source, sink,
+				NULL, NULL);
+		}
+
+		/* connect BE DAI capture if widgets are valid */
+		if (codec_dai->capture_widget && cpu_dai->capture_widget) {
+			source = codec_dai->capture_widget;
+			sink = cpu_dai->capture_widget;
+			dev_dbg(rtd->dev, "connected DAI link %s:%s -> %s:%s\n",
+				codec_dai->component->name, source->name,
+				cpu_dai->component->name, sink->name);
+
+			snd_soc_dapm_add_path(&card->dapm, source, sink,
+				NULL, NULL);
+		}
+	}
+}
+
+static void soc_dapm_dai_stream_event(struct snd_soc_dai *dai, int stream,
+	int event)
+{
+	struct snd_soc_dapm_widget *w;
+
+	if (stream == SNDRV_PCM_STREAM_PLAYBACK)
+		w = dai->playback_widget;
+	else
+		w = dai->capture_widget;
+
+	if (w) {
+		dapm_mark_dirty(w, "stream event");
+
+		switch (event) {
+		case SND_SOC_DAPM_STREAM_START:
+			w->active = 1;
+			break;
+		case SND_SOC_DAPM_STREAM_STOP:
+			w->active = 0;
+			break;
+		case SND_SOC_DAPM_STREAM_SUSPEND:
+		case SND_SOC_DAPM_STREAM_RESUME:
+		case SND_SOC_DAPM_STREAM_PAUSE_PUSH:
+		case SND_SOC_DAPM_STREAM_PAUSE_RELEASE:
+			break;
+		}
+
+		if (w->id == snd_soc_dapm_dai_in) {
+			w->is_source = w->active;
+			dapm_widget_invalidate_input_paths(w);
+		} else {
+			w->is_sink = w->active;
+			dapm_widget_invalidate_output_paths(w);
+		}
+	}
+}
+
+void snd_soc_dapm_connect_dai_link_widgets(struct snd_soc_card *card)
+{
+	struct snd_soc_pcm_runtime *rtd = card->rtd;
+	int i;
+
+	/* for each BE DAI link... */
+	for (i = 0; i < card->num_rtd; i++) {
+		rtd = &card->rtd[i];
+
+		/*
+		 * dynamic FE links have no fixed DAI mapping.
+		 * CODEC<->CODEC links have no direct connection.
+		 */
+		if (rtd->dai_link->dynamic || rtd->dai_link->params)
+			continue;
+
+		dapm_connect_dai_link_widgets(card, rtd);
+	}
+}
+
+static void soc_dapm_stream_event(struct snd_soc_pcm_runtime *rtd, int stream,
+	int event)
+{
+	int i;
+
+	soc_dapm_dai_stream_event(rtd->cpu_dai, stream, event);
+	for (i = 0; i < rtd->num_codecs; i++)
+		soc_dapm_dai_stream_event(rtd->codec_dais[i], stream, event);
+
+	dapm_power_widgets(rtd->card, event);
+}
+
+/**
+ * snd_soc_dapm_stream_event - send a stream event to the dapm core
+ * @rtd: PCM runtime data
+ * @stream: stream name
+ * @event: stream event
+ *
+ * Sends a stream event to the dapm core. The core then makes any
+ * necessary widget power changes.
+ *
+ * Returns 0 for success else error.
+ */
+void snd_soc_dapm_stream_event(struct snd_soc_pcm_runtime *rtd, int stream,
+			      int event)
+{
+	struct snd_soc_card *card = rtd->card;
+
+	mutex_lock_nested(&card->dapm_mutex, SND_SOC_DAPM_CLASS_RUNTIME);
+	soc_dapm_stream_event(rtd, stream, event);
+	mutex_unlock(&card->dapm_mutex);
+}
+
+/**
+ * snd_soc_dapm_enable_pin_unlocked - enable pin.
+ * @dapm: DAPM context
+ * @pin: pin name
+ *
+ * Enables input/output pin and its parents or children widgets iff there is
+ * a valid audio route and active audio stream.
+ *
+ * Requires external locking.
+ *
+ * NOTE: snd_soc_dapm_sync() needs to be called after this for DAPM to
+ * do any widget power switching.
+ */
+int snd_soc_dapm_enable_pin_unlocked(struct snd_soc_dapm_context *dapm,
+				   const char *pin)
+{
+	return snd_soc_dapm_set_pin(dapm, pin, 1);
+}
+EXPORT_SYMBOL_GPL(snd_soc_dapm_enable_pin_unlocked);
+
+/**
+ * snd_soc_dapm_enable_pin - enable pin.
+ * @dapm: DAPM context
+ * @pin: pin name
+ *
+ * Enables input/output pin and its parents or children widgets iff there is
+ * a valid audio route and active audio stream.
+ *
+ * NOTE: snd_soc_dapm_sync() needs to be called after this for DAPM to
+ * do any widget power switching.
+ */
+int snd_soc_dapm_enable_pin(struct snd_soc_dapm_context *dapm, const char *pin)
+{
+	int ret;
+
+	mutex_lock_nested(&dapm->card->dapm_mutex, SND_SOC_DAPM_CLASS_RUNTIME);
+
+	ret = snd_soc_dapm_set_pin(dapm, pin, 1);
+
+	mutex_unlock(&dapm->card->dapm_mutex);
+
+	return ret;
+}
+EXPORT_SYMBOL_GPL(snd_soc_dapm_enable_pin);
+
+/**
+ * snd_soc_dapm_force_enable_pin_unlocked - force a pin to be enabled
+ * @dapm: DAPM context
+ * @pin: pin name
+ *
+ * Enables input/output pin regardless of any other state.  This is
+ * intended for use with microphone bias supplies used in microphone
+ * jack detection.
+ *
+ * Requires external locking.
+ *
+ * NOTE: snd_soc_dapm_sync() needs to be called after this for DAPM to
+ * do any widget power switching.
+ */
+int snd_soc_dapm_force_enable_pin_unlocked(struct snd_soc_dapm_context *dapm,
+					 const char *pin)
+{
+	struct snd_soc_dapm_widget *w = dapm_find_widget(dapm, pin, true);
+
+	if (!w) {
+		dev_err(dapm->dev, "ASoC: unknown pin %s\n", pin);
+		return -EINVAL;
+	}
+
+	dev_dbg(w->dapm->dev, "ASoC: force enable pin %s\n", pin);
+	if (!w->connected) {
+		/*
+		 * w->force does not affect the number of input or output paths,
+		 * so we only have to recheck if w->connected is changed
+		 */
+		dapm_widget_invalidate_input_paths(w);
+		dapm_widget_invalidate_output_paths(w);
+		w->connected = 1;
+	}
+	w->force = 1;
+	dapm_mark_dirty(w, "force enable");
+
+	return 0;
+}
+EXPORT_SYMBOL_GPL(snd_soc_dapm_force_enable_pin_unlocked);
+
+/**
+ * snd_soc_dapm_force_enable_pin - force a pin to be enabled
+ * @dapm: DAPM context
+ * @pin: pin name
+ *
+ * Enables input/output pin regardless of any other state.  This is
+ * intended for use with microphone bias supplies used in microphone
+ * jack detection.
+ *
+ * NOTE: snd_soc_dapm_sync() needs to be called after this for DAPM to
+ * do any widget power switching.
+ */
+int snd_soc_dapm_force_enable_pin(struct snd_soc_dapm_context *dapm,
+				  const char *pin)
+{
+	int ret;
+
+	mutex_lock_nested(&dapm->card->dapm_mutex, SND_SOC_DAPM_CLASS_RUNTIME);
+
+	ret = snd_soc_dapm_force_enable_pin_unlocked(dapm, pin);
+
+	mutex_unlock(&dapm->card->dapm_mutex);
+
+	return ret;
+}
+EXPORT_SYMBOL_GPL(snd_soc_dapm_force_enable_pin);
+
+/**
+ * snd_soc_dapm_disable_pin_unlocked - disable pin.
+ * @dapm: DAPM context
+ * @pin: pin name
+ *
+ * Disables input/output pin and its parents or children widgets.
+ *
+ * Requires external locking.
+ *
+ * NOTE: snd_soc_dapm_sync() needs to be called after this for DAPM to
+ * do any widget power switching.
+ */
+int snd_soc_dapm_disable_pin_unlocked(struct snd_soc_dapm_context *dapm,
+				    const char *pin)
+{
+	return snd_soc_dapm_set_pin(dapm, pin, 0);
+}
+EXPORT_SYMBOL_GPL(snd_soc_dapm_disable_pin_unlocked);
+
+/**
+ * snd_soc_dapm_disable_pin - disable pin.
+ * @dapm: DAPM context
+ * @pin: pin name
+ *
+ * Disables input/output pin and its parents or children widgets.
+ *
+ * NOTE: snd_soc_dapm_sync() needs to be called after this for DAPM to
+ * do any widget power switching.
+ */
+int snd_soc_dapm_disable_pin(struct snd_soc_dapm_context *dapm,
+			     const char *pin)
+{
+	int ret;
+
+	mutex_lock_nested(&dapm->card->dapm_mutex, SND_SOC_DAPM_CLASS_RUNTIME);
+
+	ret = snd_soc_dapm_set_pin(dapm, pin, 0);
+
+	mutex_unlock(&dapm->card->dapm_mutex);
+
+	return ret;
+}
+EXPORT_SYMBOL_GPL(snd_soc_dapm_disable_pin);
+
+/**
+ * snd_soc_dapm_nc_pin_unlocked - permanently disable pin.
+ * @dapm: DAPM context
+ * @pin: pin name
+ *
+ * Marks the specified pin as being not connected, disabling it along
+ * any parent or child widgets.  At present this is identical to
+ * snd_soc_dapm_disable_pin() but in future it will be extended to do
+ * additional things such as disabling controls which only affect
+ * paths through the pin.
+ *
+ * Requires external locking.
+ *
+ * NOTE: snd_soc_dapm_sync() needs to be called after this for DAPM to
+ * do any widget power switching.
+ */
+int snd_soc_dapm_nc_pin_unlocked(struct snd_soc_dapm_context *dapm,
+			       const char *pin)
+{
+	return snd_soc_dapm_set_pin(dapm, pin, 0);
+}
+EXPORT_SYMBOL_GPL(snd_soc_dapm_nc_pin_unlocked);
+
+/**
+ * snd_soc_dapm_nc_pin - permanently disable pin.
+ * @dapm: DAPM context
+ * @pin: pin name
+ *
+ * Marks the specified pin as being not connected, disabling it along
+ * any parent or child widgets.  At present this is identical to
+ * snd_soc_dapm_disable_pin() but in future it will be extended to do
+ * additional things such as disabling controls which only affect
+ * paths through the pin.
+ *
+ * NOTE: snd_soc_dapm_sync() needs to be called after this for DAPM to
+ * do any widget power switching.
+ */
+int snd_soc_dapm_nc_pin(struct snd_soc_dapm_context *dapm, const char *pin)
+{
+	int ret;
+
+	mutex_lock_nested(&dapm->card->dapm_mutex, SND_SOC_DAPM_CLASS_RUNTIME);
+
+	ret = snd_soc_dapm_set_pin(dapm, pin, 0);
+
+	mutex_unlock(&dapm->card->dapm_mutex);
+
+	return ret;
+}
+EXPORT_SYMBOL_GPL(snd_soc_dapm_nc_pin);
+
+/**
+ * snd_soc_dapm_get_pin_status - get audio pin status
+ * @dapm: DAPM context
+ * @pin: audio signal pin endpoint (or start point)
+ *
+ * Get audio pin status - connected or disconnected.
+ *
+ * Returns 1 for connected otherwise 0.
+ */
+int snd_soc_dapm_get_pin_status(struct snd_soc_dapm_context *dapm,
+				const char *pin)
+{
+	struct snd_soc_dapm_widget *w = dapm_find_widget(dapm, pin, true);
+
+	if (w)
+		return w->connected;
+
+	return 0;
+}
+EXPORT_SYMBOL_GPL(snd_soc_dapm_get_pin_status);
+
+/**
+ * snd_soc_dapm_ignore_suspend - ignore suspend status for DAPM endpoint
+ * @dapm: DAPM context
+ * @pin: audio signal pin endpoint (or start point)
+ *
+ * Mark the given endpoint or pin as ignoring suspend.  When the
+ * system is disabled a path between two endpoints flagged as ignoring
+ * suspend will not be disabled.  The path must already be enabled via
+ * normal means at suspend time, it will not be turned on if it was not
+ * already enabled.
+ */
+int snd_soc_dapm_ignore_suspend(struct snd_soc_dapm_context *dapm,
+				const char *pin)
+{
+	struct snd_soc_dapm_widget *w = dapm_find_widget(dapm, pin, false);
+
+	if (!w) {
+		dev_err(dapm->dev, "ASoC: unknown pin %s\n", pin);
+		return -EINVAL;
+	}
+
+	w->ignore_suspend = 1;
+
+	return 0;
+}
+EXPORT_SYMBOL_GPL(snd_soc_dapm_ignore_suspend);
+
+/**
+ * snd_soc_dapm_free - free dapm resources
+ * @dapm: DAPM context
+ *
+ * Free all dapm widgets and resources.
+ */
+void snd_soc_dapm_free(struct snd_soc_dapm_context *dapm)
+{
+	dapm_debugfs_cleanup(dapm);
+	dapm_free_widgets(dapm);
+	list_del(&dapm->list);
+}
+EXPORT_SYMBOL_GPL(snd_soc_dapm_free);
+
+static void soc_dapm_shutdown_dapm(struct snd_soc_dapm_context *dapm)
+{
+	struct snd_soc_card *card = dapm->card;
+	struct snd_soc_dapm_widget *w;
+	LIST_HEAD(down_list);
+	int powerdown = 0;
+
+	mutex_lock(&card->dapm_mutex);
+
+	list_for_each_entry(w, &dapm->card->widgets, list) {
+		if (w->dapm != dapm)
+			continue;
+		if (w->power) {
+			dapm_seq_insert(w, &down_list, false);
+			w->power = 0;
+			powerdown = 1;
+		}
+	}
+
+	/* If there were no widgets to power down we're already in
+	 * standby.
+	 */
+	if (powerdown) {
+		if (dapm->bias_level == SND_SOC_BIAS_ON)
+			snd_soc_dapm_set_bias_level(dapm,
+						    SND_SOC_BIAS_PREPARE);
+		dapm_seq_run(card, &down_list, 0, false);
+		if (dapm->bias_level == SND_SOC_BIAS_PREPARE)
+			snd_soc_dapm_set_bias_level(dapm,
+						    SND_SOC_BIAS_STANDBY);
+	}
+
+	mutex_unlock(&card->dapm_mutex);
+}
+
+/*
+ * snd_soc_dapm_shutdown - callback for system shutdown
+ */
+void snd_soc_dapm_shutdown(struct snd_soc_card *card)
+{
+	struct snd_soc_dapm_context *dapm;
+
+	list_for_each_entry(dapm, &card->dapm_list, list) {
+		if (dapm != &card->dapm) {
+			soc_dapm_shutdown_dapm(dapm);
+			if (dapm->bias_level == SND_SOC_BIAS_STANDBY)
+				snd_soc_dapm_set_bias_level(dapm,
+							    SND_SOC_BIAS_OFF);
+		}
+	}
+
+	soc_dapm_shutdown_dapm(&card->dapm);
+	if (card->dapm.bias_level == SND_SOC_BIAS_STANDBY)
+		snd_soc_dapm_set_bias_level(&card->dapm,
+					    SND_SOC_BIAS_OFF);
+}
+
+/* Module information */
+MODULE_AUTHOR("Liam Girdwood, lrg@slimlogic.co.uk");
+MODULE_DESCRIPTION("Dynamic Audio Power Management core for ALSA SoC");
+MODULE_LICENSE("GPL");
diff -Nru a/sound/soc/soc-io.c b/sound/soc/soc-io.c
--- a/sound/soc/soc-io.c	2015-08-16 23:52:51.000000000 -0400
+++ b/sound/soc/soc-io.c	2015-08-22 16:54:09.952983000 -0400
@@ -271,3 +271,31 @@
 	return snd_soc_component_write(&platform->component, reg, val);
 }
 EXPORT_SYMBOL_GPL(snd_soc_platform_write);
+
+/**
+ * snd_soc_component_init_io() - Initialize regmap IO
+ *
+ * @component: component to initialize
+ * @regmap: regmap instance to use for IO operations
+ *
+ * Return: 0 on success, a negative error code otherwise
+ */
+int snd_soc_component_init_io(struct snd_soc_component *component,
+	struct regmap *regmap)
+{
+	int ret;
+
+	if (!regmap)
+		return -EINVAL;
+
+	ret = regmap_get_val_bytes(regmap);
+	/* Errors are legitimate for non-integer byte
+	 * multiples */
+	if (ret > 0)
+		component->val_bytes = ret;
+
+	component->regmap = regmap;
+
+	return 0;
+}
+EXPORT_SYMBOL_GPL(snd_soc_component_init_io);
diff -Nru a/sound/soc/soc-jack.c b/sound/soc/soc-jack.c
--- a/sound/soc/soc-jack.c	2015-08-16 23:52:51.000000000 -0400
+++ b/sound/soc/soc-jack.c	2015-08-22 16:54:09.952983000 -0400
@@ -22,42 +22,30 @@
 #include <trace/events/asoc.h>
 
 /**
- * snd_soc_card_jack_new - Create a new jack
- * @card:  ASoC card
+ * snd_soc_jack_new - Create a new jack
+ * @codec: ASoC codec
  * @id:    an identifying string for this jack
  * @type:  a bitmask of enum snd_jack_type values that can be detected by
  *         this jack
  * @jack:  structure to use for the jack
- * @pins:  Array of jack pins to be added to the jack or NULL
- * @num_pins: Number of elements in the @pins array
  *
  * Creates a new jack object.
  *
  * Returns zero if successful, or a negative error code on failure.
  * On success jack will be initialised.
  */
-int snd_soc_card_jack_new(struct snd_soc_card *card, const char *id, int type,
-	struct snd_soc_jack *jack, struct snd_soc_jack_pin *pins,
-	unsigned int num_pins)
+int snd_soc_jack_new(struct snd_soc_codec *codec, const char *id, int type,
+		     struct snd_soc_jack *jack)
 {
-	int ret;
-
 	mutex_init(&jack->mutex);
-	jack->card = card;
+	jack->codec = codec;
 	INIT_LIST_HEAD(&jack->pins);
 	INIT_LIST_HEAD(&jack->jack_zones);
 	BLOCKING_INIT_NOTIFIER_HEAD(&jack->notifier);
 
-	ret = snd_jack_new(card->snd_card, id, type, &jack->jack);
-	if (ret)
-		return ret;
-
-	if (num_pins)
-		return snd_soc_jack_add_pins(jack, num_pins, pins);
-
-	return 0;
+	return snd_jack_new(codec->component.card->snd_card, id, type, &jack->jack);
 }
-EXPORT_SYMBOL_GPL(snd_soc_card_jack_new);
+EXPORT_SYMBOL_GPL(snd_soc_jack_new);
 
 /**
  * snd_soc_jack_report - Report the current status for a jack
@@ -75,6 +63,7 @@
  */
 void snd_soc_jack_report(struct snd_soc_jack *jack, int status, int mask)
 {
+	struct snd_soc_codec *codec;
 	struct snd_soc_dapm_context *dapm;
 	struct snd_soc_jack_pin *pin;
 	unsigned int sync = 0;
@@ -85,7 +74,8 @@
 	if (!jack)
 		return;
 
-	dapm = &jack->card->dapm;
+	codec = jack->codec;
+	dapm =  &codec->dapm;
 
 	mutex_lock(&jack->mutex);
 
@@ -126,7 +116,7 @@
  *
  * @jack:  ASoC jack
  * @count: Number of zones
- * @zones:  Array of zones
+ * @zone:  Array of zones
  *
  * After this function has been called the zones specified in the
  * array will be associated with the jack.
@@ -185,12 +175,12 @@
 
 	for (i = 0; i < count; i++) {
 		if (!pins[i].pin) {
-			dev_err(jack->card->dev, "ASoC: No name for pin %d\n",
+			dev_err(jack->codec->dev, "ASoC: No name for pin %d\n",
 				i);
 			return -EINVAL;
 		}
 		if (!pins[i].mask) {
-			dev_err(jack->card->dev, "ASoC: No mask for pin %d"
+			dev_err(jack->codec->dev, "ASoC: No mask for pin %d"
 				" (%s)\n", i, pins[i].pin);
 			return -EINVAL;
 		}
@@ -245,7 +235,7 @@
 
 #ifdef CONFIG_GPIOLIB
 /* gpio detect */
-static void snd_soc_jack_gpio_detect(struct snd_soc_jack_gpio *gpio)
+void snd_soc_jack_gpio_detect(struct snd_soc_jack_gpio *gpio)
 {
 	struct snd_soc_jack *jack = gpio->jack;
 	int enable;
@@ -265,12 +255,13 @@
 
 	snd_soc_jack_report(jack, report, gpio->report);
 }
+EXPORT_SYMBOL(snd_soc_jack_gpio_detect);
 
 /* irq handler for gpio pin */
 static irqreturn_t gpio_handler(int irq, void *data)
 {
 	struct snd_soc_jack_gpio *gpio = data;
-	struct device *dev = gpio->jack->card->dev;
+	struct device *dev = gpio->jack->codec->component.card->dev;
 
 	trace_snd_soc_jack_irq(gpio->name);
 
@@ -309,7 +300,7 @@
 
 	for (i = 0; i < count; i++) {
 		if (!gpios[i].name) {
-			dev_err(jack->card->dev,
+			dev_err(jack->codec->dev,
 				"ASoC: No name for gpio at index %d\n", i);
 			ret = -EINVAL;
 			goto undo;
@@ -319,7 +310,7 @@
 			/* GPIO descriptor */
 			gpios[i].desc = gpiod_get_index(gpios[i].gpiod_dev,
 							gpios[i].name,
-							gpios[i].idx, GPIOD_IN);
+							gpios[i].idx);
 			if (IS_ERR(gpios[i].desc)) {
 				ret = PTR_ERR(gpios[i].desc);
 				dev_err(gpios[i].gpiod_dev,
@@ -330,21 +321,24 @@
 		} else {
 			/* legacy GPIO number */
 			if (!gpio_is_valid(gpios[i].gpio)) {
-				dev_err(jack->card->dev,
+				dev_err(jack->codec->dev,
 					"ASoC: Invalid gpio %d\n",
 					gpios[i].gpio);
 				ret = -EINVAL;
 				goto undo;
 			}
 
-			ret = gpio_request_one(gpios[i].gpio, GPIOF_IN,
-					       gpios[i].name);
+			ret = gpio_request(gpios[i].gpio, gpios[i].name);
 			if (ret)
 				goto undo;
 
 			gpios[i].desc = gpio_to_desc(gpios[i].gpio);
 		}
 
+		ret = gpiod_direction_input(gpios[i].desc);
+		if (ret)
+			goto err;
+
 		INIT_DELAYED_WORK(&gpios[i].work, gpio_work);
 		gpios[i].jack = jack;
 
@@ -360,7 +354,7 @@
 		if (gpios[i].wake) {
 			ret = irq_set_irq_wake(gpiod_to_irq(gpios[i].desc), 1);
 			if (ret != 0)
-				dev_err(jack->card->dev,
+				dev_err(jack->codec->dev,
 					"ASoC: Failed to mark GPIO at index %d as wake source: %d\n",
 					i, ret);
 		}
diff -Nru a/sound/soc/soc-pcm.c b/sound/soc/soc-pcm.c
--- a/sound/soc/soc-pcm.c	2015-08-16 23:52:51.000000000 -0400
+++ b/sound/soc/soc-pcm.c	2015-08-22 16:54:09.953983000 -0400
@@ -301,18 +301,34 @@
 	return symmetry;
 }
 
+/*
+ * List of sample sizes that might go over the bus for parameter
+ * application.  There ought to be a wildcard sample size for things
+ * like the DAC/ADC resolution to use but there isn't right now.
+ */
+static int sample_sizes[] = {
+	24, 32,
+};
+
 static void soc_pcm_set_msb(struct snd_pcm_substream *substream, int bits)
 {
 	struct snd_soc_pcm_runtime *rtd = substream->private_data;
-	int ret;
+	int ret, i;
 
 	if (!bits)
 		return;
 
-	ret = snd_pcm_hw_constraint_msbits(substream->runtime, 0, 0, bits);
-	if (ret != 0)
-		dev_warn(rtd->dev, "ASoC: Failed to set MSB %d: %d\n",
-				 bits, ret);
+	for (i = 0; i < ARRAY_SIZE(sample_sizes); i++) {
+		if (bits >= sample_sizes[i])
+			continue;
+
+		ret = snd_pcm_hw_constraint_msbits(substream->runtime, 0,
+						   sample_sizes[i], bits);
+		if (ret != 0)
+			dev_warn(rtd->dev,
+				 "ASoC: Failed to set MSB %d/%d: %d\n",
+				 bits, sample_sizes[i], ret);
+	}
 }
 
 static void soc_pcm_apply_msb(struct snd_pcm_substream *substream)
@@ -336,7 +352,7 @@
 	} else {
 		for (i = 0; i < rtd->num_codecs; i++) {
 			codec_dai = rtd->codec_dais[i];
-			if (codec_dai->driver->capture.sig_bits == 0) {
+			if (codec_dai->driver->playback.sig_bits == 0) {
 				bits = 0;
 				break;
 			}
@@ -638,8 +654,6 @@
 			codec_dai->rate = 0;
 	}
 
-	snd_soc_dai_digital_mute(cpu_dai, 1, substream->stream);
-
 	if (cpu_dai->driver->ops->shutdown)
 		cpu_dai->driver->ops->shutdown(substream, cpu_dai);
 
@@ -730,8 +744,7 @@
 							      codec_dai);
 			if (ret < 0) {
 				dev_err(codec_dai->dev,
-					"ASoC: codec DAI prepare error: %d\n",
-					ret);
+					"ASoC: DAI prepare error: %d\n", ret);
 				goto out;
 			}
 		}
@@ -740,8 +753,8 @@
 	if (cpu_dai->driver->ops && cpu_dai->driver->ops->prepare) {
 		ret = cpu_dai->driver->ops->prepare(substream, cpu_dai);
 		if (ret < 0) {
-			dev_err(cpu_dai->dev,
-				"ASoC: cpu DAI prepare error: %d\n", ret);
+			dev_err(cpu_dai->dev, "ASoC: DAI prepare error: %d\n",
+				ret);
 			goto out;
 		}
 	}
@@ -759,7 +772,6 @@
 	for (i = 0; i < rtd->num_codecs; i++)
 		snd_soc_dai_digital_mute(rtd->codec_dais[i], 0,
 					 substream->stream);
-	snd_soc_dai_digital_mute(cpu_dai, 0, substream->stream);
 
 out:
 	mutex_unlock(&rtd->pcm_mutex);
@@ -1097,9 +1109,8 @@
 			stream ? "<-" : "->", be->dai_link->name);
 
 #ifdef CONFIG_DEBUG_FS
-	if (fe->debugfs_dpcm_root)
-		dpcm->debugfs_state = debugfs_create_u32(be->dai_link->name, 0644,
-				fe->debugfs_dpcm_root, &dpcm->state);
+	dpcm->debugfs_state = debugfs_create_u32(be->dai_link->name, 0644,
+			fe->debugfs_dpcm_root, &dpcm->state);
 #endif
 	return 1;
 }
@@ -1511,36 +1522,13 @@
 		dpcm_init_runtime_hw(runtime, &cpu_dai_drv->capture);
 }
 
-static int dpcm_fe_dai_do_trigger(struct snd_pcm_substream *substream, int cmd);
-
-/* Set FE's runtime_update state; the state is protected via PCM stream lock
- * for avoiding the race with trigger callback.
- * If the state is unset and a trigger is pending while the previous operation,
- * process the pending trigger action here.
- */
-static void dpcm_set_fe_update_state(struct snd_soc_pcm_runtime *fe,
-				     int stream, enum snd_soc_dpcm_update state)
-{
-	struct snd_pcm_substream *substream =
-		snd_soc_dpcm_get_substream(fe, stream);
-
-	snd_pcm_stream_lock_irq(substream);
-	if (state == SND_SOC_DPCM_UPDATE_NO && fe->dpcm[stream].trigger_pending) {
-		dpcm_fe_dai_do_trigger(substream,
-				       fe->dpcm[stream].trigger_pending - 1);
-		fe->dpcm[stream].trigger_pending = 0;
-	}
-	fe->dpcm[stream].runtime_update = state;
-	snd_pcm_stream_unlock_irq(substream);
-}
-
 static int dpcm_fe_dai_startup(struct snd_pcm_substream *fe_substream)
 {
 	struct snd_soc_pcm_runtime *fe = fe_substream->private_data;
 	struct snd_pcm_runtime *runtime = fe_substream->runtime;
 	int stream = fe_substream->stream, ret = 0;
 
-	dpcm_set_fe_update_state(fe, stream, SND_SOC_DPCM_UPDATE_FE);
+	fe->dpcm[stream].runtime_update = SND_SOC_DPCM_UPDATE_FE;
 
 	ret = dpcm_be_dai_startup(fe, fe_substream->stream);
 	if (ret < 0) {
@@ -1562,13 +1550,13 @@
 	dpcm_set_fe_runtime(fe_substream);
 	snd_pcm_limit_hw_rates(runtime);
 
-	dpcm_set_fe_update_state(fe, stream, SND_SOC_DPCM_UPDATE_NO);
+	fe->dpcm[stream].runtime_update = SND_SOC_DPCM_UPDATE_NO;
 	return 0;
 
 unwind:
 	dpcm_be_dai_startup_unwind(fe, fe_substream->stream);
 be_err:
-	dpcm_set_fe_update_state(fe, stream, SND_SOC_DPCM_UPDATE_NO);
+	fe->dpcm[stream].runtime_update = SND_SOC_DPCM_UPDATE_NO;
 	return ret;
 }
 
@@ -1615,7 +1603,7 @@
 	struct snd_soc_pcm_runtime *fe = substream->private_data;
 	int stream = substream->stream;
 
-	dpcm_set_fe_update_state(fe, stream, SND_SOC_DPCM_UPDATE_FE);
+	fe->dpcm[stream].runtime_update = SND_SOC_DPCM_UPDATE_FE;
 
 	/* shutdown the BEs */
 	dpcm_be_dai_shutdown(fe, substream->stream);
@@ -1629,7 +1617,7 @@
 	dpcm_dapm_stream_event(fe, stream, SND_SOC_DAPM_STREAM_STOP);
 
 	fe->dpcm[stream].state = SND_SOC_DPCM_STATE_CLOSE;
-	dpcm_set_fe_update_state(fe, stream, SND_SOC_DPCM_UPDATE_NO);
+	fe->dpcm[stream].runtime_update = SND_SOC_DPCM_UPDATE_NO;
 	return 0;
 }
 
@@ -1653,10 +1641,6 @@
 		if (!snd_soc_dpcm_can_be_free_stop(fe, be, stream))
 				continue;
 
-		/* do not free hw if this BE is used by other FE */
-		if (be->dpcm[stream].users > 1)
-			continue;
-
 		if ((be->dpcm[stream].state != SND_SOC_DPCM_STATE_HW_PARAMS) &&
 		    (be->dpcm[stream].state != SND_SOC_DPCM_STATE_PREPARE) &&
 		    (be->dpcm[stream].state != SND_SOC_DPCM_STATE_HW_FREE) &&
@@ -1681,7 +1665,7 @@
 	int err, stream = substream->stream;
 
 	mutex_lock_nested(&fe->card->mutex, SND_SOC_CARD_CLASS_RUNTIME);
-	dpcm_set_fe_update_state(fe, stream, SND_SOC_DPCM_UPDATE_FE);
+	fe->dpcm[stream].runtime_update = SND_SOC_DPCM_UPDATE_FE;
 
 	dev_dbg(fe->dev, "ASoC: hw_free FE %s\n", fe->dai_link->name);
 
@@ -1696,7 +1680,7 @@
 	err = dpcm_be_dai_hw_free(fe, stream);
 
 	fe->dpcm[stream].state = SND_SOC_DPCM_STATE_HW_FREE;
-	dpcm_set_fe_update_state(fe, stream, SND_SOC_DPCM_UPDATE_NO);
+	fe->dpcm[stream].runtime_update = SND_SOC_DPCM_UPDATE_NO;
 
 	mutex_unlock(&fe->card->mutex);
 	return 0;
@@ -1789,7 +1773,7 @@
 	int ret, stream = substream->stream;
 
 	mutex_lock_nested(&fe->card->mutex, SND_SOC_CARD_CLASS_RUNTIME);
-	dpcm_set_fe_update_state(fe, stream, SND_SOC_DPCM_UPDATE_FE);
+	fe->dpcm[stream].runtime_update = SND_SOC_DPCM_UPDATE_FE;
 
 	memcpy(&fe->dpcm[substream->stream].hw_params, params,
 			sizeof(struct snd_pcm_hw_params));
@@ -1812,7 +1796,7 @@
 		fe->dpcm[stream].state = SND_SOC_DPCM_STATE_HW_PARAMS;
 
 out:
-	dpcm_set_fe_update_state(fe, stream, SND_SOC_DPCM_UPDATE_NO);
+	fe->dpcm[stream].runtime_update = SND_SOC_DPCM_UPDATE_NO;
 	mutex_unlock(&fe->card->mutex);
 	return ret;
 }
@@ -1926,7 +1910,7 @@
 }
 EXPORT_SYMBOL_GPL(dpcm_be_dai_trigger);
 
-static int dpcm_fe_dai_do_trigger(struct snd_pcm_substream *substream, int cmd)
+static int dpcm_fe_dai_trigger(struct snd_pcm_substream *substream, int cmd)
 {
 	struct snd_soc_pcm_runtime *fe = substream->private_data;
 	int stream = substream->stream, ret;
@@ -2000,23 +1984,6 @@
 	return ret;
 }
 
-static int dpcm_fe_dai_trigger(struct snd_pcm_substream *substream, int cmd)
-{
-	struct snd_soc_pcm_runtime *fe = substream->private_data;
-	int stream = substream->stream;
-
-	/* if FE's runtime_update is already set, we're in race;
-	 * process this trigger later at exit
-	 */
-	if (fe->dpcm[stream].runtime_update != SND_SOC_DPCM_UPDATE_NO) {
-		fe->dpcm[stream].trigger_pending = cmd + 1;
-		return 0; /* delayed, assuming it's successful */
-	}
-
-	/* we're alone, let's trigger */
-	return dpcm_fe_dai_do_trigger(substream, cmd);
-}
-
 int dpcm_be_dai_prepare(struct snd_soc_pcm_runtime *fe, int stream)
 {
 	struct snd_soc_dpcm *dpcm;
@@ -2060,7 +2027,7 @@
 
 	dev_dbg(fe->dev, "ASoC: prepare FE %s\n", fe->dai_link->name);
 
-	dpcm_set_fe_update_state(fe, stream, SND_SOC_DPCM_UPDATE_FE);
+	fe->dpcm[stream].runtime_update = SND_SOC_DPCM_UPDATE_FE;
 
 	/* there is no point preparing this FE if there are no BEs */
 	if (list_empty(&fe->dpcm[stream].be_clients)) {
@@ -2087,7 +2054,7 @@
 	fe->dpcm[stream].state = SND_SOC_DPCM_STATE_PREPARE;
 
 out:
-	dpcm_set_fe_update_state(fe, stream, SND_SOC_DPCM_UPDATE_NO);
+	fe->dpcm[stream].runtime_update = SND_SOC_DPCM_UPDATE_NO;
 	mutex_unlock(&fe->card->mutex);
 
 	return ret;
@@ -2234,11 +2201,11 @@
 {
 	int ret;
 
-	dpcm_set_fe_update_state(fe, stream, SND_SOC_DPCM_UPDATE_BE);
+	fe->dpcm[stream].runtime_update = SND_SOC_DPCM_UPDATE_BE;
 	ret = dpcm_run_update_startup(fe, stream);
 	if (ret < 0)
 		dev_err(fe->dev, "ASoC: failed to startup some BEs\n");
-	dpcm_set_fe_update_state(fe, stream, SND_SOC_DPCM_UPDATE_NO);
+	fe->dpcm[stream].runtime_update = SND_SOC_DPCM_UPDATE_NO;
 
 	return ret;
 }
@@ -2247,11 +2214,11 @@
 {
 	int ret;
 
-	dpcm_set_fe_update_state(fe, stream, SND_SOC_DPCM_UPDATE_BE);
+	fe->dpcm[stream].runtime_update = SND_SOC_DPCM_UPDATE_BE;
 	ret = dpcm_run_update_shutdown(fe, stream);
 	if (ret < 0)
 		dev_err(fe->dev, "ASoC: failed to shutdown some BEs\n");
-	dpcm_set_fe_update_state(fe, stream, SND_SOC_DPCM_UPDATE_NO);
+	fe->dpcm[stream].runtime_update = SND_SOC_DPCM_UPDATE_NO;
 
 	return ret;
 }
@@ -2281,13 +2248,7 @@
 			fe->dai_link->name);
 
 		/* skip if FE doesn't have playback capability */
-		if (!fe->cpu_dai->driver->playback.channels_min
-		    || !fe->codec_dai->driver->playback.channels_min)
-			goto capture;
-
-		/* skip if FE isn't currently playing */
-		if (!fe->cpu_dai->playback_active
-		    || !fe->codec_dai->playback_active)
+		if (!fe->cpu_dai->driver->playback.channels_min)
 			goto capture;
 
 		paths = dpcm_path_get(fe, SNDRV_PCM_STREAM_PLAYBACK, &list);
@@ -2317,13 +2278,7 @@
 		dpcm_path_put(&list);
 capture:
 		/* skip if FE doesn't have capture capability */
-		if (!fe->cpu_dai->driver->capture.channels_min
-		    || !fe->codec_dai->driver->capture.channels_min)
-			continue;
-
-		/* skip if FE isn't currently capturing */
-		if (!fe->cpu_dai->capture_active
-		    || !fe->codec_dai->capture_active)
+		if (!fe->cpu_dai->driver->capture.channels_min)
 			continue;
 
 		paths = dpcm_path_get(fe, SNDRV_PCM_STREAM_CAPTURE, &list);
@@ -2397,11 +2352,7 @@
 	mutex_lock_nested(&fe->card->mutex, SND_SOC_CARD_CLASS_RUNTIME);
 	fe->dpcm[stream].runtime = fe_substream->runtime;
 
-	ret = dpcm_path_get(fe, stream, &list);
-	if (ret < 0) {
-		mutex_unlock(&fe->card->mutex);
-		return ret;
-	} else if (ret == 0) {
+	if (dpcm_path_get(fe, stream, &list) <= 0) {
 		dev_dbg(fe->dev, "ASoC: %s no valid %s route\n",
 			fe->dai_link->name, stream ? "capture" : "playback");
 	}
@@ -2512,7 +2463,6 @@
 	/* DAPM dai link stream work */
 	INIT_DELAYED_WORK(&rtd->delayed_work, close_delayed_work);
 
-	pcm->nonatomic = rtd->dai_link->nonatomic;
 	rtd->pcm = pcm;
 	pcm->private_data = rtd;
 
@@ -2804,13 +2754,10 @@
 	.llseek = default_llseek,
 };
 
-void soc_dpcm_debugfs_add(struct snd_soc_pcm_runtime *rtd)
+int soc_dpcm_debugfs_add(struct snd_soc_pcm_runtime *rtd)
 {
 	if (!rtd->dai_link)
-		return;
-
-	if (!rtd->card->debugfs_card_root)
-		return;
+		return 0;
 
 	rtd->debugfs_dpcm_root = debugfs_create_dir(rtd->dai_link->name,
 			rtd->card->debugfs_card_root);
@@ -2818,11 +2765,13 @@
 		dev_dbg(rtd->dev,
 			 "ASoC: Failed to create dpcm debugfs directory %s\n",
 			 rtd->dai_link->name);
-		return;
+		return -EINVAL;
 	}
 
 	rtd->debugfs_dpcm_state = debugfs_create_file("state", 0444,
 						rtd->debugfs_dpcm_root,
 						rtd, &dpcm_state_fops);
+
+	return 0;
 }
 #endif
